<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />




  


  <link rel="alternate" href="/atom.xml" title="聪菌粑粑" type="application/atom+xml" />






<meta name="description" content="chanchannel是Golang在语言层面提供的goroutine间的通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信，如果需要跨进程通信，建议使用分布式系统的方法来解决。  chan数据结构12345678910111213type hchan struct &amp;#123;    qcount   uint           &#x2F;&#x2F; 当前队列中剩余">
<meta property="og:type" content="article">
<meta property="og:title" content="go常见数据结构实现原理">
<meta property="og:url" content="http://yoursite.com/2020/10/02/go%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="聪菌粑粑">
<meta property="og:description" content="chanchannel是Golang在语言层面提供的goroutine间的通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信，如果需要跨进程通信，建议使用分布式系统的方法来解决。  chan数据结构12345678910111213type hchan struct &amp;#123;    qcount   uint           &#x2F;&#x2F; 当前队列中剩余">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_f1b42d200c5d94d02eeacef7c99aa81b_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_f48c37e012c38de53aeb532c993b6d2d_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_b235ef1f2c6ac1b5d63ec5660da97bd2_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_933ca9af4c3ec1db0b94b8b4ec208d4b_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_332a02ff2dc338bb2cce150a23d37b1c_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_c6aff21b79ce0b735065a702cb84c684_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_a87b8e2fb06bff1ea78f6096b7e81325_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_897a05f6373f7f966d00d1bfea6274d2_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_7f0ba5a124641b1413279892581513c4_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_a8b9e5919d9951a71c1c36445dd68521_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_2d622a6bc19ca1b5bcb225f77869f9c2_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_2f0122f26e5d66ca91e6820ace6b379b_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_b1178e0a3cea02c9386e5f5eaa6f99a6_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_f3a5989c90204df9304d5ae246f3db72_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_0317d71784cf0c9b1a00cee014429c40_r.png">
<meta property="og:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_5f500d01a01d45f69ea523a1789f9748_r.png">
<meta property="article:published_time" content="2020-10-02T10:48:42.000Z">
<meta property="article:modified_time" content="2020-10-31T12:08:46.421Z">
<meta property="article:author" content="Cong">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wen.topgoer.com/uploads/gozhuanjia/images/m_f1b42d200c5d94d02eeacef7c99aa81b_r.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/10/02/go常见数据结构实现原理/"/>





  <title>go常见数据结构实现原理 | 聪菌粑粑</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">聪菌粑粑</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">希望你觉得认识我是件幸运的事</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/02/go%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="聪菌粑粑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">go常见数据结构实现原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-02T18:48:42+08:00">
                2020-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h1><p>channel是Golang在语言层面提供的goroutine间的通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信，如果需要跨进程通信，建议使用分布式系统的方法来解决。 </p>
<h2 id="chan数据结构"><a href="#chan数据结构" class="headerlink" title="chan数据结构"></a>chan数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// 当前队列中剩余元素个数</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// 环形队列长度，即可以存放的元素个数</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">    closed   <span class="keyword">uint32</span>            <span class="comment">// 标识关闭状态</span></span><br><span class="line">    elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>           <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>           <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">    recvq    waitq          <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">    sendq    waitq          <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line">    lock mutex              <span class="comment">// 互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从数据结构可以看出channel由队列、类型信息、goroutine等待队列组成 </p>
<h3 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h3><p>chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。 </p>
<p>下图展示了一个可缓存6个元素的channel示意图： </p>
<p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_f1b42d200c5d94d02eeacef7c99aa81b_r.png" alt="channel示意图"></p>
<ul>
<li>dataqsiz指示了队列长度为6，即可缓存6个元素；</li>
<li>buf指向队列的内存，队列中还剩余两个元素；</li>
<li>qcount表示队列中还有两个元素；</li>
<li>sendx指示后续写入的数据存储的位置，取值[0, 6)；</li>
<li>recvx指示从该位置读取数据, 取值[0, 6)；</li>
</ul>
<h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。<br>向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。</p>
<p>被阻塞的goroutine将会挂在channel的等待队列中：</p>
<ul>
<li>因读阻塞的goroutine会被向channel写入数据的goroutine唤醒；</li>
<li>因写阻塞的goroutine会被从channel读数据的goroutine唤醒；</li>
</ul>
<p>下图展示了一个没有缓冲区的channel，有几个goroutine阻塞等待读数据：</p>
<p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_f48c37e012c38de53aeb532c993b6d2d_r.png" alt="等待队列"></p>
<p>注意，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。 </p>
<h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。</p>
<ul>
<li>elemtype代表类型，用于数据传递过程中的赋值；</li>
<li>elemsize代表类型大小，用于在buf中定位元素位置。</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>一个channel同时只被goroutine读写</p>
<h2 id="channel的读写"><a href="#channel的读写" class="headerlink" title="channel的读写"></a>channel的读写</h2><h3 id="channel创建"><a href="#channel创建" class="headerlink" title="channel创建"></a>channel创建</h3><p>使用make关键字创建，在创建时需要写明chan内的信息类型，和缓冲区大小（可选项，可以创建无缓冲区的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan &#123;</span><br><span class="line">    var c *hchan</span><br><span class="line">    c &#x3D; new(hchan)</span><br><span class="line">    c.buf &#x3D; malloc(元素类型大小*size)</span><br><span class="line">    c.elemsize &#x3D; 元素类型大小</span><br><span class="line">    c.elemtype &#x3D; 元素类型</span><br><span class="line">    c.dataqsiz &#x3D; size</span><br><span class="line"></span><br><span class="line">    return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="channel写入数据"><a href="#channel写入数据" class="headerlink" title="channel写入数据"></a>channel写入数据</h3><p>向一个channel中写数据简单过程如下：</p>
<ol>
<li>如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；</li>
<li>如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；</li>
<li>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；</li>
</ol>
<p>简单流程图如下：</p>
<p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_b235ef1f2c6ac1b5d63ec5660da97bd2_r.png" alt="写入数据的流程"></p>
<h3 id="从channel读数据"><a href="#从channel读数据" class="headerlink" title="从channel读数据"></a>从channel读数据</h3><p>从一个channel读数据简单过程如下：</p>
<ol>
<li>如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；</li>
<li>如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；</li>
<li>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；</li>
<li>将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；</li>
</ol>
<p>简单流程图如下：</p>
<p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_933ca9af4c3ec1db0b94b8b4ec208d4b_r.png" alt=""></p>
<h3 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h3><p>关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。</p>
<p>除此之外，panic出现的常见场景还有：</p>
<ol>
<li>关闭值为nil的channel</li>
<li>关闭已经被关闭的channel</li>
<li>向已经关闭的channel写数据</li>
</ol>
<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><p>Slice又称动态数组，依托数组实现，可以方便的进行扩容、传递等，实际使用中比数组更灵活。 </p>
<p><strong>切片与底层数组共享一个内容地址，当切片的值改变时会影响底层数组的值也一起改变，当切片扩容时会重新申请内存地址，此时切片不会再影响底层数组</strong></p>
<p><strong>Slice依托数组实现，底层数组对用户屏蔽，在底层数组容量不足时可以实现自动重分配并生成新的Slice。 接下来按照实际使用场景分别介绍其实现机制。</strong></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer<span class="comment">//指向底层数组</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span><span class="comment">//长度</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span><span class="comment">//容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用make创建Slice"><a href="#使用make创建Slice" class="headerlink" title="使用make创建Slice"></a>使用make创建Slice</h3><p>使用make来创建Slice时，可以同时指定长度和容量，创建时底层会分配一个数组，数组的长度即容量。</p>
<p>例如，语句<code>slice := make([]int, 5, 10)</code>所创建的Slice，结构如下图所示：</p>
<p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_332a02ff2dc338bb2cce150a23d37b1c_r.png" alt=""></p>
<p>该Slice长度为5，即可以使用下标slice[0] ~ slice[4]来操作里面的元素，capacity为10，表示后续向slice添加新的元素时可以不必重新分配内存，直接使用预留内存即可。 </p>
<h3 id="使用数组创建Slice"><a href="#使用数组创建Slice" class="headerlink" title="使用数组创建Slice"></a>使用数组创建Slice</h3><p>使用数组来创建Slice时，Slice将与原数组共用一部分内存。</p>
<p>例如，语句<code>slice := array[5:7]</code>所创建的Slice，结构如下图所示：</p>
<p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_c6aff21b79ce0b735065a702cb84c684_r.png" alt=""></p>
<p>切片从数组array[5]开始，到数组array[7]结束（不含array[7]），即切片长度为2，<strong>数组后面的内容都作为切片的预留内存，即capacity为5。</strong></p>
<p><strong>数组和切片操作可能作用于同一块内存，这也是使用过程中需要注意的地方。</strong></p>
<h3 id="slice扩容"><a href="#slice扩容" class="headerlink" title="slice扩容"></a>slice扩容</h3><p>使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容，<strong>扩容实际上是重新分配一块更大的内存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去。</strong></p>
<p>例如，当向一个capacity为5，且length也为5的Slice再次追加1个元素时，就会发生扩容，如下图所示：</p>
<p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_a87b8e2fb06bff1ea78f6096b7e81325_r.png" alt="扩容地址"></p>
<p>扩容操作只关心容量，会把原Slice数据拷贝到新Slice，追加数据由append在扩容结束后完成。上图可见，扩容后新的Slice长度仍然是5，但容量由5提升到了10，原Slice的数据也都拷贝到了新Slice指向的数组中。</p>
<p>扩容容量的选择遵循以下规则：</p>
<ul>
<li>如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍；</li>
<li>如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍；</li>
</ul>
<p>使用append()向Slice添加一个元素的实现步骤如下：</p>
<ul>
<li>假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice</li>
<li>原Slice容量不够，则将Slice先扩容，扩容后得到新Slice</li>
<li>将新元素追加进新Slice，Slice.len++，返回新的Slice。</li>
</ul>
<h3 id="slice-copy"><a href="#slice-copy" class="headerlink" title="slice copy"></a>slice copy</h3><p>使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小值。</p>
<p>例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。</p>
<p><strong>也就是说，copy过程中不会发生扩容。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min= <span class="built_in">copy</span>(<span class="built_in">make</span>([]<span class="keyword">struct</span>&#123;&#125;,a),<span class="built_in">make</span>([]<span class="keyword">struct</span>&#123;&#125;,b))</span><br></pre></td></tr></table></figure>

<p>用在函数里可以表示返回a和b间的最小值</p>
<h3 id="特殊切片"><a href="#特殊切片" class="headerlink" title="特殊切片"></a>特殊切片</h3><p>根据数组或切片生成新的切片一般使用<code>slice := array[start:end]</code>方式，这种新生成的切片并没有指定切片的容量，实际上新切片的容量是从start开始直至array的结束。</p>
<p>比如下面两个切片，长度和容量都是一致的，使用共同的内存地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sliceA := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">sliceB := sliceA[<span class="number">0</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>根据数组或切片生成切片还有另一种写法，即切片同时也指定容量，即slice[start:end:cap], 其中cap即为新切片的容量，当然容量不能超过原切片实际值，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sliceA := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)  <span class="comment">//length = 5; capacity = 10</span></span><br><span class="line">sliceB := sliceA[<span class="number">0</span>:<span class="number">5</span>]         <span class="comment">//length = 5; capacity = 10</span></span><br><span class="line">sliceC := sliceA[<span class="number">0</span>:<span class="number">5</span>:<span class="number">5</span>]       <span class="comment">//length = 5; capacity = 5</span></span><br></pre></td></tr></table></figure>

<p>这切片方法不常见，在Golang源码里能够见到，不过非常利于切片的理解。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>创建切片时可根据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能；</li>
<li>切片拷贝时需要判断实际拷贝的元素个数</li>
<li>谨慎使用多个切片操作同一个数组，以防读写冲突</li>
<li>每个切片都指向一个底层数组</li>
<li>每个切片都保存了当前切片的长度、底层数组可用容量</li>
<li>使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片</li>
<li>使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片</li>
<li>通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而已</li>
<li>使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片</li>
</ul>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="map数据结构"><a href="#map数据结构" class="headerlink" title="map数据结构"></a>map数据结构</h2><p>Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="keyword">int</span> <span class="comment">// 当前保存的元素个数</span></span><br><span class="line">    ...</span><br><span class="line">    B         <span class="keyword">uint8</span></span><br><span class="line">    ...</span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// bucket数组指针，数组的大小为2^B</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图展示一个拥有4个bucket的map： </p>
<p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_897a05f6373f7f966d00d1bfea6274d2_r.png" alt=""></p>
<p>本例中, <code>hmap.B=2</code>， 而hmap.buckets长度是2^B为4. 元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。</p>
<p><code>bucket</code>很多时候被翻译为桶，所谓的<code>哈希桶</code>实际上就是bucket。</p>
<h2 id="bucket底层结构"><a href="#bucket底层结构" class="headerlink" title="bucket底层结构"></a>bucket底层结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [<span class="number">8</span>]<span class="keyword">uint8</span> <span class="comment">//存储哈希值的高8位</span></span><br><span class="line">    data    <span class="keyword">byte</span>[<span class="number">1</span>]  <span class="comment">//key value数据:key/key/key/.../value/value/value...</span></span><br><span class="line">    overflow *bmap   <span class="comment">//溢出bucket的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个bucket可以存储8个键值对。</p>
<ul>
<li>tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。</li>
<li>data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。</li>
<li>overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。</li>
</ul>
<p>注意：上述中data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。</p>
<p>下图展示bucket存放8个key-value对：</p>
<p> <img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_7f0ba5a124641b1413279892581513c4_r.png" alt=""></p>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。 由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。 </p>
<p>下图展示产生冲突后的map： </p>
<p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_a8b9e5919d9951a71c1c36445dd68521_r.png" alt=""></p>
<h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>负载因子用于衡量一个哈希表冲突情况，公式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负载因子 &#x3D; 键数量&#x2F;bucket数量</span><br></pre></td></tr></table></figure>

<p>例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1.</p>
<p>哈希表需要将负载因子控制在合适的大小，超过其阀+值需要进行rehash，也即键值对重新组织：</p>
<ul>
<li>哈希因子过小，说明空间利用率低</li>
<li>哈希因子过大，说明冲突严重，存取效率低</li>
</ul>
<p>每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。</p>
<h2 id="渐进式扩容"><a href="#渐进式扩容" class="headerlink" title="渐进式扩容"></a>渐进式扩容</h2><h3 id="扩容前提"><a href="#扩容前提" class="headerlink" title="扩容前提"></a>扩容前提</h3><p>为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。<br>触发扩容的条件有二个：</p>
<ol>
<li>负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。</li>
<li>overflow数量 &gt; 2^15时，也即overflow数量超过32768时</li>
</ol>
<h3 id="增量扩容"><a href="#增量扩容" class="headerlink" title="增量扩容"></a>增量扩容</h3><p>当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。<br>考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。</p>
<p>下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):</p>
<p> <img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_2d622a6bc19ca1b5bcb225f77869f9c2_r.png" alt=""></p>
<p>当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。</p>
<p>当第8个键值对插入时，将会触发扩容，扩容后示意图如下：</p>
<p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_2f0122f26e5d66ca91e6820ace6b379b_r.png" alt=""></p>
<p>hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。<br>后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。</p>
<p>搬迁完成后的示意图如下：</p>
<p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_b1178e0a3cea02c9386e5f5eaa6f99a6_r.png" alt=""></p>
<p>数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。 实际搬迁过程中比较复杂，将在后续源码分析中详细介绍。 </p>
<h3 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h3><p>所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。<br>在极端场景下，比如不断地增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：</p>
<p> <img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_f3a5989c90204df9304d5ae246f3db72_r.png" alt=""></p>
<p>上图可见，overflow的bucket中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。 </p>
<h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><p>查找过程如下：</p>
<ol>
<li>根据key值算出哈希值</li>
<li>取哈希值低位与hmap.B取模确定bucket位置</li>
<li>取哈希值高位在tophash数组中查询</li>
<li>如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较</li>
<li>当前bucket没有找到，则继续从下个overflow的bucket中查找。</li>
<li>如果当前处于搬迁过程，则优先从oldbuckets查找</li>
</ol>
<p>注：如果查找不到，也不会返回空值，而是返回相应类型的0值。</p>
<h2 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h2><p>新元素插入过程如下：</p>
<ol>
<li>根据key值算出哈希值</li>
<li>取哈希值低位与hmap.B取模确定bucket位置</li>
<li>查找该key是否已经存在，如果存在则直接更新值</li>
<li>如果没找到将key，将key插入</li>
</ol>
<h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><p>Go的struct声明允许字段附带<code>Tag</code>来对字段做一些标记。</p>
<p>该<code>Tag</code>不仅仅是一个字符串那么简单，因为其主要用于反射场景，<code>reflect</code>包中提供了操作<code>Tag</code>的方法，所以<code>Tag</code>写法也要遵循一定的规则。</p>
<h2 id="Tag的本质"><a href="#Tag的本质" class="headerlink" title="Tag的本质"></a>Tag的本质</h2><h3 id="Tag规则"><a href="#Tag规则" class="headerlink" title="Tag规则"></a>Tag规则</h3><p><code>Tag</code>本身是一个字符串，但字符串中却是：<code>以空格分隔的 key:value 对</code>。</p>
<ul>
<li><code>key</code>: 必须是非空字符串，字符串不能包含控制字符、空格、引号、冒号。</li>
<li><code>value</code>: 以双引号标记的字符串</li>
<li>注意：冒号前后不能有空格</li>
</ul>
<p>如下代码所示，如此写没有实际意义，仅用于说明<code>Tag</code>规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Server struct &#123;</span><br><span class="line">    ServerName string &#96;key1: &quot;value1&quot; key11:&quot;value11&quot;&#96;</span><br><span class="line">    ServerIP   string &#96;key2: &quot;value2&quot;&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码<code>ServerName</code>字段的<code>Tag</code>包含两个key-value对。<code>ServerIP</code>字段的<code>Tag</code>只包含一个key-value对。</p>
<h3 id="Tag是Struct的一部分"><a href="#Tag是Struct的一部分" class="headerlink" title="Tag是Struct的一部分"></a>Tag是Struct的一部分</h3><p>前面说过，<code>Tag</code>只有在反射场景中才有用，而反射包中提供了操作<code>Tag</code>的方法。在说方法前，有必要先了解一下Go是如何管理struct字段的。</p>
<p>以下是<code>reflect</code>包中的类型声明，省略了部分与本文无关的字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A StructField describes a single field in a struct.</span><br><span class="line">type StructField struct &#123;</span><br><span class="line">    &#x2F;&#x2F; Name is the field name.</span><br><span class="line">    Name string</span><br><span class="line">    ...</span><br><span class="line">    Type      Type      &#x2F;&#x2F; field type</span><br><span class="line">    Tag       StructTag &#x2F;&#x2F; field tag string</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StructTag string</span><br></pre></td></tr></table></figure>

<p>可见，描述一个结构体成员的结构中包含了<code>StructTag</code>，而其本身是一个<code>string</code>。也就是说<code>Tag</code>其实是结构体字段的一个组成部分</p>
<h3 id="获取tag"><a href="#获取tag" class="headerlink" title="获取tag"></a>获取tag</h3><p><code>StructTag</code>提供了<code>Get(key string) string</code>方法来获取<code>Tag</code>，示例如下： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    ServerName <span class="keyword">string</span> <span class="string">`key1:"value1" key11:"value11"`</span></span><br><span class="line">    ServerIP   <span class="keyword">string</span> <span class="string">`key2:"value2"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Server&#123;&#125;</span><br><span class="line">    st := reflect.TypeOf(s)</span><br><span class="line"></span><br><span class="line">    field1 := st.Field(<span class="number">0</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"key1:%v\n"</span>, field1.Tag.Get(<span class="string">"key1"</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"key11:%v\n"</span>, field1.Tag.Get(<span class="string">"key11"</span>))</span><br><span class="line"></span><br><span class="line">    filed2 := st.Field(<span class="number">1</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"key2:%v\n"</span>, filed2.Tag.Get(<span class="string">"key2"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key1:value1</span><br><span class="line">key11:value11</span><br><span class="line">key2:value2</span><br></pre></td></tr></table></figure>

<h2 id="Tag存在的意义"><a href="#Tag存在的意义" class="headerlink" title="Tag存在的意义"></a>Tag存在的意义</h2><p>本文示例中tag没有任何实际意义，这是为了阐述tag的定义与操作方法，也为了避免与你之前见过的诸如<code>json:xxx</code>混淆。</p>
<p>使用反射可以动态的给结构体成员赋值，正是因为有tag，在赋值前可以使用tag来决定赋值的动作。<br>比如，官方的<code>encoding/json</code>包，可以将一个JSON数据<code>Unmarshal</code>进一个结构体，此过程中就使用了Tag。该包定义一些规则，只要参考该规则设置tag就可以将不同的JSON数据转换成结构体。</p>
<p>总之：正是基于struct的tag特性，才有了诸如json、orm等等的应用。理解这个关系是至关重要的。或许，你可以定义另一种tag规则，来处理你特有的数据。</p>
<h2 id="Tag常见用法"><a href="#Tag常见用法" class="headerlink" title="Tag常见用法"></a>Tag常见用法</h2><p>常见的tag用法，主要是JSON数据解析、ORM映射等。 </p>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="string标准概念"><a href="#string标准概念" class="headerlink" title="string标准概念"></a>string标准概念</h2><p>Go标准库<code>builtin</code>给出了所有内置类型的定义。<br>源代码位于<code>src/builtin/builtin.go</code>，其中关于string的描述如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; string is the set of all strings of 8-bit bytes, conventionally but not</span><br><span class="line">&#x2F;&#x2F; necessarily representing UTF-8-encoded text. A string may be empty, but</span><br><span class="line">&#x2F;&#x2F; not nil. Values of string type are immutable.</span><br><span class="line">type string string</span><br></pre></td></tr></table></figure>

<p>所以string是8比特字节的集合，通常是但并不一定非得是UTF-8编码的文本。</p>
<p>另外，还提到了两点，非常重要：</p>
<ul>
<li>string可以为空（长度为0），但不会是nil；</li>
<li>string对象不可以修改。</li>
</ul>
<h2 id="string-数据结构"><a href="#string-数据结构" class="headerlink" title="string 数据结构"></a>string 数据结构</h2><p>源码包<code>src/runtime/string.go:stringStruct</code>定义了string的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type stringStruct struct &#123;</span><br><span class="line">    str unsafe.Pointer</span><br><span class="line">    len int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其数据结构很简单：</p>
<ul>
<li>stringStruct.str：字符串的首地址；</li>
<li>stringStruct.len：字符串的长度；</li>
</ul>
<p>string数据结构跟切片有些类似，只不过切片还有一个表示容量的成员，事实上string和切片，准确的说是byte切片经常发生转换。这个后面再详细介绍。</p>
<h2 id="string操作"><a href="#string操作" class="headerlink" title="string操作"></a>string操作</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>如下代码所示，可以声明一个string变量变赋予初值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str string</span><br><span class="line">str &#x3D; &quot;Hello World&quot;</span><br></pre></td></tr></table></figure>

<p>字符串构建过程是先根据字符串构建stringStruct，再转换成string。转换的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func gostringnocopy(str *byte) string &#123; &#x2F;&#x2F; 根据字符串地址构建string</span><br><span class="line">    ss :&#x3D; stringStruct&#123;str: unsafe.Pointer(str), len: findnull(str)&#125; &#x2F;&#x2F; 先构造stringStruct</span><br><span class="line">    s :&#x3D; *(*string)(unsafe.Pointer(&amp;ss))                             &#x2F;&#x2F; 再将stringStruct转换成string</span><br><span class="line">    return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>string在runtime包中就是stringStruct，对外呈现叫做string。</p>
<h3 id="byte转string"><a href="#byte转string" class="headerlink" title="[]byte转string"></a>[]byte转string</h3><p>byte切片可以很方便的转换成string，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func GetStringBySlice(s []byte) string &#123;</span><br><span class="line">    return string(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是这种转换需要一次内存拷贝。</p>
<p>转换过程如下：</p>
<ol>
<li>根据切片的长度申请内存空间，假设内存地址为p，切片长度为len(b)；</li>
<li>构建string（string.str = p；string.len = len；）</li>
<li>拷贝数据(切片中数据拷贝到新申请的内存空间)</li>
</ol>
<p>转换示意图：</p>
<p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_0317d71784cf0c9b1a00cee014429c40_r.png" alt="null"></p>
<h3 id="string转-byte"><a href="#string转-byte" class="headerlink" title="string转[]byte"></a>string转[]byte</h3><p>string也可以方便的转成byte切片，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func GetSliceByString(str string) []byte &#123;</span><br><span class="line">    return []byte(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>string转换成byte切片，也需要一次内存拷贝，其过程如下：</p>
<ul>
<li>申请切片内存空间</li>
<li>将string拷贝到切片</li>
</ul>
<p>转换示意图：</p>
<p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_5f500d01a01d45f69ea523a1789f9748_r.png" alt="null"></p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>字符串可以很方便的拼接，像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str :&#x3D; &quot;Str1&quot; + &quot;Str2&quot; + &quot;Str3&quot;</span><br></pre></td></tr></table></figure>

<p>即便有非常多的字符串需要拼接，性能上也有比较好的保证，因为新字符串的内存空间是一次分配完成的，所以性能消耗主要在拷贝数据上。</p>
<p>一个拼接语句的字符串编译时都会被存放到一个切片中，拼接过程需要遍历两次切片，第一次遍历获取总的字符串长度，据此申请内存，第二次遍历会把字符串逐个拷贝过去。</p>
<p>字符串拼接伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func concatstrings(a []string) string &#123; &#x2F;&#x2F; 字符串拼接</span><br><span class="line">    length :&#x3D; 0        &#x2F;&#x2F; 拼接后总的字符串长度</span><br><span class="line"></span><br><span class="line">    for _, str :&#x3D; range a &#123;</span><br><span class="line">        length +&#x3D; len(str)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s, b :&#x3D; rawstring(length) &#x2F;&#x2F; 生成指定大小的字符串，返回一个string和切片，二者共享内存空间</span><br><span class="line"></span><br><span class="line">    for _, str :&#x3D; range a &#123;</span><br><span class="line">        copy(b, str)    &#x2F;&#x2F; string无法修改，只能通过切片修改</span><br><span class="line">        b &#x3D; b[len(str):]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为string是无法直接修改的，所以这里使用rawstring()方法初始化一个指定大小的string，同时返回一个切片，二者共享同一块内存空间，后面向切片中拷贝数据，也就间接修改了string。</p>
<p>rawstring()源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func rawstring(size int) (s string, b []byte) &#123; &#x2F;&#x2F; 生成一个新的string，返回的string和切片共享相同的空间</span><br><span class="line">    p :&#x3D; mallocgc(uintptr(size), nil, false)</span><br><span class="line"></span><br><span class="line">    stringStructOf(&amp;s).str &#x3D; p</span><br><span class="line">    stringStructOf(&amp;s).len &#x3D; size</span><br><span class="line"></span><br><span class="line">    *(*slice)(unsafe.Pointer(&amp;b)) &#x3D; slice&#123;p, size, size&#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么字符串不允许修改？"><a href="#为什么字符串不允许修改？" class="headerlink" title="为什么字符串不允许修改？"></a>为什么字符串不允许修改？</h2><p>像C++语言中的string，其本身拥有内存空间，修改string是支持的。但Go的实现中，string不包含内存空间，只有一个内存的指针，这样做的好处是string变得非常轻量，可以很方便的进行传递而不用担心内存拷贝。</p>
<p>因为string通常指向字符串字面量，而字符串字面量存储位置是只读段，而不是堆或栈上，所以才有了string不可修改的约定。</p>
<h2 id="byte转换成string一定会拷贝内存吗？"><a href="#byte转换成string一定会拷贝内存吗？" class="headerlink" title="[]byte转换成string一定会拷贝内存吗？"></a>[]byte转换成string一定会拷贝内存吗？</h2><p>byte切片转换成string的场景很多，为了性能上的考虑，有时候只是临时需要字符串的场景下，byte切片转换成string时并不会拷贝内存，而是直接返回一个string，这个string的指针(string.str)指向切片的内存。</p>
<p>比如，编译器会识别如下临时场景：</p>
<ul>
<li>使用m[string(b)]来查找map（map是string为key，临时把切片b转成string）；</li>
<li>字符串拼接，如”&lt;” + “string(b)” + “&gt;”；</li>
<li>字符串比较：string(b) == “foo”</li>
</ul>
<p>因为是临时把byte切片转换成string，也就避免了因byte切片同容改成而导致string引用失败的情况，所以此时可以不必拷贝内存新建一个string。</p>
<h2 id="string和-byte如何取舍"><a href="#string和-byte如何取舍" class="headerlink" title="string和[]byte如何取舍"></a>string和[]byte如何取舍</h2><p>string和[]byte都可以表示字符串，但因数据结构不同，其衍生出来的方法也不同，要根据实际应用场景来选择。</p>
<p>string 擅长的场景：</p>
<ul>
<li>需要字符串比较的场景；</li>
<li>不需要nil字符串的场景；</li>
</ul>
<p>[]byte擅长的场景：</p>
<ul>
<li>修改字符串的场景，尤其是修改粒度为1个字节；</li>
<li>函数返回值，需要用nil表示含义的场景；</li>
<li>需要切片操作的场景；</li>
</ul>
<p>虽然看起来string适用的场景不如[]byte多，但因为string直观，在实际应用中还是大量存在，在偏底层的实现中[]byte使用更多。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/10/02/golang%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6/" rel="next" title="golang的协程调度">
                <i class="fa fa-chevron-left"></i> golang的协程调度
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/10/26/Mysql%E5%92%8CMongoDB%E5%AF%B9%E6%AF%94%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" rel="prev" title="Mysql和MongoDB对比和使用场景">
                Mysql和MongoDB对比和使用场景 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Cong</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
		  <!--音乐播放器-->
		  <div>
			<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=495562302&auto=1&height=66"></iframe>
		  </div>
          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#chan"><span class="nav-number">1.</span> <span class="nav-text">chan</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#chan数据结构"><span class="nav-number">1.1.</span> <span class="nav-text">chan数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#环形队列"><span class="nav-number">1.1.1.</span> <span class="nav-text">环形队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待队列"><span class="nav-number">1.1.2.</span> <span class="nav-text">等待队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型信息"><span class="nav-number">1.1.3.</span> <span class="nav-text">类型信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁"><span class="nav-number">1.1.4.</span> <span class="nav-text">锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#channel的读写"><span class="nav-number">1.2.</span> <span class="nav-text">channel的读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#channel创建"><span class="nav-number">1.2.1.</span> <span class="nav-text">channel创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#channel写入数据"><span class="nav-number">1.2.2.</span> <span class="nav-text">channel写入数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从channel读数据"><span class="nav-number">1.2.3.</span> <span class="nav-text">从channel读数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭channel"><span class="nav-number">1.2.4.</span> <span class="nav-text">关闭channel</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#slice"><span class="nav-number">2.</span> <span class="nav-text">slice</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">2.0.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用make创建Slice"><span class="nav-number">2.0.2.</span> <span class="nav-text">使用make创建Slice</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用数组创建Slice"><span class="nav-number">2.0.3.</span> <span class="nav-text">使用数组创建Slice</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slice扩容"><span class="nav-number">2.0.4.</span> <span class="nav-text">slice扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slice-copy"><span class="nav-number">2.0.5.</span> <span class="nav-text">slice copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊切片"><span class="nav-number">2.0.6.</span> <span class="nav-text">特殊切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结："><span class="nav-number">2.0.7.</span> <span class="nav-text">总结：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#map"><span class="nav-number">3.</span> <span class="nav-text">map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#map数据结构"><span class="nav-number">3.1.</span> <span class="nav-text">map数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bucket底层结构"><span class="nav-number">3.2.</span> <span class="nav-text">bucket底层结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希冲突"><span class="nav-number">3.3.</span> <span class="nav-text">哈希冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#负载因子"><span class="nav-number">3.4.</span> <span class="nav-text">负载因子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#渐进式扩容"><span class="nav-number">3.5.</span> <span class="nav-text">渐进式扩容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#扩容前提"><span class="nav-number">3.5.1.</span> <span class="nav-text">扩容前提</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增量扩容"><span class="nav-number">3.5.2.</span> <span class="nav-text">增量扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等量扩容"><span class="nav-number">3.5.3.</span> <span class="nav-text">等量扩容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找过程"><span class="nav-number">3.6.</span> <span class="nav-text">查找过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入过程"><span class="nav-number">3.7.</span> <span class="nav-text">插入过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#struct"><span class="nav-number">4.</span> <span class="nav-text">struct</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Tag的本质"><span class="nav-number">4.1.</span> <span class="nav-text">Tag的本质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tag规则"><span class="nav-number">4.1.1.</span> <span class="nav-text">Tag规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tag是Struct的一部分"><span class="nav-number">4.1.2.</span> <span class="nav-text">Tag是Struct的一部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取tag"><span class="nav-number">4.1.3.</span> <span class="nav-text">获取tag</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tag存在的意义"><span class="nav-number">4.2.</span> <span class="nav-text">Tag存在的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tag常见用法"><span class="nav-number">4.3.</span> <span class="nav-text">Tag常见用法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#string"><span class="nav-number">5.</span> <span class="nav-text">string</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#string标准概念"><span class="nav-number">5.1.</span> <span class="nav-text">string标准概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string-数据结构"><span class="nav-number">5.2.</span> <span class="nav-text">string 数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string操作"><span class="nav-number">5.3.</span> <span class="nav-text">string操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#声明"><span class="nav-number">5.3.1.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#byte转string"><span class="nav-number">5.3.2.</span> <span class="nav-text">[]byte转string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string转-byte"><span class="nav-number">5.3.3.</span> <span class="nav-text">string转[]byte</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串拼接"><span class="nav-number">5.3.4.</span> <span class="nav-text">字符串拼接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么字符串不允许修改？"><span class="nav-number">5.4.</span> <span class="nav-text">为什么字符串不允许修改？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#byte转换成string一定会拷贝内存吗？"><span class="nav-number">5.5.</span> <span class="nav-text">[]byte转换成string一定会拷贝内存吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string和-byte如何取舍"><span class="nav-number">5.6.</span> <span class="nav-text">string和[]byte如何取舍</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cong</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  
	<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
  <script type="text/javascript" src="/js/src/love.js"></script>
