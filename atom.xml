<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>聪菌粑粑</title>
  
  <subtitle>希望你觉得认识我是件幸运的事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-02-21T15:03:25.860Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Cong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ovs</title>
    <link href="http://yoursite.com/2023/02/21/ovs/"/>
    <id>http://yoursite.com/2023/02/21/ovs/</id>
    <published>2023-02-21T14:28:14.000Z</published>
    <updated>2023-02-21T15:03:25.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Open-vSwitch"><a href="#Open-vSwitch" class="headerlink" title="Open vSwitch"></a>Open vSwitch</h1><p>Open vSwitch 是一种产品质量的多层虚拟交换机，使用开源 Apache 2.0许可证授权。它旨在通过编程扩展实现大规模网络自动化，同时仍然支持标准的管理接口和协议(例如 NetFlow、 sFlow、 IPFIX、 RSPAN、 CLI、 LACP、802.1 ag)。</p><ul><li><p>通过 NetFlow、sFlow(R)、IPFIX、SPAN、RSPAN 和 GRE 隧道镜像查看 VM 间通信</p></li><li><p>LACP (IEEE 802.1AX-2008)</p></li><li><p>具有中继的标准 802.1Q VLAN 模型</p></li><li><p>组播侦听</p></li><li><p>IETF 自动附加 SPBM 和基本所需的 LLDP 支持</p></li><li><p>BFD 和 802.1ag 链路监控</p></li><li><p>STP (IEEE 802.1D-1998) 和 RSTP (IEEE 802.1D-2004)</p></li><li><p>细粒度的 QoS 控制</p></li><li><p>支持 HFSC qdisc</p></li><li><p>每个虚拟机接口流量监管</p></li><li><p>具有源 MAC 负载平衡、主动备份和 L4 散列的 NIC 绑定</p></li><li><p>OpenFlow 协议支持（包括许多虚拟化扩展）</p><ul><li>IPv6 支持</li></ul></li><li><p>多种隧道协议（GRE、VXLAN、STT 和 Geneve，支持 IPsec）</p></li><li><p>具有 C 和 Python 绑定的远程配置协议</p></li><li><p>内核和用户空间转发引擎选项</p></li><li><p>带有流缓存引擎的多表转发管道</p></li><li><p>转发层抽象，便于移植到新的软件和硬件平台</p></li></ul><p>介绍来自Open vSwitch <a href="https://www.openvswitch.org/" target="_blank" rel="noopener">官方文档</a>，可能会有更新，最新文档可以通过官网查看。</p><h2 id="ovs-architecture"><a href="#ovs-architecture" class="headerlink" title="ovs architecture"></a>ovs architecture</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ec0257dfcb7450bbf2b44804e13026d~tplv-k3u1fbpfcp-watermark.image?" alt="ovs-architecture.jpg"></p><p>ovs的架构如上图所示，主要由内核<code>datapath</code>和用户空间的<code>vswitchd</code>、<code>ovsdb</code>组成</p><ul><li><p><code>datapath</code>：是负责数据交换的内核模块，从网卡读取数据，并快速匹配flowtable中的流表项，成功的直接转发，失败的上交vswtichd处理。它在初始化和 <code>port binding</code>的时候注册hook函数，把端口保温处理接管到内核模块，。。。。。 属于快速转发平面，主要负责流表匹配、保温修改、隧道封装、转发或者上送。并且维护底层转发表。在原始ovs中，报文首先经过该组件完成报文解析和封装、转发规则匹配，若找到转发规则不再经过用户空间，直接转发。否则转交用户空间的ovs-vswitchd组件进行处理。ovs-vswitchd组件与openvswitch.ko组件之间采用netlink执行进程间的通信。netlink是一种进程间通信机制，可用于处理用户态和内核态的通信。</p></li><li><p><code>vswitchd</code>：一个守护进程，是ovs的管理和控制服务，通过unix socket将配置保存至ovsdb，并通过netlink和内核模块交互，主要负责基本的转发逻辑、地址学习、外部物理端口绑定、还可以运行ovs-ofctl工具，采用openflow协议对交换机进行远程配置和管理</p></li><li><p><code>ovsdb</code>：ovs的数据库，保存了ovs的配置信息</p></li></ul><p>Open vSwitch 内部分为用户态和内核态，用户态为守护程序实现了交换机和流表，是Open vSwitch的核心，提供了一些组件去管理交换机，实现数据库，对内核进行管理</p><p>数据流通过ovs的转发流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 数据包进入ovs</span><br><span class="line">2 匹配流表</span><br><span class="line">3 流表无匹配，向vswitchd中匹配转发规则</span><br><span class="line">4 规则无匹配，向上传递个openflow 控制器判断是否转发，</span><br><span class="line">5 无转发决策或者判断为否，将数据包drop</span><br><span class="line">6 判断为可以转发的话，将数据包正常转发，并缓存流表</span><br></pre></td></tr></table></figure><h2 id="流表"><a href="#流表" class="headerlink" title="流表"></a>流表</h2><p>每条流表规则由一些列字段组成，可以分为<strong><code>基础字段</code></strong> 、<strong><code>匹配字段</code>和<code>动作字段</code></strong>三部分。 在打印流表时，在流表中还存在一些显示字段，如<code>duration</code>,<code>idle_age</code>等，此处把这些字段也暂时归之于基础字段之中.</p><h3 id="基础字段"><a href="#基础字段" class="headerlink" title="基础字段"></a>基础字段</h3><ul><li><code>cookie=value</code> 流表标识字段，cookie字段有两种书写方式：<code>cookie=value</code>和<code>cookie=value/mask</code>。<code>mask</code>中对应位为1时cookie中值相应的位须严格匹配，为0时cookie中值对应的位通配，当<code>mask</code>为-1时，必须严格匹配cookie值。</li><li><code>duration=value</code> 流表生效时间，标识流表从下发到现在所持续的时间</li><li><code>table=tableid</code> 流表所属表项，标识流表所属的表，默认为0</li><li><code>priority=priority</code> 标识流表的优先级，范围为0-65535，值越大，优先级越高</li><li><code>n_packets</code> 标识流表匹配包数</li><li><code>n_bytes</code> 标识流表匹配字节数</li><li><code>idle_timeout=sec</code> 流表空闲超时时间，流表会在空闲时间达到给定的时间时被删除。设置为0（默认值）时，流表不会因空闲时间被删除。</li><li><code>hard_timeout=sec</code> 流表可存在的时间。设置此值后，流表会在到达给定时间后被删除。</li><li><code>idle_age=sec</code> 流表空闲时间</li><li><code>hard_age=sec</code> 流表存在时间。此字段与<code>duration</code>字段的区别在当流表被修改后，会重新设置<code>hard_timer</code>但是不会重置<code>duration</code></li><li><code>ip_frag=frag_type</code> 当<code>dl_type</code>指定为IP或者IPv6，<code>frag_type</code>指定匹配的IP分片包或者非分片包的匹配 <code>frag_type</code>支持的值为： <code>no</code>: 仅匹配非分片报文 <code>yes</code>：匹配所有分片报文 <code>first</code>：仅匹配<code>offset</code>为0的分片报文 <code>later</code>： 仅匹配<code>offset</code>非0的分片报文 <code>not_later</code>：匹配非分片报文和offset为0的分片报文</li></ul><h3 id="匹配字段"><a href="#匹配字段" class="headerlink" title="匹配字段"></a>匹配字段</h3><ul><li><code>in_port=port</code> 标识匹配接收数据包的端口号</li><li><code>dl_type=ethertype</code> 匹配数据包的二层协议类型，IP数据包为<code>0x0800</code>，IPv6数据包为<code>0x86dd</code>，ARP数据包为<code>0x0806</code></li><li><code>dl_src=xx:xx:xx:xx:xx:xx</code></li><li><code>dl_dst=xx:xx:xx:xx:xx:xx</code> 匹配指定的链路层源或者目的MAC地址</li><li><code>dl_src=xx:xx:xx:xx:xx:xx/xx:xx:xx:xx:xx:xx</code></li><li><code>dl_dst=xx:xx:xx:xx:xx:xx/xx:xx:xx:xx:xx:xx</code> 匹配指定的链路层MAC地址，MAC地址格式为<code>ADDR/MASK</code>，当<code>MASK</code>值为<code>01:00:00:00:00:00</code>时，仅匹配多播位。当<code>dl_dst=01:00:00:00:00:00/01:00:00:00:00:00</code>时，匹配所有的组播报文和广播报文。<code>dl_dst=00:00:00:00:00:00/01:00:00:00:00:00</code>匹配所有的单播报文。</li><li><code>nw_src=ip[/mask]</code></li><li><code>nw_dst=ip[/mask]</code> 当<code>dl_type=0x0800</code>或指定<code>ip</code>时，匹配数据包的源、目的IP地址 当<code>dl_type=0x0806</code>或指定<code>arp</code>时，匹配ARP数据包的<code>ar_spa</code>或者<code>ar_tpa</code>字段</li><li><code>dl_vlan=vlan</code> 匹配802.1Q类型（即vlan）数据包</li><li><code>nw_proto=proto</code> 匹配数据包协议类型。当<code>dl_type=0x0800</code>时，匹配IP协议族的协议，例如<code>tcp</code>，<code>udp</code>，<code>icmp</code>等</li><li><code>nw_tos=tos</code> 匹配<code>IP Tos/DSCP</code>或者IPv6的<code>tos</code>字段，值为<code>0-255</code></li><li><code>nw_ecn=ecn</code> 匹配IP或者IPv6的<code>ecn</code>字段，值为<code>0~3</code></li><li><code>nw_ttl=ttl</code> 匹配TTL值</li><li><code>tp_src=port</code></li><li><code>tp_dst=port</code> 若指定了<code>udp</code>或者<code>tcp</code>协议，则匹配udp/tcp的端口号</li><li><code>icmp_type=type</code></li><li><code>icmp_code=code</code> 若指定了<code>icmp</code>或者<code>icmpv6</code>协议，则匹配对应的icmp 类型或者code字段</li><li><code>arp_sha=xx:xx:xx:xx:xx:xx</code></li><li><code>arp_tha=xx:xx:xx:xx:xx:xx</code> 当设置<code>dl_type</code>为<code>ARP</code>或者<code>RARP</code>，则<code>arp_sha</code>和<code>arp_tha</code>匹配数据包的源、目的MAC地址</li></ul><h3 id="动作字段"><a href="#动作字段" class="headerlink" title="动作字段"></a>动作字段</h3><ul><li><code>output:port</code> 将数据包从<code>port</code>接口发送</li><li><code>enqueue:port:queue</code> 将数据包入队到指定端口的指定队列里</li><li><code>normal</code> 将数据包按照设备上的正常L2/L3层处理方式进行处理</li><li><code>flood</code> 将数据包发送到交换机上除接收接口和禁止flood的接口外的所有接口</li><li><code>all</code> 将数据包发送到除接收接口外的所有接口</li><li><code>controller(key=value…)</code> 将数据包作为<code>PACKET IN</code>消息发送到OpenFlow控制器。 支持的键值对： <code>max_len=nbytes</code>：限制发送到控制器的数据包长度字节数，默认情况是发送整个数据包；<code>reason=reason</code>：在<code>PACKET IN</code>消息中指明发送消息的原因，支持的<code>reason</code>为<code>action</code>(default)，<code>no_match</code>和<code>invalid_ttl</code>; <code>id=controller-id</code>：指明控制器ID</li><li><code>in_port</code> 将数据包从接收的接口发送出去</li><li><code>drop</code> 丢弃数据包</li><li><code>mod_vlan_vid:vlan_vid</code> 修改数据包的vlan id</li><li><code>mod_vlan_pcp:vlan_pcp</code> 修改数据包的vlan priority</li><li><code>strip_vlan</code> 如果数据包中存在vlan tag，则剥离vlan tag</li><li><code>push_vlan:ethertype</code> 为数据包添加新的vlan tag</li><li><code>mod_dl_src:mac</code> 设置数据包的源MAC地址</li><li><code>mod_dl_dst:mac</code> 设置数据包的目的MAC地址</li><li><code>mod_nw_src:ip</code> 设置数据包的源IP地址</li><li><code>mod_nw_dsp:ip</code> 设置数据包的目的IP地址</li><li><code>mod_tp_src:port</code> 设置TCP或者UDP的源端口</li><li><code>mod_tp_dst:port</code> 设置TCP或UDP的目的端口</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Open-vSwitch&quot;&gt;&lt;a href=&quot;#Open-vSwitch&quot; class=&quot;headerlink&quot; title=&quot;Open vSwitch&quot;&gt;&lt;/a&gt;Open vSwitch&lt;/h1&gt;&lt;p&gt;Open vSwitch 是一种产品质量的多层虚拟交换机，使
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iptables</title>
    <link href="http://yoursite.com/2023/02/21/iptables/"/>
    <id>http://yoursite.com/2023/02/21/iptables/</id>
    <published>2023-02-21T13:44:52.000Z</published>
    <updated>2023-02-21T14:06:44.614Z</updated>
    
    <content type="html"><![CDATA[<p>在云原生领域iptables 是绕不开的一个功能，许多我们常见的组件都是基于iptables 实现的功能，比如kube-proxy 又比如calico cni 等等，所以在网络排错或者网络调优都需要了解iptables的规则</p><h2 id="一、四表五链"><a href="#一、四表五链" class="headerlink" title="一、四表五链"></a>一、四表五链</h2><p><strong>四表</strong> iptables的功能——filter, nat, mangle, raw.</p><p><strong>filter</strong>：控制数据包是否允许进出及转发（INPUT、OUTPUT、FORWARD）,（这个规则表是预设规则表，这个规则表顾名思义是用来进行封包过滤的理动作）</p><p><strong>nat</strong>：控制数据包中地址转换，可控制的链路有prerouting, input, output, postrouting（ 主要功能为进行一对一、一对多、多对多等网址转译工作（SNATDNAT））</p><p><strong>mangle</strong>：修改数据包中的原数据，可控制的链prerouting, input, forward, output, postrouting（除了进行网址转译工作会改写封包外，在某些特殊应用可能也必须去改写封包(ITL、TOS)或者是设定MARK(将封包作记号，以进行后续的过滤)这时就必须将这些工作定义在mangles规则表中）</p><p><strong>raw</strong>：控制nat表中连接追踪机制的启用状况，可以控制的链路有prerouting, output（RAW表只使用在PREROUTING链和OUTPUT链上,因为优先级最高，从而可以对收到的数据包在连接跟踪前进行处理。一但用户使用了RAW表,在某个链上,RAW表处理完后,将跳过NAT表和ip_conntrack处理,即不再做地址转换和数据包的链接跟踪处理了.）</p><p>4个表的优先级由高到低：raw–&gt;mangle–&gt;nat–&gt;filter，</p><p><strong>五链</strong>:内核中控制网络的NetFilter定义的五个规则链</p><p>PREROUTING, 路由前</p><p>INPUT, 数据包流入口</p><p>FORWARD, 转发管卡</p><p>OUTPUT, 数据包出口</p><p>POSTROUTING, 路由后</p><h2 id="二、堵通策略"><a href="#二、堵通策略" class="headerlink" title="二、堵通策略"></a>二、堵通策略</h2><p>accept、drop、reject（drop收到数据直接不回、reject回复拒绝）</p><h2 id="三、iptables命令"><a href="#三、iptables命令" class="headerlink" title="三、iptables命令"></a>三、iptables命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t table] COMMAND [chain] CRETIRIA -j ACTION</span><br></pre></td></tr></table></figure><p>　　-t table，是指操作的表，filter、nat、mangle或raw, 默认使用filter</p><p>　　COMMAND，子命令，定义对规则的管理</p><p>　　chain, 指明链路</p><p>　　CRETIRIA, 匹配的条件或标准</p><p>　　ACTION,操作动作</p><p>例如，不允许10.8.0.0/16网络对80/tcp端口进行访问，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -s 10.8.0.0&#x2F;16 -d 172.16.55.7 -p tcp --dport 80 -j DROP</span><br></pre></td></tr></table></figure><h3 id="3-1命令"><a href="#3-1命令" class="headerlink" title="3.1命令"></a>3.1命令</h3><p>操作命令：-A, -I, -D, -R, -P -F</p><p>查看：-xnvL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L:list列出规则</span><br><span class="line">-S:显示指定链的所有规则</span><br><span class="line">v:显示详细信息</span><br><span class="line">x:在v的基础上禁止单位换算</span><br><span class="line">n:只显示ip地址和端口号，不显示域名和服务名称</span><br><span class="line">iptables -t nat -vxnL PREROUTING</span><br><span class="line">详细列出nat表PREROUTING链的所有规则</span><br></pre></td></tr></table></figure><p><strong>-A</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-A&lt;链名&gt;   追加一条规则放在最后</span><br><span class="line">append</span><br><span class="line">iptables -t filter -A INPUT -j DROP</span><br><span class="line">在表fil的input链追加规则作为最后一条匹配所有访问本机的数据包，并丢弃</span><br></pre></td></tr></table></figure><p><strong>-I</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-I&lt;链名&gt;[x]</span><br><span class="line">insert</span><br><span class="line">插入一条规则为第x条</span><br></pre></td></tr></table></figure><p><strong>-D</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-D&lt;链名&gt;[规则号码|具体规则内容]</span><br><span class="line">delete删除一条规则</span><br><span class="line">(1，若有多条相同规则，按内容匹配只删除最小的一条</span><br><span class="line">2，确保规则或号码存在，否则报错)</span><br></pre></td></tr></table></figure><p><strong>-R</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-R&lt;链名&gt;[规则号码]&lt;具体规则内容&gt;</span><br><span class="line">replace替换一条规则</span><br></pre></td></tr></table></figure><p><strong>-P</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-P&lt;链名&gt;[动作]</span><br><span class="line">policy 设置某个链的默认规则</span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">设置filter表的INPUT链的默认规则是DROP</span><br><span class="line">（当数据包没被任何规则匹配到，按默认规则，动作前面不能加 -j</span><br></pre></td></tr></table></figure><p><strong>-F</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-F[链名]</span><br><span class="line">flush 清空所有规则</span><br><span class="line">(1-F仅仅清楚链中的规则，并不影响-P设置的默认规则</span><br><span class="line">2-P设置DROP后使用-F要小心</span><br><span class="line">3如果不写链名，则默认清空表中所有链)</span><br></pre></td></tr></table></figure><p>　　-N, –new-chain chain：新建一个自定义的规则链；</p><p>　　-X, –delete-chain [chain]：删除用户自定义的引用计数为0的空链；</p><p>　　-F, –flush [chain]：清空指定的规则链上的规则；</p><p>　　-E, –rename-chain old-chain new-chain：重命名链；</p><p>　　-Z, –zero [chain [rulenum]]：置零计数器；　　</p><p>　　-P, –policy chain target， 设置链路的默认策略</p><h3 id="3-2匹配条件"><a href="#3-2匹配条件" class="headerlink" title="3.2匹配条件"></a>3.2匹配条件</h3><p>流入流出 -i -o 、来源目的地址 -s -d 、协议类型 -p 、来源目的端口 –sport 、–dport</p><h3 id="3-3动作"><a href="#3-3动作" class="headerlink" title="3.3动作"></a>3.3动作</h3><p>ACCEPT、DROP、SNAT、DNAT、MASQUERADE（动作一般写法 -j ACCEPT）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RETURN返回 在自定义链执行完毕后使用返回，来返回原规则链。</span><br><span class="line">MARK：打防火墙标记的</span><br><span class="line">MASQUERADE：源地址伪装</span><br><span class="line">REDIRECT：重定向：主要用于实现端口重定向</span><br><span class="line"></span><br><span class="line">DNAT</span><br><span class="line">-to-destination [ipaddr[-ipaddr]][:port[-port]] 轮询访问</span><br><span class="line">--random 随机访问</span><br><span class="line">--persistent 固定访问</span><br></pre></td></tr></table></figure><h3 id="3-4附加模块-m"><a href="#3-4附加模块-m" class="headerlink" title="3.4附加模块(-m)"></a>3.4附加模块(-m)</h3><p>按包状态匹配：state、按来源mac匹配：mac、按包速率匹配：limit、多端口匹配：multiport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-m state --state</span><br><span class="line">状态有NEW、RELABTED、ESTABLISHD、INVALID</span><br><span class="line">    ？、连接态、衍生态、不能被识别属于哪个连接或没有任何状态</span><br><span class="line">iptables -A INPUT -m state --state RELABTED,ESTABLISHD\ -j ACCEPT</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-m mac --mac-source MAC</span><br><span class="line">匹配某个mac地址</span><br><span class="line">iptables -A FORWARD -m mac --mac-source xx:xxx:xx:xx:xx:xx -j DROP</span><br><span class="line">(报文经过路由后，数据包中的原有的mac地址会被替换，所以再路由后的iptables中使用mac模块没意义)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-m limit --limit [匹配速率]</span><br><span class="line">用一定的速率去匹配数据包</span><br><span class="line">iptables -A FORWARD -d 192.168.0.1 -m limit --limit 50&#x2F;s \ -j ACCCEPT</span><br><span class="line">iptables -A FORWARD -d 192.168.0.1  -j DROP</span><br><span class="line">(limit只是匹配，想要限制的话，后面要再单独加命令)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-m multiport &lt;--sports|--dports|--ports&gt;[端口1，端口2，。。。端口n]</span><br><span class="line">一次性匹配多个端口</span><br><span class="line">iptables -A INPUT -p tcp -m multiport --dports\21,22,23,24 -j ACCEPT</span><br><span class="line">必须和-p一起使用</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-m connlimit</span><br><span class="line">　　--connlimit-upto n</span><br><span class="line"></span><br><span class="line">　　--connlimit-above n</span><br><span class="line">用于限制同一IP可建立的连接数目</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-m string </span><br><span class="line">匹配数据包中的字符</span><br><span class="line">　　--algo &#123;bm|kmp&#125;</span><br><span class="line">　　[!] --string pattern</span><br><span class="line">　　[!] --hex-string pattern</span><br><span class="line">　　--from offset</span><br><span class="line">　　--to offset</span><br><span class="line">　　iptables -I OUTPUT -m string --algo bm --string &quot;gay&quot; -j REJECT</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-m time</span><br><span class="line">匹配数据包到达的时间</span><br><span class="line"></span><br><span class="line">　　--timestart hh:mm[:ss]</span><br><span class="line"></span><br><span class="line">　　--timestop hh:mm[:ss]</span><br><span class="line"></span><br><span class="line">　　[!] --weekdays day[,day...]</span><br><span class="line"></span><br><span class="line">　　[!] --monthdays day[,day...]</span><br><span class="line"></span><br><span class="line">　　--datestart YYYY[-MM[-DD[Thh[:mm[:ss]]]]]</span><br><span class="line"></span><br><span class="line">　　--datestop YYYY[-MM[-DD[Thh[:mm[:ss]]]]]</span><br><span class="line"></span><br><span class="line">　　--kerneltz：使用内核配置的时区而非默认的UTC；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-m iprange</span><br><span class="line">以连续地址块的方式来指明多IP地址匹配条件；</span><br><span class="line"></span><br><span class="line">　　[!] --src-range from[-to]</span><br><span class="line"></span><br><span class="line">　　[!] --dst-range from[-to]</span><br><span class="line">　　iptables -I INPUT -d 172.16.0.7 -p tcp -m multiport --dports 22,80,139,445,3306 -m iprange --src-range 172.16.0.61-172.16.0.70 -j REJECT</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-m comment --comment &quot;note&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在云原生领域iptables 是绕不开的一个功能，许多我们常见的组件都是基于iptables 实现的功能，比如kube-proxy 又比如calico cni 等等，所以在网络排错或者网络调优都需要了解iptables的规则&lt;/p&gt;
&lt;h2 id=&quot;一、四表五链&quot;&gt;&lt;a h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>拉起pod的流程</title>
    <link href="http://yoursite.com/2023/02/20/%E6%8B%89%E8%B5%B7pod%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2023/02/20/%E6%8B%89%E8%B5%B7pod%E7%9A%84%E6%B5%81%E7%A8%8B/</id>
    <published>2023-02-20T13:25:08.000Z</published>
    <updated>2023-02-20T13:25:53.739Z</updated>
    
    <content type="html"><![CDATA[<p>  因为最近在工作中遇到一个问题，业务pod 没创建失败，但是检测cni 的日志发现新创建的pod 已经被分配了IP地址，但是通过docker ps 和 kubectl get pod 均没有发现对应的容器，遂重温了下pod 创建的流程，查到得大部分都比较简单，到kubelet之后就是一笔带过，没有明确给出拉起pod时的具体操作，所以简单过了一下kubelet 的代码，发现是拉起业务容器时出现的问题，因为问题比较有通用性，所以简单的记录下。</p><ol><li>用户通过kubectl或者k8s官方提供的client库，向api-server 发起请求</li><li>api-server接受请求，并将数据写入etcd</li><li>kube-scheduler通过watch检测到未绑定node 的pod，调度pod到某一node上，并通知给api-server，api-server将其写入etcd</li><li>kubelet通过watch 检测到有新的pod调度过来，通过container runtime 运行新pod</li><li>kubelet 通过cri 拉起pause 容器</li><li>kubelet 通过cni 为pause容器创建网络(虚拟网络设备，ip地址)</li><li>kubelet 拉起业务容器，业务容器和pause容器共享同一个网络空间</li></ol><p>由于网上的流程图实在太多了，这里就不贴图了(主要是我太懒了，不想画图)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  因为最近在工作中遇到一个问题，业务pod 没创建失败，但是检测cni 的日志发现新创建的pod 已经被分配了IP地址，但是通过docker ps 和 kubectl get pod 均没有发现对应的容器，遂重温了下pod 创建的流程，查到得大部分都比较简单，到kubel
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[论文整理]流表大小对网络性能的影响</title>
    <link href="http://yoursite.com/2023/02/16/%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86-%E6%B5%81%E8%A1%A8%E5%A4%A7%E5%B0%8F%E5%AF%B9%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>http://yoursite.com/2023/02/16/%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86-%E6%B5%81%E8%A1%A8%E5%A4%A7%E5%B0%8F%E5%AF%B9%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</id>
    <published>2023-02-16T13:03:58.000Z</published>
    <updated>2023-02-16T13:07:32.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-引言"><a href="#一-引言" class="headerlink" title="一 引言"></a><strong>一 引言</strong></h1><p>本文主要研究流表大小对网络性能的影响，数据均来自期刊论文，我没有按照论文复现实验，所以我无法保证数据的真实性。本文仅仅是论文数据的整理和汇总分析，可以作为工作中性能调优的参考，实际生产中可能有其它的生产场景的数据，欢迎和我联系共同丰富数据的完整性。</p><h1 id="二-相关研究"><a href="#二-相关研究" class="headerlink" title="二 相关研究"></a><strong>二 相关研究</strong></h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><p>测试环境：</p><p>我们⽤H3C S5820V2OpenFlow 交换机 Opendaylight作为控制器试匹配/添加/删除/修改条⽬的平均响应时间每个操作都在增加的随机选择条⽬中进⾏测试。详细数据如表一所示</p><table><thead><tr><th>Flow table size</th><th>match</th><th>add</th><th>delete</th><th>Modify</th></tr></thead><tbody><tr><td>100</td><td>1.71ms</td><td>11 ms</td><td>10 ms</td><td>6 ms</td></tr><tr><td>500</td><td>5.2ms</td><td>171 ms</td><td>87 ms</td><td>33 ms</td></tr><tr><td>1000</td><td>15.7ms</td><td>290 ms</td><td>112 ms</td><td>51 ms</td></tr><tr><td>2000</td><td>27.3ms</td><td>454 ms</td><td>207 ms</td><td>107 ms</td></tr><tr><td>3000</td><td>41.3ms</td><td>15589 ms</td><td>573 ms</td><td>133 ms</td></tr></tbody></table><p><strong>表一时间成本与流表规模大小的关系[1]</strong></p><h2 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h2><p>BA模型:无标度网络模型，</p><p>初始时，网络中有m0个节点，这些节点任意连接，只需保证每个节点至少有一个链接即可，并按照生长与偏好连接逐步演,每步向网络中添加一个拥有m(≤m0) 条链的新节点。 <strong>[2]</strong></p><p>Bcube模型：专为⽀持带宽密集型应⽤的模块化数据中⼼⽽设计。BCube 架构的核⼼是其以服务器为中⼼的⽹络结构，其中服务器不仅充当终端主机，还充当彼此的中继节点. <strong>[3]</strong></p><p>网状拓扑 :网状拓扑是一种网络设置，其中每台计算机和网络设备相互连接。即使其中一个连接出现故障，这种拓扑设置也允许分配大多数传输。<a href="https://www.computerhope.com/jargon/w/wifi.htm" target="_blank" rel="noopener">它是无线网络</a>常用的一种拓扑结构。下面是使用网状拓扑在网络上设置简单计算机的可视示例</p><p>测试背景：</p><p>对于所有拓扑，模拟了 200,000 种不同需求的流量。在⽤于我们实验的每个图形实例中，转发表⼤⼩统⼀设置在 500 到 10,000 之间。该值是根据流量需求数 (200,000) 设置的。</p><p>在所有拓扑中，链路容量是统⼀的（通常表⽰ 10 Gigabit 链路），⽽需求是使⽤均匀分布随机⽣成的，并根据我们的基础设施可以⽀持的最⼤流量进⾏标准化。具体来说，我们表⽰为F最⼤限度在节点上没有路径度限制的情况下，可以为所有需求路由的最⼤流量。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f9edfc149d9438c95b4c8f8d1eb38b0~tplv-k3u1fbpfcp-watermark.image?" alt="流表大小和总流量的关系.png"></p><p><strong>图1 流表大小和总流量的关系[4]</strong></p><hr><p>显然，节点的流表⼤⼩越⼩，可以达到的总流量就越低。对于 5000个条⽬的转发表⼤⼩，实现的流量在最佳（BA 拓扑）的 75% 以上，⽽对于 1000 个条⽬的⼤⼩，它减少到最佳（BCube 拓扑）的25% 以上。我们注意到，在计算最⼤流量时，转发表⼤⼩没有提供限制，转发表条⽬的实际使⽤量被测量为⾼达 30,000（最⾼值是针对 BA 拓扑测量的）。从图中可以看出，使⽤我们的技术，只需使⽤10,000 个条⽬（3 倍），同时将总流量减少 15%。</p><p>同时，转发表大小和性能比如图2所示</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b74222c6deae401ab4b3b8ca7b23c061~tplv-k3u1fbpfcp-watermark.image?" alt="路径度最大流量算法与贪婪算法的性能比.png"></p><p><strong>图2路径度最大流量算法与贪婪算法的性能比[4]</strong></p><h1 id="三-结论"><a href="#三-结论" class="headerlink" title="三 结论"></a><strong>三 结论</strong></h1><p>由研究一可以看出，网络的性能和流表的规模呈现出明显的负相关，即流表规模越大，openflow平均相应时间越长。而研究二表示，在网络拓扑中，流表规模和网络性能呈现正相关，即流表规模越大，网络拓扑中可以承受的网络流量越大，并且在流表规模到达1000-2000时性能下降较为明显，2000-3000以后虽然性能比不在下降，但是性能比的值相对较小。</p><p>综上流表的规模推荐流表条数小于2000.</p><h1 id="四-参考文献"><a href="#四-参考文献" class="headerlink" title="四 参考文献"></a><strong>四 参考文献</strong></h1><p>[1] Bing Leng,Liusheng Huang,Chunming Qiao,Hongli Xu,Xinglong Wang.FTRS: A mechanism for reducing flow table entries in software defined networks[J].Computer Networks,2017,122(122).</p><p>[2] R. Albert and A.L. Barabasi. Statistical mechanics of complex networks. Reviews of Modern Physics, Vol. 74, pp. 47-97, 2002.</p><p>[3] Guo, CX,Lu, GH,Li, D,Wu, HT,Zhang, X,Shi, YF,Tian, C,Zhang, YG,Lu, SW. BCube: A High Performance, Server-centric Network Architecture for Modular Data Centers[J]. Computer Communication Review: A Quarterly Publication of the Special Interest Group on Data Communication,2009,39(4).</p><p>[4] R. Cohen, L. Lewin-Eytan, J. S. Naor and D. Raz, “On the effect of forwarding table size on SDN network utilization,” IEEE INFOCOM 2014 - IEEE Conference on Computer Communications, 2014, pp. 1734-1742, doi: 10.1109/INFOCOM.2014.6848111.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-引言&quot;&gt;&lt;a href=&quot;#一-引言&quot; class=&quot;headerlink&quot; title=&quot;一 引言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一 引言&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;本文主要研究流表大小对网络性能的影响，数据均来自期刊论文，我没有按照论文复现实验，所以我无
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>kubernetes网络模型</title>
    <link href="http://yoursite.com/2023/02/15/kubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2023/02/15/kubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-02-15T14:03:46.000Z</published>
    <updated>2023-02-15T14:04:19.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes的网络模型"><a href="#Kubernetes的网络模型" class="headerlink" title="Kubernetes的网络模型"></a>Kubernetes的网络模型</h1><p>前言：kubernetes作为云原生领域绕不开的一个重要内容，在私有云和公有云领域都是构建集群的主要工具，所以本文主要分析一下kubernetes 集群中的整体网络模型。</p><p><strong>注：为了简化，kubernetes 后文写为k8s</strong></p><h2 id="k8s网络标准"><a href="#k8s网络标准" class="headerlink" title="k8s网络标准"></a>k8s网络标准</h2><p>K8s的网络接口是开放的，只要是符合其规范开发者可以自定义自己的CNI（container network interface）这也造就了云原生网络层面的百花齐放，不得不说k8s社区考虑的是真的厉害，下面是k8s的网络实现标准</p><ul><li>所有的pod 都可以在不使用nat的情况下和所有其它的pod通信</li><li>所有的节点都可以在不适应nat的情况下和所有的pod通信</li><li>pod认为自己的IP地址与其他人认为它的IP地址一致</li></ul><h3 id="k8s中的网络类型"><a href="#k8s中的网络类型" class="headerlink" title="k8s中的网络类型"></a>k8s中的网络类型</h3><ul><li>容器内部的网络通信</li><li>pod to pod</li><li>pod to service</li><li>外部网络到容器网络</li></ul><h2 id="1-容器内部通信"><a href="#1-容器内部通信" class="headerlink" title="1 容器内部通信"></a>1 容器内部通信</h2><p>在云原生领域容器有很多种，k8s也有自己的容器运行时标准（container runtime interface ）但是其实实现原理都大同小异(都是在linux 的网络空间做文章)，为了方便理解这里我们使用docker 容器作为讲解的例子</p><p>在k8s中pod 是最小的工作单位，但是一个pod中可以有很多容器，可能一个pod 中有多个容器相互配合才能正常完成工作，虽然k8s官方推荐的是一个pod对应一个容器，但是实际的生产中，多容器在同一个pod中也是有出现的。图1 为pod 内部之间容器之间的关系：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee468d49bcb34428b1aff194cbb97aad~tplv-k3u1fbpfcp-watermark.image?" alt="k8s网络模型1.svg"></p><pre><code>**图1pod内部各个容器之间的关系**</code></pre><p>在pod 中必须有一个由kubelet拉起的pause 其余所有的容器都共享pause的网络空间，可以理解为docker 容器的other container 模式，所以容器之间的通信相对简单，大家共享同一网络空间，相当于内部通信</p><h2 id="2-pod-to-pod"><a href="#2-pod-to-pod" class="headerlink" title="2 pod to pod"></a>2 pod to pod</h2><p>pod 作为k8s中最小的工作单位，每个pod都有一个真实的IP地址，而且每个pod 使用该IP地址与外部通信，但是pod 在同一宿主节点还是在不同的宿主节点上还是有很大的区别的，所以我们将pod 和pod 的通信分为，<code>pod to remote pod</code>(非同一宿主节点)<code>pod to local pod</code>(同一宿主节点)</p><h3 id="2-1-pod-to-local-pod"><a href="#2-1-pod-to-local-pod" class="headerlink" title="2.1 pod to local pod"></a>2.1 pod to local pod</h3><p>当pod 在同一宿主机时，同节点的网络通信损耗相对较小，网络模型也相对简单，具体网络流向如图2 所示</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c04ca64adc054509800579e783e9e264~tplv-k3u1fbpfcp-watermark.image?" alt="k8snet2.svg"></p><p><strong>图2 Pod 和同节点的pod通信</strong></p><p>这里以网络建立连接时的arp请求为例。</p><p>pod1的数据包发送到自己的以太网设备eth0(其实也是一个veth不理解的veth pair 的可以去看下上篇文章《linux网络虚拟化》)；随后数据包到达对端veth 所在的网桥之上；网桥上的所有设备接受到arp请求，pod2 收到arp包之后发送响应包，自此网络成功打通</p><h3 id="2-2-pod-to-remote-pod"><a href="#2-2-pod-to-remote-pod" class="headerlink" title="2.2 pod to remote pod"></a>2.2 pod to remote pod</h3><p>当pod在不同的宿主机时，pod 之间通信需要跨过一层主机网络，不同的cni 有不同的实现方式，这里我们只用两个常见的overlay和underlay实现方式来讲解</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66ae05108b3744849446aeac0047d91b~tplv-k3u1fbpfcp-watermark.image?" alt="k8snet3.svg"></p><p><strong>图3 跨节点的pod 之间的通信</strong></p><p>pod1 将数据包发送至自己的以太网设备eth0;</p><p>到达网桥之后发现目的地址，不在当前宿主机</p><pre><code>underlay 方式，之间通过路由方式将，当前包的下一条路由至对端节点；到达对端节点之后同样路由至网桥上；然后到达pod 3overlay 方式（以vxlan为例）将数据包封装一层vxlan，目的地址封装为对端宿主机地址通过eth0发出；到达对端之后经由vlxan网卡解封装，路由至网桥；到达pod3</code></pre><h2 id="3-pod-to-service"><a href="#3-pod-to-service" class="headerlink" title="3 pod to service"></a>3 pod to service</h2><p>上面我们展示了pod 之间的通信，但是我们要知道的是，pod作为k8s集群中最小的工作单位，在设计之初就被认为是不稳定的，宿主机节点的内存、网络、等等各种小问题都容易导致pod重启，这是pod 的IP很容易变化。为了应对这些变化service出现了</p><p>service 对应着一组pod，当访问service时流量会被打散到这组pod(分配不一定均匀，这个要结合下kube-proxy来看)</p><p><code>iptables</code>:一个用户空间程序，它提供了一个基于表的系统，用于定义使用 netfilter 框架操作和转换数据包的规则。在 Kubernetes 中，iptables 规则由 kube-proxy 控制器配置，该控制器监视 Kubernetes API 服务器的更改,当kube-proxy使用iptables模式时，kube-proxy 会将对应service 的iptables规则注入到各个节点的iptables表中，当流量匹配到时，就会根据iptables表规则转发</p><p><code>ipvs</code>IPVS（IP 虚拟服务器）也构建在 netfilter 之上，并将传输层负载平衡作为 Linux 内核的一部分实现。IPVS 被合并到 LVS（Linux 虚拟服务器）中，它在主机上运行并充当真实服务器集群前面的负载平衡器。IPVS 可以将基于 TCP 和 UDP 的服务的请求定向到真实服务器，并使真实服务器的服务在单个 IP 地址上表现为虚拟服务。这使得 IPVS 非常适合 Kubernetes 服务</p><p>当集群规模较大时，iptables模式会有明显的iptables规则过多导致查询缓慢的问题，缓慢是网络所不能容忍的，所以k8s在新版本开始支持ipvs，但是当前市面上应用较多的还是iptables</p><p>当然kubernetes service 也有多种的网络模式，为了方便讲述，这里以cluster ip service 为例如图4所示</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41900d50f0e6412b81d94f3066016d3b~tplv-k3u1fbpfcp-watermark.image?" alt="k8snet4.svg"></p><p><strong>图4 pod to service</strong></p><p>当数据包到达网桥之后，被iptables 捕获到，经过nat之后，将流量穿发至后端pod所在节点</p><p>当访问node port模式的service 的是其实也是差不多的，只不过流量要先到node 上，然后再被iptables规则捕获，只是这样的话，pod 到node 再到 pod ，多经过了一次封装，网络性能又会下降一点</p><p>其实还有个loadbalance的service ，因为我自己也没遇到过，所以先不写</p><h2 id="4-外部网络到容器网络"><a href="#4-外部网络到容器网络" class="headerlink" title="4 外部网络到容器网络"></a>4 外部网络到容器网络</h2><p>其实上面的几种网络模型，已经把私有云网络基本覆盖了，但是又是我们希望我们的服务能够暴露给外部流量，所以就有了下面的两种问题</p><h3 id="4-1-egress-将集群流量转发到Internet"><a href="#4-1-egress-将集群流量转发到Internet" class="headerlink" title="4.1 egress 将集群流量转发到Internet"></a>4.1 egress 将集群流量转发到Internet</h3><p>这里每个不同的CNI实现的都略有差异，但是总体来说还是nat 。当数据包到达宿主机之后，被iptables 拦截，经过snat之后源地址被修改为egress ip地址，随后通过数据网卡将流量转发至外部</p><h3 id="4-2-ingress"><a href="#4-2-ingress" class="headerlink" title="4.2 ingress"></a>4.2 ingress</h3><p>ingress 在k8s官方文档中有很详细的文档介绍，这里我只做一个简单的介绍，我们把他理解成外部网络访问ingress，ingress 根据访问接口不同通过ingress 将流量分配到对应的业务service 中</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e84cc744e2184845a1a98c6bdcbab32d~tplv-k3u1fbpfcp-watermark.image?" alt="ingress.svg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kubernetes的网络模型&quot;&gt;&lt;a href=&quot;#Kubernetes的网络模型&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes的网络模型&quot;&gt;&lt;/a&gt;Kubernetes的网络模型&lt;/h1&gt;&lt;p&gt;前言：kubernetes作为云原生
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>云原生网络基础</title>
    <link href="http://yoursite.com/2023/02/15/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2023/02/15/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</id>
    <published>2023-02-15T13:38:59.000Z</published>
    <updated>2023-02-15T13:42:21.557Z</updated>
    
    <content type="html"><![CDATA[<p>前言，云原生网络的基础就是在主机层面的网络虚拟化而来，将原有的网络空间通过虚拟化隔离出单独的网络空间。在宿主机中的每个容器获得一个单独的网络空间，对网络资源的隔离就是云原生网络的基础。所以本文主要是对云原生的基石linux 网络虚拟化相关的知识相关笔记</p><h2 id="network-namespace"><a href="#network-namespace" class="headerlink" title="network namespace"></a>network namespace</h2><p>  linux 的network namespace技术可以自定义一个独立的网络栈，简单到只有loopback设备，复杂到具备系统完整的网络能力，linux namespace的作用就是隔离内核资源，想要使用namespace里的资源，首先要进入到，namespace中，而且还无法跨namespace访问资源</p><ul><li>ip netns</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip netns add netns1</span><br><span class="line">ip netns list </span><br><span class="line">ip netns exec netns1 sh </span><br><span class="line">ip netns delete netns1</span><br></pre></td></tr></table></figure><p>  当ip命令创建一个network namespace之后，系统会在/var/run/netns路径下生成一个挂载点，挂载点的作用一是对namespace管理二是namespace没有进程运行也能存在</p><ul><li>配置namespace<br>创建的namespace中会附带创建一个本地回环地址lo，状态还是down的，所以访问当前namespace的本地回环地址是不通的<br>想要与外界通信的话，需要在namespace里再创建一对veth pair，并将其一端放于当前namespace，一端放于想要互通的namespace<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link add veth0 type veth peer name veth1</span><br><span class="line">ip link set veth1 netns netns1</span><br></pre></td></tr></table></figure></li></ul><p>到目前为止，在netns1 namespace内部，仍然不能与外界通信，因为这两个块网卡还处于down状态，还需要手动为网卡绑定IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec netns1 ifconfig veth1 10.1.1.1&#x2F;24 up</span><br><span class="line">ifconfig veth0 10.1.1.1.2&#x2F;24 up</span><br></pre></td></tr></table></figure><p>此外，不同的namespace直接的路由表和防火墙规则等也是隔离的，所以netns1的路由表和防火墙没法和主机共享路由表和防火墙</p><h2 id="veth-pair"><a href="#veth-pair" class="headerlink" title="veth pair"></a>veth pair</h2><p>veth pair是虚拟以太网卡(Virtual Ethernet)的缩写，veth设备总是成对的，所以成为veth pair，一端发送的数据会在另一端接收，非常像linux的双向管道，使用可以参照network namespace</p><h2 id="linux-bridge"><a href="#linux-bridge" class="headerlink" title="linux bridge"></a>linux bridge</h2><p>网桥是二层设备，两个端口Denbighshire有一条独立的交换信道，不共享一条背板总线。linux bridge就是linux系统中的网桥，但是linux bridge的行为更像是一台网络虚拟交换机</p><ul><li>创建bridge</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link add name br0 type bridge </span><br><span class="line">ip linl set br0 up</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brctl addbr br0</span><br></pre></td></tr></table></figure><p>刚刚创建的bridge是一个独立的网络设备，只有一个端口连接协议栈，其它端口什么都没连，这里加上一堆veth设备，并配置IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip link add veth0 type veth peer name veth1</span><br><span class="line">ip addr add 1.2.3.1&#x2F;24 dev veth0 </span><br><span class="line">ip addr add 1.2.3.2&#x2F;24 dev veth1</span><br><span class="line">ip link set veth0 up </span><br><span class="line">ip link set veth0 up</span><br></pre></td></tr></table></figure><p>将veth0连接到br0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link set dev veth0 master br0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brctl addif br0 veth0</span><br></pre></td></tr></table></figure><p>查看当前网桥上连接了哪些设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bridge link</span><br><span class="line">brctl show</span><br></pre></td></tr></table></figure><p>br0和veth0相连之后发生了如下变化</p><p>br0和veth0直接连接起来了，并且是双向通道，协议站和veth0直接变成了单项通道，协议栈能发送数据给veth0，但veth0收到的数据不会转发给协议栈,直接转发给bridge了</p><p>从上面分析可以看出，给veth0分配IP没有意义，因为就算协议栈传数据包给veth0，回程报文也回不来，所以直接把veth0的IP地址让给，linux bridge</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip addr del 1.2.3.101&#x2F;24 dev veth0</span><br><span class="line">ip addr add 1.2.3.101&#x2F;24 dev br0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 1 -I br0 1.2.3.102</span><br></pre></td></tr></table></figure><p>这样就可以ping通veth1了但是还是ping不通网关，因为网桥上只有veth1 和 veth2 ，不知道网关的地址</p><p>所以把物理网卡也加到bridge上</p><h2 id="tun-tap"><a href="#tun-tap" class="headerlink" title="tun/tap"></a>tun/tap</h2><p>tun/tap设备，从linux文件系统角度看，是用户可以用文件句柄操作的字符设备，从网络虚拟化角度看，是虚拟网卡，一端连接网络协议栈，一端连接用户态程序。tun表示虚拟的是点对点设备，tap表示虚拟的是以太网设备。tun/tap设备可以讲TCP/ip协议栈处理好的网络包发送给任何一个使用tun/tap驱动的进程，由进程冲洗处理后发到物理链路中。</p><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>iptables底层实现是，netfilter，它提供了一整套hook函数的管理机制，使得数据包过滤，包处理（设置标志位、修改TTL等）、地址伪装、网络地址转换、透明代理等功能<br><del>因为iptables 相对复杂，篇幅所限不很难讲解透彻，感兴趣的可以自行了解，要点在iptables 的四表五链</del></p><h2 id="ipip"><a href="#ipip" class="headerlink" title="ipip"></a>ipip</h2><p>linux原生支持下列5种L3隧道，</p><ul><li>ipip：IPv4 in IPv4 ，在IPv4报文的基础上再封装一个IPv4报文</li><li>GRE：通用路由封装（Generic Routing Encapsulation）,定义了在任意的一种网络协议上封装其它任意一种网络层协议的机制，v4和v6都支持</li><li>sitL和ipip类似，不同的是用IPv4报文封装IPv6</li><li>ISATAP：站内自动隧道寻址协议与sit类似，也用于IPv6的隧道封装</li><li>VTI：虚拟隧道接口，思科提出的一种IPSec隧道技术</li></ul><p><strong>Linux L3隧道底层实现原理都基于tun设备</strong></p><h2 id="VXLan"><a href="#VXLan" class="headerlink" title="VXLan"></a>VXLan</h2><h2 id="Macvlan"><a href="#Macvlan" class="headerlink" title="Macvlan"></a>Macvlan</h2><p>macvlan接口可以看作是物理以太网接口的虚拟子接口，macvlan允许用户在主机的一个网络接口上配置多个虚拟的网络接口，每个macvlan接口都有自己区别于父接口的Mac地址，并且可以像普通的网络接口一样分配IP地址，，一块物理网卡上可以绑定多个IP地址，每个IP地址都有自己的MAC地址</p><p>bridge模式：区别于linux网桥，不需要学习mac地址，性能要优于 linux bridge. 相同父接口的两块macvlan虚拟网卡可以直接通信，不需要把流量通过父接口发送到外部网络。</p><p>vepa模式：默认模式，所有从macvlan接口发出的流量都会从父接口发出，经由交换机处理</p><p>private模式，类似vepa模式，但是增强了隔离，完全阻止了，同一父接口的macvlan之间的通信，</p><p>passthru:模式，直通模式，macvlan每个父接口只能绑定一个macvlan</p><p>在容器网络中，访问跨节点的容器，物理网卡（父接口）相当于一个交换机，对应进出其子Macvlan网卡的数据包，只转发，不处理，所以使用本机Macvlan网卡的IP，无法和本届物理网卡IP通信。</p><p>只为虚拟机或容器提供访问外部物理网络的连接</p><h2 id="IPvlan"><a href="#IPvlan" class="headerlink" title="IPvlan"></a>IPvlan</h2><p>和macvlan类似，IPvlan也是从一个主机接口虚拟出多个虚拟网络接口，区别在于IPvlan所有的虚拟接口都是相同的MAC地址，但是IP地址却不同，所有的IPvlan共享mac地址，所以需要注意DHCP使用的场景，DHCP分配IP地址的时候一般回用MAC地址所谓机器表示，所以在使用MACVlan的情况下，客户端动态获取PI的时候需要配置唯一的clientID，</p><p>IPvlan有L2和L3两种模式，一个父接口只能选择其中一种模式</p><ul><li>L2模式：和macvlan的bridge模式工作原理相似，父接口作为交换机转发子接口的数据，同一个网络的子接口可以通过父接口转发数据，如果想发送到其它网络，则报文回通过父接口的路由转发出去</li><li>L3模式，有点像路由器的功能。IPvlan在各个虚拟网络和主机网络之间进行不同网络报文的路由转发工作。只要父接口相同，即使虚拟机/容器不在同一个网络内，也可以互通</li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>很多的网络问题都和路由有关，所以需要能看懂路由表，已经如何添加修改 在命令行中输入<code>route -n</code> 或者<code>netstat -rn</code>打印本机路由表输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         10.22.19.254    0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">10.22.19.0      0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line">10.96.0.0       0.0.0.0         255.240.0.0     U     0      0        0 boc0</span><br><span class="line">169.254.169.254 10.22.19.1      255.255.255.255 UGH   0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br></pre></td></tr></table></figure><h3 id="字段解释"><a href="#字段解释" class="headerlink" title="字段解释"></a>字段解释</h3><ul><li><p><code>Destination</code> :目的网段，最长匹配0.0.0.0</p></li><li><p><code>Gateway</code>: 网关 0.0.0.0 表示无网关，即与本机IP同一网段，不需要经过网关(同一局域网的两台主机通信不需要经过网关)</p></li><li><p><code>GenMask:</code> 子网掩码</p></li><li><p><code>Flags</code> ：</p><p>  U - Up表示有效 G - Gateway表示连接路由，若无这个字段表示直连目的地址 H - Host表示目标是具体主机，而不是网段 R 恢复动态路由产生的表项 D 由路由的后台程序动态地安装 M 由路由的后台程序修改</p><p>  ! 拒绝路由址 H-Host表示目标是具体主机不是网段。</p></li><li><p><code>Metric:</code> 路由距离，到达指定网络所需要的中转数，大型局域网和广域网所必须的</p></li><li><p><code>Ref</code>: 路由项的引用次数（不在linux内核中使用）</p></li><li><p><code>Use</code>:此路由项被路由软件查找的次数</p></li><li><p><code>Iface</code>:网卡名</p></li></ul><h3 id="路由类型"><a href="#路由类型" class="headerlink" title="路由类型"></a>路由类型</h3><p><strong>主机路由</strong>：路由表中执行单个IP地址或者主机名的路由记录，Flag值为H</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.0.0.0        10.139.128.1    255.255.255.0   UG    0      0        0 eth0</span><br></pre></td></tr></table></figure><p><strong>网络路由</strong>： 主机可到达的网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.0.0.0        10.139.128.1    255.255.255.0   UG    0      0        0 eth0</span><br></pre></td></tr></table></figure><p><strong>默认路由</strong>： 目标主机的IP或者网络不在路由表中，数据包就被发往默认网关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         gateway         0.0.0.0         UG    0      0        0 eth0</span><br></pre></td></tr></table></figure><h3 id="路由命令"><a href="#路由命令" class="headerlink" title="路由命令"></a>路由命令</h3><p><code>-A</code>：设置地址类型 <code>-C</code>：打印 Linux 内核的路由缓存 <code>-v</code>：显示详细信息 <code>-n</code>：不执行 DNS 反向查找，直接显示数字形式的 IP 地址 <code>-e</code>：netstat 格式显示路由表 <code>-net</code>：到一个网络的路由表 <code>-host</code>：到一个主机的路由表</p><p>参数：</p><p><code>add</code>：增加路由记录 <code>del</code>：删除路由记录 <code>target</code>：目的网络或目的主机 <code>gw</code>：设置默认网关 <code>mss</code>：设置TCP的最大区块长度（MSS），单位MB <code>window</code>：指定通过路由表的TCP连接的TCP窗口大小 <code>dev</code>：路由记录所表示的网络接口</p><ul><li>1、添加主机路由，添加主机路由时，需要指定网络 ID 和主机 ID，此时需要设置 netmask 255.255.255.255</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_139_74_centos ~]# route add -net 10.0.0.10 netmask 255.255.255.255 gw 10.139.128.1 dev eth0</span><br><span class="line">[root@VM_139_74_centos ~]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.0.0.10       10.139.128.1    255.255.255.255 UGH   0      0        0 eth0</span><br></pre></td></tr></table></figure><ul><li>2 添加网络路由，添加网络路由时，只需指定网络 ID，通过 netmask 设置掩码长度：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_139_74_centos ~]# route add -net 10.0.0.0 netmask 255.255.255.0 gw 10.139.128.1 dev eth0</span><br><span class="line">[root@VM_139_74_centos ~]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.0.0.0        10.139.128.1    255.255.255.0   UG    0      0        0 eth0</span><br></pre></td></tr></table></figure><ul><li>3 添加同一个局域网的主机，不指定 gw 选项时，添加的路由记录不使用网关</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_139_74_centos ~]# route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0</span><br><span class="line">[root@VM_139_74_centos ~]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br></pre></td></tr></table></figure><ul><li>4 屏蔽路由</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_139_74_centos ~]# route add -net 224.0.0.0 netmask 240.0.0.0 reject</span><br><span class="line">[root@VM_139_74_centos ~]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">224.0.0.0       -               240.0.0.0       !     0      -        0 -</span><br></pre></td></tr></table></figure><ul><li>5删除可用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0</span><br></pre></td></tr></table></figure><ul><li>6 删除屏蔽路由</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0 reject</span><br></pre></td></tr></table></figure><ul><li>7 删除和添加设置默认网关，添加或删除默认网关时，Linux 会自动检查网关的可用性：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_139_74_centos ~]# route add default gw 192.168.1.1</span><br><span class="line">SIOCADDRT: Network is unreachable</span><br><span class="line">[root@VM_139_74_centos ~]# route del default gw 192.168.1.1</span><br><span class="line">SIOCDELRT: No such process</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言，云原生网络的基础就是在主机层面的网络虚拟化而来，将原有的网络空间通过虚拟化隔离出单独的网络空间。在宿主机中的每个容器获得一个单独的网络空间，对网络资源的隔离就是云原生网络的基础。所以本文主要是对云原生的基石linux 网络虚拟化相关的知识相关笔记&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从零开始的K8S</title>
    <link href="http://yoursite.com/2021/10/22/K8S%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"/>
    <id>http://yoursite.com/2021/10/22/K8S%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</id>
    <published>2021-10-22T15:02:47.000Z</published>
    <updated>2021-10-22T15:04:26.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从零开始搭建Kubernetes集群"><a href="#从零开始搭建Kubernetes集群" class="headerlink" title="从零开始搭建Kubernetes集群"></a>从零开始搭建Kubernetes集群</h1><p><strong>以Centos系统为例，以下操作步骤5在主节点操作，步骤1-4需要在所有节点进行</strong></p><h2 id="1、升级系统内核"><a href="#1、升级系统内核" class="headerlink" title="1、升级系统内核"></a>1、升级系统内核</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">更新yum源</span><br><span class="line">yum -y update</span><br><span class="line">获取源</span><br><span class="line">rpm -Uvh http:&#x2F;&#x2F;www.elrepo.org&#x2F;elrepo-release-7.0-4.el7.elrepo.noarch.rpm</span><br><span class="line">安装</span><br><span class="line">yum --enablerepo&#x3D;elrepo-kernel install -y kernel-lt </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">离线安装</span><br><span class="line">下载RPM包https:&#x2F;&#x2F;elrepo.org&#x2F;linux&#x2F;kernel&#x2F;el7&#x2F;x86_64&#x2F;RPMS&#x2F; #选择自己想要的版本下载对应的</span><br><span class="line">wget https:&#x2F;&#x2F;elrepo.org&#x2F;linux&#x2F;kernel&#x2F;el7&#x2F;x86_64&#x2F;RPMS&#x2F;kernel-lt-4.4.206-1.el7.elrepo.x86_64.rpm</span><br><span class="line">安装</span><br><span class="line">yum localinstall -y kernel-lt-4.4.206-1.el7.elrepo.x86_64.rpm</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">查看全部的系统内核</span><br><span class="line">sudo awk -F\&#39; &#39;$1&#x3D;&#x3D;&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#39; &#x2F;etc&#x2F;grub2.cfg</span><br><span class="line">设置开机从新内核启动</span><br><span class="line">grub2-set-default 0</span><br><span class="line">生成grub配置文件</span><br><span class="line">grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfg</span><br><span class="line">重启使配置有效</span><br><span class="line">reboot</span><br><span class="line">查看正在使用的内核</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure><h2 id="2、安装kube系列程序"><a href="#2、安装kube系列程序" class="headerlink" title="2、安装kube系列程序"></a>2、安装kube系列程序</h2><p>使用本地软件包管理软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name&#x3D;Kubernetes</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64&#x2F;</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">repo_gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>安装kubelet kubeadm kubectl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#版本可以根据自己选择</span><br><span class="line">yum install -y kubelet-1.18.2 kubeadm-1.18.2 kubectl-1.18.2</span><br><span class="line"></span><br><span class="line">#设置kubelet开机启动</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure><h2 id="3、安装docker"><a href="#3、安装docker" class="headerlink" title="3、安装docker"></a>3、安装docker</h2><p>使用国内的阿里镜像安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br><span class="line">  </span><br><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><p>安装最新版本的 Docker Engine-Community 和 containerd </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line">根据自己的需要（如自己的镜像仓库地址）更新docker的配置文件&#x2F;etc&#x2F;docker&#x2F;daemon.json,如果没有可以不必要刻意设置</span><br><span class="line"># 使docker配置生效</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"># 开机启动docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="4、linux系统配置更改"><a href="#4、linux系统配置更改" class="headerlink" title="4、linux系统配置更改"></a>4、linux系统配置更改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、设置路由策略</span><br><span class="line">lsmod | grep br_netfilter</span><br><span class="line">2、使桥接流量对iptables可见</span><br><span class="line">cat &lt;&lt;EOF &gt;  &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sysctl --system</span><br><span class="line"></span><br><span class="line">3、关闭swap</span><br><span class="line">sudo sed -i &#39;&#x2F; swap &#x2F; s&#x2F;^\(.*\)$&#x2F;#\1&#x2F;g&#39; &#x2F;etc&#x2F;fstab</span><br><span class="line">sudo swapoff -a</span><br><span class="line">4、关闭防火墙</span><br><span class="line">sudo systemctl stop firewalld.service   #停止firewall</span><br><span class="line">sudo systemctl disable firewalld.service #禁止firewall开机启动</span><br><span class="line">sudo firewall-cmd --state             #查看防火墙状态</span><br><span class="line">5、禁用selinux</span><br><span class="line">sudo setenforce 0</span><br><span class="line">sudo vi &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line">#SELINUX修改为disabled</span><br><span class="line">SELINUX&#x3D;disabled</span><br></pre></td></tr></table></figure><h2 id="5、初始化集群"><a href="#5、初始化集群" class="headerlink" title="5、初始化集群"></a>5、初始化集群</h2><p><strong>初始化集群时要注意所使用的cni插件是否对参数有要求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubeadm init --kubernetes-version&#x3D;1.18.2 \</span><br><span class="line">--apiserver-advertise-address&#x3D;192.168.253.11 \</span><br><span class="line">--ignore-preflight-errors&#x3D;all \</span><br><span class="line">--image-repository registry.aliyuncs.com&#x2F;google_containers \</span><br><span class="line">--service-cidr&#x3D;10.1.0.0&#x2F;16 \</span><br><span class="line">--pod-network-cidr&#x3D;10.244.0.0&#x2F;16</span><br></pre></td></tr></table></figure><p>apiserver地址就是master的地址，最后两个参数是service和pod的cidr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">根据kubeadm init之后提示的执行如下命令</span><br><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line">sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br></pre></td></tr></table></figure><h2 id="6、加入集群"><a href="#6、加入集群" class="headerlink" title="6、加入集群"></a>6、加入集群</h2><p>集群初始化后会给出一个kubeadm join的命令，如果不是刚刚初始化的集群，可以使用<code>kubeadm token create --print-join-command</code>生成加入集群的命令</p><p>加入集群之后可以使用 <code>kubectl get node</code>来查看集群中的节点</p><p>将master节点的<code>/root/.kube/config</code>文件拷贝至其他node可以让kubectl在其它节点同样生效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从零开始搭建Kubernetes集群&quot;&gt;&lt;a href=&quot;#从零开始搭建Kubernetes集群&quot; class=&quot;headerlink&quot; title=&quot;从零开始搭建Kubernetes集群&quot;&gt;&lt;/a&gt;从零开始搭建Kubernetes集群&lt;/h1&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GoSocket</title>
    <link href="http://yoursite.com/2020/10/30/GoSocket/"/>
    <id>http://yoursite.com/2020/10/30/GoSocket/</id>
    <published>2020-10-30T13:38:51.000Z</published>
    <updated>2020-10-31T02:45:43.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="socket概念："><a href="#socket概念：" class="headerlink" title="socket概念："></a>socket概念：</h1><p>socket，指套接字用于描述IP地址和端口。可以实现不同程序间的数据通信 （网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。 ）</p><p>Socket起源于Unix，而Unix基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，网络的Socket数据传输是一种特殊的I/O，Socket也是一种文件描述符。Socket也具有一个类似于打开文件的函数调用：Socket()，该函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。</p><h1 id="socket通信原理"><a href="#socket通信原理" class="headerlink" title="socket通信原理"></a>socket通信原理</h1><p>socket是通过TCP/IP协议族来提供网络链接。Socket是应用程序和运输层之间的抽象层，封装了TCP/IP协议族，用一组简单的接口就能就能通过网络链接通信。下图为网上经典图，用户不需要知道TCP/IP的各种复杂功能协议等，直接使用Socket提供的接口就能完成所有工作。 </p><p><img src="https://segmentfault.com/img/bVt7xq" alt=""></p><h1 id="TCP和UDP编程区别"><a href="#TCP和UDP编程区别" class="headerlink" title="TCP和UDP编程区别"></a>TCP和UDP编程区别</h1><p>TCP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt(); * 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、开启监听，用函数listen()；<br>　　5、接收客户端上来的连接，用函数accept()；<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接；<br>　　8、关闭监听；<br>　　TCP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();* 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>　　4、设置要连接的对方的IP地址和端口等属性；<br>　　5、连接服务器，用函数connect()；<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接；</p><p>　　与之对应的UDP编程步骤要简单许多，分别如下：<br>　　UDP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();* 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、循环接收数据，用函数recvfrom();<br>　　5、关闭网络连接；<br>　　UDP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();* 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>　　4、设置对方的IP地址和端口等属性;<br>　　5、发送数据，用函数sendto();<br>　　6、关闭网络连接；</p><h1 id="socket通信流程"><a href="#socket通信流程" class="headerlink" title="socket通信流程"></a>socket通信流程</h1><p>服务端： 首先服务端需要<strong>初始化Socket</strong>，然后与<strong>端口绑定(bind)</strong>，<strong>对端口进行监听(listen)</strong>，<strong>调用accept阻塞</strong>，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。 </p><p>客户端：客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。 </p><p><img src="https://segmentfault.com/img/bVN3xV?w=478&h=491" alt=""></p><p>socket提供的主要接口：</p><p>初始化（int socket）、绑定（int bind）、监听（listen）、接受请求（accpet）</p><h1 id="SOCKET状态介绍"><a href="#SOCKET状态介绍" class="headerlink" title="SOCKET状态介绍"></a><strong>SOCKET状态介绍</strong></h1><p>​    1、客户端独有的：（1）SYN_SENT （2）FIN_WAIT1 （3）FIN_WAIT2 （4）CLOSING （5）TIME_WAIT 。</p><p>​    2、服务器独有的：（1）LISTEN （2）SYN_RCVD （3）CLOSE_WAIT （4）LAST_ACK 。</p><p>​    3、共有的：（1）CLOSED （2）ESTABLISHED 。</p><p>各个状态的意义如下： </p><p><strong>LISTEN</strong> - 侦听来自远方TCP端口的连接请求； </p><p><strong>SYN-SENT</strong> -在发送连接请求后等待匹配的连接请求； </p><p><strong>SYN-RECEIVED</strong>- 在收到和发送一个连接请求后等待对连接请求的确认； </p><p><strong>ESTABLISHED</strong>- 代表一个打开的连接，数据可以传送给用户； </p><p><strong>FIN-WAIT-1</strong> - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p><p><strong>FIN-WAIT-2</strong> - 从远程TCP等待连接中断请求； </p><p><strong>CLOSE-WAIT</strong> - 等待从本地用户发来的连接中断请求； </p><p><strong>CLOSING</strong> -等待远程TCP对连接中断的确认； </p><p><strong>LAST-ACK</strong> - 等待原来发向远程TCP的连接中断请求的确认； </p><p><strong>TIME-WAIT</strong> -等待足够的时间以确保远程TCP接收到连接中断请求的确认； </p><p><strong>CLOSED</strong> - 没有任何连接状态；</p><h1 id="go操作socket"><a href="#go操作socket" class="headerlink" title="go操作socket"></a>go操作socket</h1><p> go的net包对socket的各个接口都做了封装，但是原理还是和上图的流程一样，这里只演示go如何渐离socket通信</p><p><strong>服务端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// net listen 函数 传入socket类型和ip端口，返回监听对象</span></span><br><span class="line">    listener, err := net.Listen(socket.Server_NetWorkType,socket.Server_Address)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="comment">// 循环等待客户端访问</span></span><br><span class="line">        <span class="keyword">for</span>&#123;</span><br><span class="line">            conn,err := listener.Accept()</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span>&#123;</span><br><span class="line">                <span class="comment">// 一旦有外部请求，并且没有错误 直接开启异步执行</span></span><br><span class="line">                <span class="keyword">go</span> handleConn(conn)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"server error"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listener.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 设置读取超时时间</span></span><br><span class="line">        conn.SetReadDeadline(time.Now().Add(time.Second * <span class="number">2</span>))</span><br><span class="line">        <span class="comment">// 调用公用方法read 获取客户端传过来的消息。</span></span><br><span class="line">        <span class="keyword">if</span> str, err := socket.Read(conn); err == <span class="literal">nil</span>&#123;</span><br><span class="line">            fmt.Println(<span class="string">"client:"</span>,conn.RemoteAddr(),str)</span><br><span class="line">            <span class="comment">// 通过write 方法往客户端传递一个消息</span></span><br><span class="line">            socket.Write(conn,<span class="string">"server got:"</span>+str)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>客户端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用net包中的dial 传入ip 端口 进行拨号连接，通过三次握手之后获取到conn</span></span><br><span class="line">    conn,err := net.Dial(socket.Server_NetWorkType, socket.Server_Address)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"Client create conn error err:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    <span class="comment">//往服务端传递消息</span></span><br><span class="line">    socket.Write(conn,<span class="string">"aaaa"</span>)</span><br><span class="line">    <span class="comment">//读取服务端返回的消息</span></span><br><span class="line">    <span class="keyword">if</span> str, err := socket.Read(conn);err == <span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Println(str)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;socket概念：&quot;&gt;&lt;a href=&quot;#socket概念：&quot; class=&quot;headerlink&quot; title=&quot;socket概念：&quot;&gt;&lt;/a&gt;socket概念：&lt;/h1&gt;&lt;p&gt;socket，指套接字用于描述IP地址和端口。可以实现不同程序间的数据通信 （网络上
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mysql和MongoDB对比和使用场景</title>
    <link href="http://yoursite.com/2020/10/26/Mysql%E5%92%8CMongoDB%E5%AF%B9%E6%AF%94%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2020/10/26/Mysql%E5%92%8CMongoDB%E5%AF%B9%E6%AF%94%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2020-10-26T15:19:08.000Z</published>
    <updated>2020-10-26T15:20:46.160Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/linguoguo/p/10640179.html" target="_blank" rel="noopener">参考自</a></p><h2 id="MongoDB："><a href="#MongoDB：" class="headerlink" title="MongoDB："></a>MongoDB：</h2><p><strong>更高的写入负载</strong></p><p>默认情况下，MongoDB更侧重高数据写入性能，而非事务安全，MongoDB很适合业务系统中有大量“低价值”数据的场景。但是应当避免在高事务安全性的系统中使用MongoDB，除非能从架构设计上保证事务安全。</p><p><strong>高可用性</strong></p><p>MongoDB的复副集(Master-Slave)配置非常简洁方便，此外，MongoDB可以快速响应的处理单节点故障，自动、安全的完成故障转移。这些特性使得MongoDB能在一个相对不稳定（如云主机）的环境中，保持高可用性。</p><p><strong>数据量很大或者未来会变得很大</strong></p><p>依赖数据库(MySQL)自身的特性，完成数据的扩展是较困难的事，在MySQL中，当一个单达表到5-10GB时会出现明显的性能降级，此时需要通过数据的水平和垂直拆分、库的拆分完成扩展，使用MySQL通常需要借助驱动层或代理层完成这类需求。而MongoDB内建了多种数据分片的特性，可以很好的适应大数据量的需求。</p><p><strong>基于位置的数据查询</strong></p><p>MongoDB支持二维空间索引，因此可以快速及精确的从指定位置获取数据。</p><p><strong>表结构不明确，且数据在不断变大</strong></p><p>在一些传统RDBMS中，增加一个字段会锁住整个数据库/表，或者在执行一个重负载的请求时会明显造成其它请求的性能降级。通常发生在数据表大于1G的时候（当大于1TB时更甚）。 因MongoDB是文档型数据库，为非结构货的文档增加一个新字段是很快速的操作，并且不会影响到已有数据。另外一个好处当业务数据发生变化时，是将不在需要由DBA修改表结构。</p><h2 id="Mysql："><a href="#Mysql：" class="headerlink" title="Mysql："></a>Mysql：</h2><p>1）这些数据通常需要做结构化查询，比如join，这时候，关系型数据库就要胜出一筹 </p><p>2）这些数据的规模、增长的速度通常是可以预期的 </p><p>3）事务性、一致性</p><p>4）丰富的锁机制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/linguoguo/p/10640179.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考自&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;MongoDB：&quot;&gt;&lt;a href=&quot;#MongoD
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>go常见数据结构实现原理</title>
    <link href="http://yoursite.com/2020/10/02/go%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/10/02/go%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-10-02T10:48:42.000Z</published>
    <updated>2020-10-31T12:08:46.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h1><p>channel是Golang在语言层面提供的goroutine间的通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信，如果需要跨进程通信，建议使用分布式系统的方法来解决。 </p><h2 id="chan数据结构"><a href="#chan数据结构" class="headerlink" title="chan数据结构"></a>chan数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// 当前队列中剩余元素个数</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// 环形队列长度，即可以存放的元素个数</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">    closed   <span class="keyword">uint32</span>            <span class="comment">// 标识关闭状态</span></span><br><span class="line">    elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>           <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>           <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">    recvq    waitq          <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">    sendq    waitq          <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line">    lock mutex              <span class="comment">// 互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据结构可以看出channel由队列、类型信息、goroutine等待队列组成 </p><h3 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h3><p>chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。 </p><p>下图展示了一个可缓存6个元素的channel示意图： </p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_f1b42d200c5d94d02eeacef7c99aa81b_r.png" alt="channel示意图"></p><ul><li>dataqsiz指示了队列长度为6，即可缓存6个元素；</li><li>buf指向队列的内存，队列中还剩余两个元素；</li><li>qcount表示队列中还有两个元素；</li><li>sendx指示后续写入的数据存储的位置，取值[0, 6)；</li><li>recvx指示从该位置读取数据, 取值[0, 6)；</li></ul><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。<br>向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。</p><p>被阻塞的goroutine将会挂在channel的等待队列中：</p><ul><li>因读阻塞的goroutine会被向channel写入数据的goroutine唤醒；</li><li>因写阻塞的goroutine会被从channel读数据的goroutine唤醒；</li></ul><p>下图展示了一个没有缓冲区的channel，有几个goroutine阻塞等待读数据：</p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_f48c37e012c38de53aeb532c993b6d2d_r.png" alt="等待队列"></p><p>注意，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。 </p><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。</p><ul><li>elemtype代表类型，用于数据传递过程中的赋值；</li><li>elemsize代表类型大小，用于在buf中定位元素位置。</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>一个channel同时只被goroutine读写</p><h2 id="channel的读写"><a href="#channel的读写" class="headerlink" title="channel的读写"></a>channel的读写</h2><h3 id="channel创建"><a href="#channel创建" class="headerlink" title="channel创建"></a>channel创建</h3><p>使用make关键字创建，在创建时需要写明chan内的信息类型，和缓冲区大小（可选项，可以创建无缓冲区的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan &#123;</span><br><span class="line">    var c *hchan</span><br><span class="line">    c &#x3D; new(hchan)</span><br><span class="line">    c.buf &#x3D; malloc(元素类型大小*size)</span><br><span class="line">    c.elemsize &#x3D; 元素类型大小</span><br><span class="line">    c.elemtype &#x3D; 元素类型</span><br><span class="line">    c.dataqsiz &#x3D; size</span><br><span class="line"></span><br><span class="line">    return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="channel写入数据"><a href="#channel写入数据" class="headerlink" title="channel写入数据"></a>channel写入数据</h3><p>向一个channel中写数据简单过程如下：</p><ol><li>如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；</li><li>如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；</li><li>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；</li></ol><p>简单流程图如下：</p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_b235ef1f2c6ac1b5d63ec5660da97bd2_r.png" alt="写入数据的流程"></p><h3 id="从channel读数据"><a href="#从channel读数据" class="headerlink" title="从channel读数据"></a>从channel读数据</h3><p>从一个channel读数据简单过程如下：</p><ol><li>如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；</li><li>如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；</li><li>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；</li><li>将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；</li></ol><p>简单流程图如下：</p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_933ca9af4c3ec1db0b94b8b4ec208d4b_r.png" alt=""></p><h3 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h3><p>关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。</p><p>除此之外，panic出现的常见场景还有：</p><ol><li>关闭值为nil的channel</li><li>关闭已经被关闭的channel</li><li>向已经关闭的channel写数据</li></ol><h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><p>Slice又称动态数组，依托数组实现，可以方便的进行扩容、传递等，实际使用中比数组更灵活。 </p><p><strong>切片与底层数组共享一个内容地址，当切片的值改变时会影响底层数组的值也一起改变，当切片扩容时会重新申请内存地址，此时切片不会再影响底层数组</strong></p><p><strong>Slice依托数组实现，底层数组对用户屏蔽，在底层数组容量不足时可以实现自动重分配并生成新的Slice。 接下来按照实际使用场景分别介绍其实现机制。</strong></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer<span class="comment">//指向底层数组</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span><span class="comment">//长度</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span><span class="comment">//容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用make创建Slice"><a href="#使用make创建Slice" class="headerlink" title="使用make创建Slice"></a>使用make创建Slice</h3><p>使用make来创建Slice时，可以同时指定长度和容量，创建时底层会分配一个数组，数组的长度即容量。</p><p>例如，语句<code>slice := make([]int, 5, 10)</code>所创建的Slice，结构如下图所示：</p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_332a02ff2dc338bb2cce150a23d37b1c_r.png" alt=""></p><p>该Slice长度为5，即可以使用下标slice[0] ~ slice[4]来操作里面的元素，capacity为10，表示后续向slice添加新的元素时可以不必重新分配内存，直接使用预留内存即可。 </p><h3 id="使用数组创建Slice"><a href="#使用数组创建Slice" class="headerlink" title="使用数组创建Slice"></a>使用数组创建Slice</h3><p>使用数组来创建Slice时，Slice将与原数组共用一部分内存。</p><p>例如，语句<code>slice := array[5:7]</code>所创建的Slice，结构如下图所示：</p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_c6aff21b79ce0b735065a702cb84c684_r.png" alt=""></p><p>切片从数组array[5]开始，到数组array[7]结束（不含array[7]），即切片长度为2，<strong>数组后面的内容都作为切片的预留内存，即capacity为5。</strong></p><p><strong>数组和切片操作可能作用于同一块内存，这也是使用过程中需要注意的地方。</strong></p><h3 id="slice扩容"><a href="#slice扩容" class="headerlink" title="slice扩容"></a>slice扩容</h3><p>使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容，<strong>扩容实际上是重新分配一块更大的内存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去。</strong></p><p>例如，当向一个capacity为5，且length也为5的Slice再次追加1个元素时，就会发生扩容，如下图所示：</p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_a87b8e2fb06bff1ea78f6096b7e81325_r.png" alt="扩容地址"></p><p>扩容操作只关心容量，会把原Slice数据拷贝到新Slice，追加数据由append在扩容结束后完成。上图可见，扩容后新的Slice长度仍然是5，但容量由5提升到了10，原Slice的数据也都拷贝到了新Slice指向的数组中。</p><p>扩容容量的选择遵循以下规则：</p><ul><li>如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍；</li><li>如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍；</li></ul><p>使用append()向Slice添加一个元素的实现步骤如下：</p><ul><li>假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice</li><li>原Slice容量不够，则将Slice先扩容，扩容后得到新Slice</li><li>将新元素追加进新Slice，Slice.len++，返回新的Slice。</li></ul><h3 id="slice-copy"><a href="#slice-copy" class="headerlink" title="slice copy"></a>slice copy</h3><p>使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小值。</p><p>例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。</p><p><strong>也就是说，copy过程中不会发生扩容。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min= <span class="built_in">copy</span>(<span class="built_in">make</span>([]<span class="keyword">struct</span>&#123;&#125;,a),<span class="built_in">make</span>([]<span class="keyword">struct</span>&#123;&#125;,b))</span><br></pre></td></tr></table></figure><p>用在函数里可以表示返回a和b间的最小值</p><h3 id="特殊切片"><a href="#特殊切片" class="headerlink" title="特殊切片"></a>特殊切片</h3><p>根据数组或切片生成新的切片一般使用<code>slice := array[start:end]</code>方式，这种新生成的切片并没有指定切片的容量，实际上新切片的容量是从start开始直至array的结束。</p><p>比如下面两个切片，长度和容量都是一致的，使用共同的内存地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sliceA := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">sliceB := sliceA[<span class="number">0</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>根据数组或切片生成切片还有另一种写法，即切片同时也指定容量，即slice[start:end:cap], 其中cap即为新切片的容量，当然容量不能超过原切片实际值，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sliceA := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)  <span class="comment">//length = 5; capacity = 10</span></span><br><span class="line">sliceB := sliceA[<span class="number">0</span>:<span class="number">5</span>]         <span class="comment">//length = 5; capacity = 10</span></span><br><span class="line">sliceC := sliceA[<span class="number">0</span>:<span class="number">5</span>:<span class="number">5</span>]       <span class="comment">//length = 5; capacity = 5</span></span><br></pre></td></tr></table></figure><p>这切片方法不常见，在Golang源码里能够见到，不过非常利于切片的理解。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>创建切片时可根据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能；</li><li>切片拷贝时需要判断实际拷贝的元素个数</li><li>谨慎使用多个切片操作同一个数组，以防读写冲突</li><li>每个切片都指向一个底层数组</li><li>每个切片都保存了当前切片的长度、底层数组可用容量</li><li>使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片</li><li>使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片</li><li>通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而已</li><li>使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片</li></ul><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="map数据结构"><a href="#map数据结构" class="headerlink" title="map数据结构"></a>map数据结构</h2><p>Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="keyword">int</span> <span class="comment">// 当前保存的元素个数</span></span><br><span class="line">    ...</span><br><span class="line">    B         <span class="keyword">uint8</span></span><br><span class="line">    ...</span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// bucket数组指针，数组的大小为2^B</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示一个拥有4个bucket的map： </p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_897a05f6373f7f966d00d1bfea6274d2_r.png" alt=""></p><p>本例中, <code>hmap.B=2</code>， 而hmap.buckets长度是2^B为4. 元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。</p><p><code>bucket</code>很多时候被翻译为桶，所谓的<code>哈希桶</code>实际上就是bucket。</p><h2 id="bucket底层结构"><a href="#bucket底层结构" class="headerlink" title="bucket底层结构"></a>bucket底层结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [<span class="number">8</span>]<span class="keyword">uint8</span> <span class="comment">//存储哈希值的高8位</span></span><br><span class="line">    data    <span class="keyword">byte</span>[<span class="number">1</span>]  <span class="comment">//key value数据:key/key/key/.../value/value/value...</span></span><br><span class="line">    overflow *bmap   <span class="comment">//溢出bucket的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个bucket可以存储8个键值对。</p><ul><li>tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。</li><li>data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。</li><li>overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。</li></ul><p>注意：上述中data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。</p><p>下图展示bucket存放8个key-value对：</p><p> <img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_7f0ba5a124641b1413279892581513c4_r.png" alt=""></p><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。 由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。 </p><p>下图展示产生冲突后的map： </p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_a8b9e5919d9951a71c1c36445dd68521_r.png" alt=""></p><h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>负载因子用于衡量一个哈希表冲突情况，公式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负载因子 &#x3D; 键数量&#x2F;bucket数量</span><br></pre></td></tr></table></figure><p>例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1.</p><p>哈希表需要将负载因子控制在合适的大小，超过其阀+值需要进行rehash，也即键值对重新组织：</p><ul><li>哈希因子过小，说明空间利用率低</li><li>哈希因子过大，说明冲突严重，存取效率低</li></ul><p>每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。</p><h2 id="渐进式扩容"><a href="#渐进式扩容" class="headerlink" title="渐进式扩容"></a>渐进式扩容</h2><h3 id="扩容前提"><a href="#扩容前提" class="headerlink" title="扩容前提"></a>扩容前提</h3><p>为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。<br>触发扩容的条件有二个：</p><ol><li>负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。</li><li>overflow数量 &gt; 2^15时，也即overflow数量超过32768时</li></ol><h3 id="增量扩容"><a href="#增量扩容" class="headerlink" title="增量扩容"></a>增量扩容</h3><p>当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。<br>考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。</p><p>下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):</p><p> <img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_2d622a6bc19ca1b5bcb225f77869f9c2_r.png" alt=""></p><p>当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。</p><p>当第8个键值对插入时，将会触发扩容，扩容后示意图如下：</p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_2f0122f26e5d66ca91e6820ace6b379b_r.png" alt=""></p><p>hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。<br>后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。</p><p>搬迁完成后的示意图如下：</p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_b1178e0a3cea02c9386e5f5eaa6f99a6_r.png" alt=""></p><p>数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。 实际搬迁过程中比较复杂，将在后续源码分析中详细介绍。 </p><h3 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h3><p>所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。<br>在极端场景下，比如不断地增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：</p><p> <img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_f3a5989c90204df9304d5ae246f3db72_r.png" alt=""></p><p>上图可见，overflow的bucket中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。 </p><h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><p>查找过程如下：</p><ol><li>根据key值算出哈希值</li><li>取哈希值低位与hmap.B取模确定bucket位置</li><li>取哈希值高位在tophash数组中查询</li><li>如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较</li><li>当前bucket没有找到，则继续从下个overflow的bucket中查找。</li><li>如果当前处于搬迁过程，则优先从oldbuckets查找</li></ol><p>注：如果查找不到，也不会返回空值，而是返回相应类型的0值。</p><h2 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h2><p>新元素插入过程如下：</p><ol><li>根据key值算出哈希值</li><li>取哈希值低位与hmap.B取模确定bucket位置</li><li>查找该key是否已经存在，如果存在则直接更新值</li><li>如果没找到将key，将key插入</li></ol><h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><p>Go的struct声明允许字段附带<code>Tag</code>来对字段做一些标记。</p><p>该<code>Tag</code>不仅仅是一个字符串那么简单，因为其主要用于反射场景，<code>reflect</code>包中提供了操作<code>Tag</code>的方法，所以<code>Tag</code>写法也要遵循一定的规则。</p><h2 id="Tag的本质"><a href="#Tag的本质" class="headerlink" title="Tag的本质"></a>Tag的本质</h2><h3 id="Tag规则"><a href="#Tag规则" class="headerlink" title="Tag规则"></a>Tag规则</h3><p><code>Tag</code>本身是一个字符串，但字符串中却是：<code>以空格分隔的 key:value 对</code>。</p><ul><li><code>key</code>: 必须是非空字符串，字符串不能包含控制字符、空格、引号、冒号。</li><li><code>value</code>: 以双引号标记的字符串</li><li>注意：冒号前后不能有空格</li></ul><p>如下代码所示，如此写没有实际意义，仅用于说明<code>Tag</code>规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Server struct &#123;</span><br><span class="line">    ServerName string &#96;key1: &quot;value1&quot; key11:&quot;value11&quot;&#96;</span><br><span class="line">    ServerIP   string &#96;key2: &quot;value2&quot;&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码<code>ServerName</code>字段的<code>Tag</code>包含两个key-value对。<code>ServerIP</code>字段的<code>Tag</code>只包含一个key-value对。</p><h3 id="Tag是Struct的一部分"><a href="#Tag是Struct的一部分" class="headerlink" title="Tag是Struct的一部分"></a>Tag是Struct的一部分</h3><p>前面说过，<code>Tag</code>只有在反射场景中才有用，而反射包中提供了操作<code>Tag</code>的方法。在说方法前，有必要先了解一下Go是如何管理struct字段的。</p><p>以下是<code>reflect</code>包中的类型声明，省略了部分与本文无关的字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A StructField describes a single field in a struct.</span><br><span class="line">type StructField struct &#123;</span><br><span class="line">    &#x2F;&#x2F; Name is the field name.</span><br><span class="line">    Name string</span><br><span class="line">    ...</span><br><span class="line">    Type      Type      &#x2F;&#x2F; field type</span><br><span class="line">    Tag       StructTag &#x2F;&#x2F; field tag string</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StructTag string</span><br></pre></td></tr></table></figure><p>可见，描述一个结构体成员的结构中包含了<code>StructTag</code>，而其本身是一个<code>string</code>。也就是说<code>Tag</code>其实是结构体字段的一个组成部分</p><h3 id="获取tag"><a href="#获取tag" class="headerlink" title="获取tag"></a>获取tag</h3><p><code>StructTag</code>提供了<code>Get(key string) string</code>方法来获取<code>Tag</code>，示例如下： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    ServerName <span class="keyword">string</span> <span class="string">`key1:"value1" key11:"value11"`</span></span><br><span class="line">    ServerIP   <span class="keyword">string</span> <span class="string">`key2:"value2"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Server&#123;&#125;</span><br><span class="line">    st := reflect.TypeOf(s)</span><br><span class="line"></span><br><span class="line">    field1 := st.Field(<span class="number">0</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"key1:%v\n"</span>, field1.Tag.Get(<span class="string">"key1"</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"key11:%v\n"</span>, field1.Tag.Get(<span class="string">"key11"</span>))</span><br><span class="line"></span><br><span class="line">    filed2 := st.Field(<span class="number">1</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"key2:%v\n"</span>, filed2.Tag.Get(<span class="string">"key2"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key1:value1</span><br><span class="line">key11:value11</span><br><span class="line">key2:value2</span><br></pre></td></tr></table></figure><h2 id="Tag存在的意义"><a href="#Tag存在的意义" class="headerlink" title="Tag存在的意义"></a>Tag存在的意义</h2><p>本文示例中tag没有任何实际意义，这是为了阐述tag的定义与操作方法，也为了避免与你之前见过的诸如<code>json:xxx</code>混淆。</p><p>使用反射可以动态的给结构体成员赋值，正是因为有tag，在赋值前可以使用tag来决定赋值的动作。<br>比如，官方的<code>encoding/json</code>包，可以将一个JSON数据<code>Unmarshal</code>进一个结构体，此过程中就使用了Tag。该包定义一些规则，只要参考该规则设置tag就可以将不同的JSON数据转换成结构体。</p><p>总之：正是基于struct的tag特性，才有了诸如json、orm等等的应用。理解这个关系是至关重要的。或许，你可以定义另一种tag规则，来处理你特有的数据。</p><h2 id="Tag常见用法"><a href="#Tag常见用法" class="headerlink" title="Tag常见用法"></a>Tag常见用法</h2><p>常见的tag用法，主要是JSON数据解析、ORM映射等。 </p><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="string标准概念"><a href="#string标准概念" class="headerlink" title="string标准概念"></a>string标准概念</h2><p>Go标准库<code>builtin</code>给出了所有内置类型的定义。<br>源代码位于<code>src/builtin/builtin.go</code>，其中关于string的描述如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; string is the set of all strings of 8-bit bytes, conventionally but not</span><br><span class="line">&#x2F;&#x2F; necessarily representing UTF-8-encoded text. A string may be empty, but</span><br><span class="line">&#x2F;&#x2F; not nil. Values of string type are immutable.</span><br><span class="line">type string string</span><br></pre></td></tr></table></figure><p>所以string是8比特字节的集合，通常是但并不一定非得是UTF-8编码的文本。</p><p>另外，还提到了两点，非常重要：</p><ul><li>string可以为空（长度为0），但不会是nil；</li><li>string对象不可以修改。</li></ul><h2 id="string-数据结构"><a href="#string-数据结构" class="headerlink" title="string 数据结构"></a>string 数据结构</h2><p>源码包<code>src/runtime/string.go:stringStruct</code>定义了string的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type stringStruct struct &#123;</span><br><span class="line">    str unsafe.Pointer</span><br><span class="line">    len int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其数据结构很简单：</p><ul><li>stringStruct.str：字符串的首地址；</li><li>stringStruct.len：字符串的长度；</li></ul><p>string数据结构跟切片有些类似，只不过切片还有一个表示容量的成员，事实上string和切片，准确的说是byte切片经常发生转换。这个后面再详细介绍。</p><h2 id="string操作"><a href="#string操作" class="headerlink" title="string操作"></a>string操作</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>如下代码所示，可以声明一个string变量变赋予初值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str string</span><br><span class="line">str &#x3D; &quot;Hello World&quot;</span><br></pre></td></tr></table></figure><p>字符串构建过程是先根据字符串构建stringStruct，再转换成string。转换的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func gostringnocopy(str *byte) string &#123; &#x2F;&#x2F; 根据字符串地址构建string</span><br><span class="line">    ss :&#x3D; stringStruct&#123;str: unsafe.Pointer(str), len: findnull(str)&#125; &#x2F;&#x2F; 先构造stringStruct</span><br><span class="line">    s :&#x3D; *(*string)(unsafe.Pointer(&amp;ss))                             &#x2F;&#x2F; 再将stringStruct转换成string</span><br><span class="line">    return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string在runtime包中就是stringStruct，对外呈现叫做string。</p><h3 id="byte转string"><a href="#byte转string" class="headerlink" title="[]byte转string"></a>[]byte转string</h3><p>byte切片可以很方便的转换成string，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func GetStringBySlice(s []byte) string &#123;</span><br><span class="line">    return string(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是这种转换需要一次内存拷贝。</p><p>转换过程如下：</p><ol><li>根据切片的长度申请内存空间，假设内存地址为p，切片长度为len(b)；</li><li>构建string（string.str = p；string.len = len；）</li><li>拷贝数据(切片中数据拷贝到新申请的内存空间)</li></ol><p>转换示意图：</p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_0317d71784cf0c9b1a00cee014429c40_r.png" alt="null"></p><h3 id="string转-byte"><a href="#string转-byte" class="headerlink" title="string转[]byte"></a>string转[]byte</h3><p>string也可以方便的转成byte切片，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func GetSliceByString(str string) []byte &#123;</span><br><span class="line">    return []byte(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string转换成byte切片，也需要一次内存拷贝，其过程如下：</p><ul><li>申请切片内存空间</li><li>将string拷贝到切片</li></ul><p>转换示意图：</p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_5f500d01a01d45f69ea523a1789f9748_r.png" alt="null"></p><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>字符串可以很方便的拼接，像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str :&#x3D; &quot;Str1&quot; + &quot;Str2&quot; + &quot;Str3&quot;</span><br></pre></td></tr></table></figure><p>即便有非常多的字符串需要拼接，性能上也有比较好的保证，因为新字符串的内存空间是一次分配完成的，所以性能消耗主要在拷贝数据上。</p><p>一个拼接语句的字符串编译时都会被存放到一个切片中，拼接过程需要遍历两次切片，第一次遍历获取总的字符串长度，据此申请内存，第二次遍历会把字符串逐个拷贝过去。</p><p>字符串拼接伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func concatstrings(a []string) string &#123; &#x2F;&#x2F; 字符串拼接</span><br><span class="line">    length :&#x3D; 0        &#x2F;&#x2F; 拼接后总的字符串长度</span><br><span class="line"></span><br><span class="line">    for _, str :&#x3D; range a &#123;</span><br><span class="line">        length +&#x3D; len(str)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s, b :&#x3D; rawstring(length) &#x2F;&#x2F; 生成指定大小的字符串，返回一个string和切片，二者共享内存空间</span><br><span class="line"></span><br><span class="line">    for _, str :&#x3D; range a &#123;</span><br><span class="line">        copy(b, str)    &#x2F;&#x2F; string无法修改，只能通过切片修改</span><br><span class="line">        b &#x3D; b[len(str):]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为string是无法直接修改的，所以这里使用rawstring()方法初始化一个指定大小的string，同时返回一个切片，二者共享同一块内存空间，后面向切片中拷贝数据，也就间接修改了string。</p><p>rawstring()源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func rawstring(size int) (s string, b []byte) &#123; &#x2F;&#x2F; 生成一个新的string，返回的string和切片共享相同的空间</span><br><span class="line">    p :&#x3D; mallocgc(uintptr(size), nil, false)</span><br><span class="line"></span><br><span class="line">    stringStructOf(&amp;s).str &#x3D; p</span><br><span class="line">    stringStructOf(&amp;s).len &#x3D; size</span><br><span class="line"></span><br><span class="line">    *(*slice)(unsafe.Pointer(&amp;b)) &#x3D; slice&#123;p, size, size&#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么字符串不允许修改？"><a href="#为什么字符串不允许修改？" class="headerlink" title="为什么字符串不允许修改？"></a>为什么字符串不允许修改？</h2><p>像C++语言中的string，其本身拥有内存空间，修改string是支持的。但Go的实现中，string不包含内存空间，只有一个内存的指针，这样做的好处是string变得非常轻量，可以很方便的进行传递而不用担心内存拷贝。</p><p>因为string通常指向字符串字面量，而字符串字面量存储位置是只读段，而不是堆或栈上，所以才有了string不可修改的约定。</p><h2 id="byte转换成string一定会拷贝内存吗？"><a href="#byte转换成string一定会拷贝内存吗？" class="headerlink" title="[]byte转换成string一定会拷贝内存吗？"></a>[]byte转换成string一定会拷贝内存吗？</h2><p>byte切片转换成string的场景很多，为了性能上的考虑，有时候只是临时需要字符串的场景下，byte切片转换成string时并不会拷贝内存，而是直接返回一个string，这个string的指针(string.str)指向切片的内存。</p><p>比如，编译器会识别如下临时场景：</p><ul><li>使用m[string(b)]来查找map（map是string为key，临时把切片b转成string）；</li><li>字符串拼接，如”&lt;” + “string(b)” + “&gt;”；</li><li>字符串比较：string(b) == “foo”</li></ul><p>因为是临时把byte切片转换成string，也就避免了因byte切片同容改成而导致string引用失败的情况，所以此时可以不必拷贝内存新建一个string。</p><h2 id="string和-byte如何取舍"><a href="#string和-byte如何取舍" class="headerlink" title="string和[]byte如何取舍"></a>string和[]byte如何取舍</h2><p>string和[]byte都可以表示字符串，但因数据结构不同，其衍生出来的方法也不同，要根据实际应用场景来选择。</p><p>string 擅长的场景：</p><ul><li>需要字符串比较的场景；</li><li>不需要nil字符串的场景；</li></ul><p>[]byte擅长的场景：</p><ul><li>修改字符串的场景，尤其是修改粒度为1个字节；</li><li>函数返回值，需要用nil表示含义的场景；</li><li>需要切片操作的场景；</li></ul><p>虽然看起来string适用的场景不如[]byte多，但因为string直观，在实际应用中还是大量存在，在偏底层的实现中[]byte使用更多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;chan&quot;&gt;&lt;a href=&quot;#chan&quot; class=&quot;headerlink&quot; title=&quot;chan&quot;&gt;&lt;/a&gt;chan&lt;/h1&gt;&lt;p&gt;channel是Golang在语言层面提供的goroutine间的通信方式，比Unix管道更易用也更轻便。channel主要
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>golang的协程调度</title>
    <link href="http://yoursite.com/2020/10/02/golang%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>http://yoursite.com/2020/10/02/golang%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6/</id>
    <published>2020-10-02T08:17:22.000Z</published>
    <updated>2020-10-02T10:39:32.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="goroutine的调度器模型"><a href="#goroutine的调度器模型" class="headerlink" title="goroutine的调度器模型"></a>goroutine的调度器模型</h1><p><strong>总结：goroutine是依赖于线程，所以gorountine必须调度到m上，p相当于一个调度的执行者p将goroutine调度到m中执行，一般p的个数相当于cpu的核数（可以修改）</strong></p><p>线程数过多，意味着操作系统会不断地切换线程，频繁的上下文切换就成了性能瓶颈。<br>Go提供一种机制，可以在线程中自己实现调度，上下文切换更轻量，从而达到了线程数少，而并发数并不少的效果。而线程中调度的就是Goroutine.</p><p>早期Go版本，比如1.9.2版本的源码注释中有关于调度器的解释。<br>Goroutine 调度器的工作就是把“ready-to-run”的goroutine分发到线程中。</p><p>Goroutine主要概念如下：</p><ul><li>G（Goroutine）: 即Go协程，每个go关键字都会创建一个协程。</li><li>M（Machine）： 工作线程，在Go中称为Machine。</li><li>P(Processor): 处理器（Go中定义的一个摡念，不是指CPU），包含运行Go代码的必要资源，也有调度goroutine的能力。</li></ul><p>M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队列，P可以调度G交由M执行。其关系如下图所示：</p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_274ee3af62bab4ad8f74a6753d6969cf_r.png" alt="mpg的调度模型"></p><p>图中M是交给操作系统调度的线程，M持有一个P，P将G调度进M中执行。P同时还维护着一个包含G的队列（图中灰色部分），可以按照一定的策略将G调度到M中执行。</p><p>P的个数在程序启动时决定，默认情况下等同于CPU的核数，由于M必须持有一个P才可以运行Go代码，所以同时运行的M个数，也即线程数一般等同于CPU的个数，以达到尽可能的使用CPU而又不至于产生过多的线程切换开销。</p><h1 id="goroutine的调度策略"><a href="#goroutine的调度策略" class="headerlink" title="goroutine的调度策略"></a>goroutine的调度策略</h1><h2 id="1、队列轮转"><a href="#1、队列轮转" class="headerlink" title="1、队列轮转"></a>1、队列轮转</h2><p>上图中可见每个P维护着一个包含G的队列，不考虑G进入系统调用或IO操作的情况下，P周期性的将G调度到M中执行，执行一小段时间，将上下文保存下来，然后将G放到队列尾部，然后从队列中重新取出一个G进行调度。</p><p>除了每个P维护的G队列以外，还有一个全局的队列，每个P会周期性地查看全局队列中是否有G待运行并将其调度到M中执行，全局队列中G的来源，主要有从系统调用中恢复的G。之所以P会周期性地查看全局队列，也是为了防止全局队列中的G被饿死。</p><p><strong>总结：go的并发是对goroutine的调度，goroutine队列周期性的调度到m中去执行，就是go并发的核心</strong></p><h2 id="2、系统调用"><a href="#2、系统调用" class="headerlink" title="2、系统调用"></a>2、系统调用</h2><p>上面说到P的个数默认等于CPU核数，每个M必须持有一个P才可以执行G，一般情况下M的个数会略大于P的个数，这多出来的M将会在G产生系统调用时发挥作用。类似线程池，Go也提供一个M的池子，需要时从池子中获取，用完放回池子，不够用时就再创建一个。</p><p>当M运行的某个G产生系统调用时，如下图所示：</p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_fd748bf1364411aa7929b84c155ef67a_r.png" alt="系统调用"></p><p>如图所示，当G0即将进入系统调用时，M0将释放P，进而某个空闲的M1获取P，继续执行P队列中剩下的G。而M0由于陷入系统调用而进被阻塞，M1接替M0的工作，只要P不空闲，就可以保证充分利用CPU。</p><p>M1的来源有可能是M的缓存池，也可能是新建的。当G0系统调用结束后，根据M0是否能获取到P，将会将G0做不同的处理：</p><ol><li>如果有空闲的P，则获取一个P，继续执行G0。</li><li>如果没有空闲的P，则将G0放入全局队列，等待被其他的P调度。然后M0将进入缓存池睡眠。</li></ol><h2 id="3、工作量窃取"><a href="#3、工作量窃取" class="headerlink" title="3、工作量窃取"></a>3、工作量窃取</h2><p>多个P中维护的G队列有可能是不均衡的，比如下图： </p><p><img src="http://wen.topgoer.com/uploads/gozhuanjia/images/m_511f878a3328cf036e73368eaf864177_r.png" alt=""></p><p>竖线左侧中右边的P已经将G全部执行完，然后去查询全局队列，全局队列中也没有G，而另一个M中除了正在运行的G外，队列中还有3个G待运行。此时，空闲的P会将其他P中的G偷取一部分过来，一般每次偷取一半。偷取完如右图所示。 </p><p><strong>总结，这个策略就是为了更高效的执行goroutine，平衡各个队列中的等待goroutine</strong></p><h2 id="4、GOMAXPROCS设置对性能的影响"><a href="#4、GOMAXPROCS设置对性能的影响" class="headerlink" title="4、GOMAXPROCS设置对性能的影响"></a>4、GOMAXPROCS设置对性能的影响</h2><p>一般来讲，程序运行时就将GOMAXPROCS大小设置为CPU核数，可让Go程序充分利用CPU。 在某些IO密集型的应用里，这个值可能并不意味着性能最好。 理论上当某个Goroutine进入系统调用时，会有一个新的M被启用或创建，继续占满CPU。 但由于Go调度器检测到M被阻塞是有一定延迟的，也即旧的M被阻塞和新的M得到运行之间是有一定间隔的，所以在IO密集型应用中不妨把GOMAXPROCS设置的大一些，或许会有好的效果。 </p><p><strong>参考</strong>：<a href="http://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">The Go scheduler</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;goroutine的调度器模型&quot;&gt;&lt;a href=&quot;#goroutine的调度器模型&quot; class=&quot;headerlink&quot; title=&quot;goroutine的调度器模型&quot;&gt;&lt;/a&gt;goroutine的调度器模型&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;总结：gorouti
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://yoursite.com/2020/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-07-08T02:30:59.000Z</published>
    <updated>2020-07-09T03:02:00.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、稀疏数组sparsearry"><a href="#1、稀疏数组sparsearry" class="headerlink" title="1、稀疏数组sparsearry"></a>1、稀疏数组sparsearry</h1><p>当一个数组中大部分元素为0，或者为同一值，可以使用稀疏数组来保存稀疏数组的处理方法。</p><p>1记录一个数组有几行几列，有多少不同的值</p><p>2把不同值的元素的行，列，值记录在一个小规模数组中，从而缩小程序的规模</p><p>应用实例</p><p>1使用稀疏数组，来保留类似的前面的二维数组（例如棋盘、地图）</p><p>2把稀疏数组存盘，并且可以重新恢复成二维数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ValNode <span class="keyword">struct</span> &#123;</span><br><span class="line">row <span class="keyword">int</span></span><br><span class="line">col <span class="keyword">int</span></span><br><span class="line">val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1创建一个原始数组(棋盘地图)</span></span><br><span class="line"><span class="keyword">var</span> chessMap [<span class="number">11</span>][<span class="number">11</span>] <span class="keyword">int</span></span><br><span class="line">chessMap[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span> <span class="comment">//黑子</span></span><br><span class="line">chessMap[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">2</span> <span class="comment">//白子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2看看输出的原始数组</span></span><br><span class="line"><span class="keyword">for</span> _,v :=<span class="keyword">range</span> chessMap&#123;</span><br><span class="line"><span class="keyword">for</span> _,v2 :=<span class="keyword">range</span> v&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t"</span>,v2)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、转成稀疏数组</span></span><br><span class="line"><span class="comment">//思路：创建一个node结构体</span></span><br><span class="line"><span class="comment">//遍历chessMap如果发现有一个元素的值不为0，将其放入对应切片</span></span><br><span class="line"><span class="keyword">var</span> sparseArr [] ValNode</span><br><span class="line"><span class="comment">//标准的稀疏数组应该含有记录元素二维数组的规模（行，列，默认值）</span></span><br><span class="line">valNode:=ValNode&#123;</span><br><span class="line"><span class="number">11</span>,</span><br><span class="line"><span class="number">11</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line">sparseArr = <span class="built_in">append</span>(sparseArr,valNode)</span><br><span class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> chessMap&#123;</span><br><span class="line"><span class="keyword">for</span> j,v2:=<span class="keyword">range</span> v&#123;</span><br><span class="line"><span class="keyword">if</span> v2!=<span class="number">0</span>&#123;</span><br><span class="line"><span class="comment">//创建一个ValNode的值节点</span></span><br><span class="line">valNode := ValNode&#123;</span><br><span class="line">i,</span><br><span class="line">j,</span><br><span class="line">v2,</span><br><span class="line">&#125;</span><br><span class="line">sparseArr = <span class="built_in">append</span>(sparseArr,valNode)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出稀疏数组</span></span><br><span class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> sparseArr&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d: %d %d %d\n"</span>,i,v.row,v.col,v.val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将稀疏数组存盘，</span></span><br><span class="line"><span class="comment">//恢复成原始数组(读取稀疏数组文件)用稀疏数组恢复</span></span><br><span class="line"><span class="keyword">var</span> chessMap2 [<span class="number">11</span>][<span class="number">11</span>]<span class="keyword">int</span></span><br><span class="line"><span class="comment">//遍历稀疏数组</span></span><br><span class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> sparseArr&#123;</span><br><span class="line"><span class="comment">//第一行是11 11 0 (数组的索引只到10第一行只是规定大小的所以直接跳过)</span></span><br><span class="line"><span class="keyword">if</span> i!=<span class="number">0</span>&#123;</span><br><span class="line">chessMap2[v.row][v.row]=v.val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检验是否被恢复</span></span><br><span class="line">fmt.Println(<span class="string">":::::::::::::::恢复之后的二维数组"</span>)</span><br><span class="line"><span class="keyword">for</span> _,v:=<span class="keyword">range</span> chessMap2&#123;</span><br><span class="line"><span class="keyword">for</span> _,v2:=<span class="keyword">range</span> v&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t"</span>,v2)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、队列-queue"><a href="#2、队列-queue" class="headerlink" title="2、队列(queue)"></a>2、队列(queue)</h1><p><strong>先进者先出，就是”队列”</strong> 我们可以想象成，排队买票，先来的先买，后来的只能在末尾，不允许插队。</p><p>队列的两个基本操作：<strong>入队</strong> 将一个数据放到队列尾部；<strong>出队</strong> 从队列的头部取出一个元素。队列也是一种<strong>操作受限的线性表数据结构</strong> 它具有先进先出的特性，支持队尾插入元素，在队头删除元素。队列是一个有序列表，可以用数组或是链表来实现</p><p>数组模拟队列</p><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下，必须有maxSize最大容量，因为队列的入队出队分别由前后两端来的需要两个变量front rear分别记录队首和队尾的下标 front会根据输出而改变，rear会根据输入而改变</p><h2 id="简单队列实现"><a href="#简单队列实现" class="headerlink" title="简单队列实现"></a>简单队列实现</h2><p>当取值使得队首到队尾时队列失效</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"prisma/errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用一个结构体管理队列</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">maxSize <span class="keyword">int</span></span><br><span class="line">array [<span class="number">4</span>]<span class="keyword">int</span> <span class="comment">//数组=》模拟队列</span></span><br><span class="line">front <span class="keyword">int</span><span class="comment">//表示指向队首</span></span><br><span class="line">rear <span class="keyword">int</span><span class="comment">//指向队尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加数据到队尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span><span class="title">AddQueue</span><span class="params">(val <span class="keyword">int</span>)</span><span class="params">(err error)</span></span>&#123;</span><br><span class="line"><span class="comment">//先判断队列是否已满</span></span><br><span class="line"><span class="keyword">if</span> this.rear == this.maxSize<span class="number">-1</span>&#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"queue full"</span>)</span><br><span class="line">&#125;</span><br><span class="line">this.rear++<span class="comment">//rear 后移</span></span><br><span class="line">this.array[this.rear]=val</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示队列，找到队首然后遍历到队尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span><span class="title">ShowQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i:=this.front+<span class="number">1</span>;i&lt;=this.rear;i++&#123;</span><br><span class="line"><span class="comment">//fmt.Println(this.array[i])</span></span><br><span class="line">fmt.Printf(<span class="string">"array[%d]=%d\n"</span>,i,this.array[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span><span class="title">GetQueue</span><span class="params">()</span><span class="params">(val <span class="keyword">int</span>,err error)</span></span>&#123;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> this.front==this.rear&#123;</span><br><span class="line">fmt.Println(<span class="string">"队列为空"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>,errors.New(<span class="string">"queue empty"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">this.front++</span><br><span class="line">val=this.array[this.front]</span><br><span class="line"><span class="keyword">return</span> val,err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">var</span> queue=&amp;Queue&#123;</span><br><span class="line"> maxSize:<span class="number">5</span>,</span><br><span class="line"> front:<span class="number">-1</span>,</span><br><span class="line"> rear:<span class="number">-1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> key <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> val <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"1输入add,表示添加数据到队列"</span>)</span><br><span class="line">fmt.Println(<span class="string">"2输入get,表示从队列中取出数据"</span>)</span><br><span class="line">fmt.Println(<span class="string">"3输入show,表示查看队列信息"</span>)</span><br><span class="line">fmt.Println(<span class="string">"4输入退出,表示退出"</span>)</span><br><span class="line">fmt.Scanln(&amp;key)</span><br><span class="line"><span class="keyword">switch</span> key &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">fmt.Println(<span class="string">"请输入你要输入队列的数据"</span>)</span><br><span class="line">fmt.Scanln(&amp;val)</span><br><span class="line">err:=queue.AddQueue(val)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"队列添加成功"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">queue.ShowQueue()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"get"</span>:</span><br><span class="line">val,err:=queue.GetQueue()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"取到一个数%d\n"</span>,val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"退出"</span>:</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><p> 数组需要空出以为作为标记</p><p>尾索引的下一位为头索引时表示队列满，即将队列容量空出一位作为约定，这个在做判断队列满时需要注意(rear+1)%maxSize=front则为满    rear=front为空，统计该队列有多少元素，（rear+maxSize-front)%maxSize</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"prisma/errors"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//使用一个结构体管理队列</span></span><br><span class="line"><span class="keyword">type</span> CircleQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">maxSize <span class="keyword">int</span></span><br><span class="line">array [<span class="number">4</span>]<span class="keyword">int</span> <span class="comment">//数组=》模拟队列</span></span><br><span class="line">front <span class="keyword">int</span><span class="comment">//表示指向队首</span></span><br><span class="line">rear <span class="keyword">int</span><span class="comment">//指向队尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加数据到队尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span><span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span><span class="params">(err error)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> this.IsFull() &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"queue full"</span>)</span><br><span class="line">&#125;</span><br><span class="line">this.array[this.rear]=val</span><br><span class="line">    <span class="comment">//核心思想当尾部坐标到达最后一位时通过取余值回到队首</span></span><br><span class="line">this.rear=(this.rear+<span class="number">1</span>)%this.maxSize</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span><span class="title">Pop</span><span class="params">()</span><span class="params">(Val <span class="keyword">int</span>,err error)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> this.IsEmpty()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>,errors.New(<span class="string">"queue empty"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">Val=this.array[this.front]</span><br><span class="line">this.front=(this.front+<span class="number">1</span>)%this.maxSize</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span><span class="title">ShowQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">size:=this.Size()</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"队列为空\n"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设计一个辅助变量，指向front</span></span><br><span class="line">temFront:=this.front</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size;i++&#123;</span><br><span class="line">fmt.Printf(<span class="string">"arr[%d]=%d\t"</span>,temFront,this.array[temFront])</span><br><span class="line">temFront=(temFront+<span class="number">1</span>)%this.maxSize</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出环形队列有多少元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *CircleQueue)</span><span class="title">Size</span><span class="params">()</span><span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (this.rear+this.maxSize-this.front)%this.maxSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断缓刑队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *CircleQueue)</span><span class="title">IsEmpty</span><span class="params">()</span><span class="title">bool</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> this.front==this.rear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断环形队列是否满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *CircleQueue)</span><span class="title">IsFull</span><span class="params">()</span><span class="title">bool</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (this.rear+<span class="number">1</span>)%this.maxSize==this.front</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> circlequeue=&amp;CircleQueue&#123;</span><br><span class="line">maxSize:<span class="number">4</span>,</span><br><span class="line">front:<span class="number">0</span>,</span><br><span class="line">rear:<span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> key <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> val <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"1输入add,表示添加数据到队列"</span>)</span><br><span class="line">fmt.Println(<span class="string">"2输入get,表示从队列中取出数据"</span>)</span><br><span class="line">fmt.Println(<span class="string">"3输入show,表示查看队列信息"</span>)</span><br><span class="line">fmt.Println(<span class="string">"4输入退出,表示退出"</span>)</span><br><span class="line">fmt.Scanln(&amp;key)</span><br><span class="line"><span class="keyword">switch</span> key &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">fmt.Println(<span class="string">"请输入你要输入队列的数据"</span>)</span><br><span class="line">fmt.Scanln(&amp;val)</span><br><span class="line">err:=circlequeue.Push(val)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"队列添加成功"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">circlequeue.ShowQueue()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"get"</span>:</span><br><span class="line">val,err:=circlequeue.Pop()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"取到一个数%d\n"</span>,val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"退出"</span>:</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、链表"><a href="#3、链表" class="headerlink" title="3、链表"></a>3、链表</h1><p>有序的列表</p><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个HeroNode</span></span><br><span class="line"><span class="keyword">type</span> HeroNode <span class="keyword">struct</span> &#123;</span><br><span class="line">   no       <span class="keyword">int</span></span><br><span class="line">   name       <span class="keyword">string</span></span><br><span class="line">   nickname   <span class="keyword">string</span></span><br><span class="line">   next       *HeroNode  <span class="comment">//这个字段表示指向下一节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给链表插入一个节点</span></span><br><span class="line"><span class="comment">//编写第一种插入方式，在单链表的最后加入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertHeroNode</span><span class="params">(head *HeroNode,newHeroNode *HeroNode)</span></span>&#123;</span><br><span class="line">   <span class="comment">//1先找到先找到该链表的最后一个节点</span></span><br><span class="line">   <span class="comment">//2创建一个辅助节点</span></span><br><span class="line">   temp:=head</span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> temp.next==<span class="literal">nil</span>&#123;<span class="comment">//表示找到最后的节点</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         temp=temp.next<span class="comment">//让temp不断的指向下一个节点直到找到最后一个节点</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3将newHeroNode加入到链表的最后</span></span><br><span class="line">   temp.next=newHeroNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//有序插入</span></span><br><span class="line"><span class="comment">//根据no的编号从小到大插入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertHeroNode2</span><span class="params">(head *HeroNode,newHeroNode *HeroNode)</span></span>&#123;</span><br><span class="line">   <span class="comment">//1找到适当节点</span></span><br><span class="line">   <span class="comment">//2创建一个辅助节点</span></span><br><span class="line">   flag:=<span class="literal">true</span></span><br><span class="line">   temp:=head</span><br><span class="line">   <span class="comment">//让插入的节点的no和temp的下一个节点的no比较</span></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> temp.next==<span class="literal">nil</span>&#123;<span class="comment">//说明到了链表最后</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> temp.next.no &gt; newHeroNode.no&#123;</span><br><span class="line">         <span class="comment">//说明newHeroNode就应该插入到temp后面</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> temp.next.no ==newHeroNode.no&#123;</span><br><span class="line">         <span class="comment">//说这个no已经存在了，不可插入</span></span><br><span class="line">         flag=<span class="literal">false</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      temp=temp.next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> !flag&#123;</span><br><span class="line">      fmt.Println(<span class="string">"对不起，已经存在这个no"</span>,newHeroNode.no)</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      newHeroNode.next=temp.next</span><br><span class="line">      temp.next=newHeroNode</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示链表的所有节点信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListHeroNode</span><span class="params">(head *HeroNode)</span></span>&#123;</span><br><span class="line">   <span class="comment">//创建辅助节点</span></span><br><span class="line">   temp:=head</span><br><span class="line">   <span class="comment">//先判断这个链表是否为空</span></span><br><span class="line">   <span class="keyword">if</span> temp.next==<span class="literal">nil</span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"空链表"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//遍历这个链表</span></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      fmt.Printf(<span class="string">"[%d,%s,%s]==&gt;"</span>,temp.next.no,temp.next.name,temp.next.nickname)</span><br><span class="line">      temp=temp.next</span><br><span class="line">      <span class="keyword">if</span> temp.next==<span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链表种的某个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DelHeroNode</span><span class="params">(head *HeroNode,id <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   temp:=head</span><br><span class="line">   <span class="comment">//设置是否可以找到删除的标记</span></span><br><span class="line">   flag:=<span class="literal">false</span></span><br><span class="line">   <span class="comment">//找到要删除的节点</span></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> temp.next==<span class="literal">nil</span>&#123;<span class="comment">//说明到了链表最后</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> temp.next.no &gt;id&#123;</span><br><span class="line">         <span class="comment">//说明newHeroNode就应该插入到temp后面</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> temp.next.no ==id&#123;</span><br><span class="line">         <span class="comment">//找到了需要删除的节点</span></span><br><span class="line">         flag=<span class="literal">true</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      temp=temp.next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> flag&#123;<span class="comment">//找到了需要删除的</span></span><br><span class="line">      temp.next=temp.next.next</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"需要删除的id不存在"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//1先创建一个头节点</span></span><br><span class="line">   head:=&amp;HeroNode&#123;&#125;</span><br><span class="line">   <span class="comment">//2.创建新的HerNode节点</span></span><br><span class="line">   hero1:=&amp;HeroNode&#123;</span><br><span class="line">      no:<span class="number">1</span>,</span><br><span class="line">      name:<span class="string">"宋江"</span>,</span><br><span class="line">      nickname:<span class="string">"及时雨"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   hero2:=&amp;HeroNode&#123;</span><br><span class="line">      no:<span class="number">2</span>,</span><br><span class="line">      name:<span class="string">"卢俊义"</span>,</span><br><span class="line">      nickname:<span class="string">"玉麒麟"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   hero3:=&amp;HeroNode&#123;</span><br><span class="line">      no:<span class="number">3</span>,</span><br><span class="line">      name:<span class="string">"林冲"</span>,</span><br><span class="line">      nickname:<span class="string">"豹子头"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3加入链表</span></span><br><span class="line">   InsertHeroNode(head,hero1)</span><br><span class="line">   InsertHeroNode(head,hero2)</span><br><span class="line">   InsertHeroNode(head,hero3)</span><br><span class="line">   <span class="comment">//4显示链表</span></span><br><span class="line">   ListHeroNode(head)</span><br><span class="line">   <span class="comment">//删除节点</span></span><br><span class="line">   DelHeroNode(head,<span class="number">2</span>)</span><br><span class="line">   ListHeroNode(head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>单向链表查询只能是一个方向，双向链表可以向前或者向后两个方向</p><p>单向链表不能自我删除，需要辅助节点（temp），而双向链表可以自我删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个HeroNode</span></span><br><span class="line"><span class="keyword">type</span> HeroNode <span class="keyword">struct</span> &#123;</span><br><span class="line">   no       <span class="keyword">int</span></span><br><span class="line">   name       <span class="keyword">string</span></span><br><span class="line">   nickname   <span class="keyword">string</span></span><br><span class="line">   pre         *HeroNode<span class="comment">//这个字段指向前一个节点</span></span><br><span class="line">   next       *HeroNode  <span class="comment">//这个字段表示指向下一节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给链表插入一个节点</span></span><br><span class="line"><span class="comment">//编写第一种插入方式，在单链表的最后加入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertHeroNode</span><span class="params">(head *HeroNode,newHeroNode *HeroNode)</span></span>&#123;</span><br><span class="line">   <span class="comment">//1先找到先找到该链表的最后一个节点</span></span><br><span class="line">   <span class="comment">//2创建一个辅助节点</span></span><br><span class="line">   temp:=head</span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> temp.next==<span class="literal">nil</span>&#123;<span class="comment">//表示找到最后的节点</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         temp=temp.next<span class="comment">//让temp不断的指向下一个节点直到找到最后一个节点</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3将newHeroNode加入到链表的最后</span></span><br><span class="line">   temp.next=newHeroNode</span><br><span class="line">   newHeroNode.pre = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//有序插入</span></span><br><span class="line"><span class="comment">//根据no的编号从小到大插入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertHeroNode2</span><span class="params">(head *HeroNode,newHeroNode *HeroNode)</span></span>&#123;</span><br><span class="line">   <span class="comment">//1找到适当节点</span></span><br><span class="line">   <span class="comment">//2创建一个辅助节点</span></span><br><span class="line">   flag:=<span class="literal">true</span></span><br><span class="line">   temp:=head</span><br><span class="line">   <span class="comment">//让插入的节点的no和temp的下一个节点的no比较</span></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> temp.next==<span class="literal">nil</span>&#123;<span class="comment">//说明到了链表最后</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> temp.next.no &gt; newHeroNode.no&#123;</span><br><span class="line">         <span class="comment">//说明newHeroNode就应该插入到temp后面</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> temp.next.no ==newHeroNode.no&#123;</span><br><span class="line">         <span class="comment">//说这个no已经存在了，不可插入</span></span><br><span class="line">         flag=<span class="literal">false</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      temp=temp.next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> !flag&#123;</span><br><span class="line">      fmt.Println(<span class="string">"对不起，已经存在这个no"</span>,newHeroNode.no)</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      newHeroNode.next=temp.next</span><br><span class="line">      newHeroNode.pre=temp</span><br><span class="line">      <span class="comment">//当temp是最后一位的时候没有下一位了不能调用pre</span></span><br><span class="line">      <span class="keyword">if</span> temp.next==<span class="literal">nil</span>&#123;</span><br><span class="line">         temp.next.pre=newHeroNode</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      temp.next=newHeroNode</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示链表的所有节点信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListHeroNode</span><span class="params">(head *HeroNode)</span></span>&#123;</span><br><span class="line">   <span class="comment">//创建辅助节点</span></span><br><span class="line">   temp:=head</span><br><span class="line">   <span class="comment">//先判断这个链表是否为空</span></span><br><span class="line">   <span class="keyword">if</span> temp.next==<span class="literal">nil</span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"空链表"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//遍历这个链表</span></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      fmt.Printf(<span class="string">"[%d,%s,%s]==&gt;"</span>,temp.next.no,temp.next.name,temp.next.nickname)</span><br><span class="line">      temp=temp.next</span><br><span class="line">      <span class="keyword">if</span> temp.next==<span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反向显示链表的所有节点信息（证明是双向链表）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListHeroNode2</span><span class="params">(head *HeroNode)</span></span>&#123;</span><br><span class="line">   <span class="comment">//创建辅助节点</span></span><br><span class="line">   temp:=head</span><br><span class="line">   <span class="comment">//先判断这个链表是否为空</span></span><br><span class="line">   <span class="keyword">if</span> temp.next==<span class="literal">nil</span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"空链表"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将temp定位到双向链表的结尾</span></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> temp.next==<span class="literal">nil</span>&#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历这个链表</span></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      fmt.Printf(<span class="string">"[%d,%s,%s]==&gt;"</span>,temp.no,temp.name,temp.nickname)</span><br><span class="line">      temp=temp.pre</span><br><span class="line">      <span class="keyword">if</span> temp.pre==<span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链表种的某个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DelHeroNode</span><span class="params">(head *HeroNode,id <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   temp:=head</span><br><span class="line">   <span class="comment">//设置是否可以找到删除的标记</span></span><br><span class="line">   flag:=<span class="literal">false</span></span><br><span class="line">   <span class="comment">//找到要删除的节点</span></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> temp.next==<span class="literal">nil</span>&#123;<span class="comment">//说明到了链表最后</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> temp.next.no &gt;id&#123;</span><br><span class="line">         <span class="comment">//说明newHeroNode就应该插入到temp后面</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> temp.next.no ==id&#123;</span><br><span class="line">         <span class="comment">//找到了需要删除的节点</span></span><br><span class="line">         flag=<span class="literal">true</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      temp=temp.next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> flag&#123;<span class="comment">//找到了需要删除的</span></span><br><span class="line">      temp.next=temp.next.next</span><br><span class="line">      <span class="keyword">if</span> temp.next!=<span class="literal">nil</span>&#123;</span><br><span class="line">         temp.next.pre=temp</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"需要删除的id不存在"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//1先创建一个头节点</span></span><br><span class="line">   head:=&amp;HeroNode&#123;&#125;</span><br><span class="line">   <span class="comment">//2.创建新的HerNode节点</span></span><br><span class="line">   hero1:=&amp;HeroNode&#123;</span><br><span class="line">      no:<span class="number">1</span>,</span><br><span class="line">      name:<span class="string">"宋江"</span>,</span><br><span class="line">      nickname:<span class="string">"及时雨"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   hero2:=&amp;HeroNode&#123;</span><br><span class="line">      no:<span class="number">2</span>,</span><br><span class="line">      name:<span class="string">"卢俊义"</span>,</span><br><span class="line">      nickname:<span class="string">"玉麒麟"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   hero3:=&amp;HeroNode&#123;</span><br><span class="line">      no:<span class="number">3</span>,</span><br><span class="line">      name:<span class="string">"林冲"</span>,</span><br><span class="line">      nickname:<span class="string">"豹子头"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3加入链表</span></span><br><span class="line">   InsertHeroNode(head,hero1)</span><br><span class="line">   InsertHeroNode(head,hero2)</span><br><span class="line">   InsertHeroNode(head,hero3)</span><br><span class="line">   <span class="comment">//4显示链表</span></span><br><span class="line">   ListHeroNode(head)</span><br><span class="line">   <span class="comment">//删除节点</span></span><br><span class="line">   <span class="comment">//DelHeroNode(head,2)</span></span><br><span class="line">   <span class="comment">//ListHeroNode(head)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义猫的结构体</span></span><br><span class="line"><span class="keyword">type</span> CatNode <span class="keyword">struct</span> &#123;</span><br><span class="line">   no <span class="keyword">int</span></span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   next *CatNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertCatNode</span><span class="params">(head *CatNode,newCatNode *CatNode)</span></span>&#123;</span><br><span class="line">   <span class="comment">//判断是不是添加第一个猫</span></span><br><span class="line">   <span class="keyword">if</span> head.next==<span class="literal">nil</span>&#123;</span><br><span class="line">      head.no=newCatNode.no</span><br><span class="line">      head.name=newCatNode.name</span><br><span class="line">      <span class="comment">//head.next不能指向newCatNode</span></span><br><span class="line">      head.next=head<span class="comment">//形成一个环状</span></span><br><span class="line">      fmt.Println(newCatNode,<span class="string">"加入到环形链表中"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//定义一个临时变量，帮忙找到环形的最后一个节点</span></span><br><span class="line">      temp:=head</span><br><span class="line">      <span class="keyword">for</span>&#123;</span><br><span class="line">         <span class="keyword">if</span> temp.next==head&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         temp=temp.next</span><br><span class="line">      &#125;</span><br><span class="line">      temp.next = newCatNode</span><br><span class="line">      newCatNode.next=head</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////删除节点</span></span><br><span class="line"><span class="comment">//func DeleteCatNode(head *CatNode,id int) *CatNode&#123;</span></span><br><span class="line"><span class="comment">// temp:=head</span></span><br><span class="line"><span class="comment">// helper:=head</span></span><br><span class="line"><span class="comment">// flag:=true</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// //如果环形链表是空的</span></span><br><span class="line"><span class="comment">// if temp.next==nil&#123;</span></span><br><span class="line"><span class="comment">//    fmt.Println("这是一个空的环形链表无法删除")</span></span><br><span class="line"><span class="comment">//    return head</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// //如果环形链表是只有一个节点</span></span><br><span class="line"><span class="comment">// if temp.next==head&#123;</span></span><br><span class="line"><span class="comment">//    temp.next=nil</span></span><br><span class="line"><span class="comment">//    return head</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// //将helper定位到链表最后</span></span><br><span class="line"><span class="comment">// for&#123;</span></span><br><span class="line"><span class="comment">//    if helper.next==head&#123;</span></span><br><span class="line"><span class="comment">//       break</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    helper=helper.next</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// //如果有两个或以上的节点</span></span><br><span class="line"><span class="comment">// for&#123;</span></span><br><span class="line"><span class="comment">//    if temp.next==head&#123;//说明已经比较到了最后一个（最后一个还没比较）</span></span><br><span class="line"><span class="comment">//       break</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    if temp.no==id&#123;</span></span><br><span class="line"><span class="comment">//       if temp==head&#123;//说明删除的是头节点</span></span><br><span class="line"><span class="comment">//          //删除头节点时需要注意</span></span><br><span class="line"><span class="comment">//          head=head.next</span></span><br><span class="line"><span class="comment">//          //但是尾部节点还指向原来的头节点</span></span><br><span class="line"><span class="comment">//          //所以需要把新的头节点暴露初老</span></span><br><span class="line"><span class="comment">//          return head</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//       //找到了要删除的</span></span><br><span class="line"><span class="comment">//       helper.next=temp.next</span></span><br><span class="line"><span class="comment">//       fmt.Printf("猫=%d\n",id)</span></span><br><span class="line"><span class="comment">//       flag=false</span></span><br><span class="line"><span class="comment">//       break</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    temp=temp.next //移动比较</span></span><br><span class="line"><span class="comment">//    helper=helper.next//移动【一旦找到要删除的节点 helper】</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// //在这里是为了判断前面没有判断的最后一位</span></span><br><span class="line"><span class="comment">// if flag&#123;//如果flag为真，则上面没有删除</span></span><br><span class="line"><span class="comment">//    fmt.Println("这里删除")</span></span><br><span class="line"><span class="comment">//    if temp.no==id&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//       helper.next=temp.next</span></span><br><span class="line"><span class="comment">//       fmt.Printf("猫=%d\n被删除",id)</span></span><br><span class="line"><span class="comment">//       //return head</span></span><br><span class="line"><span class="comment">//    &#125;else &#123;</span></span><br><span class="line"><span class="comment">//       fmt.Println("不存在无法删除")</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return head</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// return head</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteCatNode</span><span class="params">(head *CatNode,id <span class="keyword">int</span>)</span>*<span class="title">CatNode</span></span>&#123;</span><br><span class="line">   temp:=head</span><br><span class="line">   helper:=head</span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> helper.next==head&#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         helper=helper.next</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> temp.next==<span class="literal">nil</span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"空链表无法删除"</span>)</span><br><span class="line">      <span class="keyword">return</span> head</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> temp.next==head&#123;</span><br><span class="line">      temp.next=<span class="literal">nil</span></span><br><span class="line">      <span class="keyword">return</span> head</span><br><span class="line">   &#125;</span><br><span class="line">   flag:=<span class="literal">true</span></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> temp.next==head&#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> temp.no==id&#123;</span><br><span class="line">         <span class="keyword">if</span> temp==head&#123;</span><br><span class="line">            head=head.next</span><br><span class="line">         &#125;</span><br><span class="line">         fmt.Printf(<span class="string">"删除id=%d\n"</span>,id)</span><br><span class="line">         helper.next=temp.next</span><br><span class="line">         flag=<span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      temp=temp.next</span><br><span class="line">      helper=helper.next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> flag&#123;</span><br><span class="line">      <span class="keyword">if</span> temp.no==id&#123;</span><br><span class="line">         helper.next=temp.next</span><br><span class="line">         fmt.Printf(<span class="string">"删除id=%d\n"</span>,id)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出环形链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListCircleLink</span><span class="params">(head *CatNode)</span></span>&#123;</span><br><span class="line">   temp:=head</span><br><span class="line">   <span class="keyword">if</span> temp.next==<span class="literal">nil</span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"空链表"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      fmt.Printf(<span class="string">"猫链表的信息为=[id=%d name=%s]-&gt;\n"</span>,temp.no,temp.name)</span><br><span class="line">      <span class="keyword">if</span> temp.next==head&#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      temp=temp.next</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   head:=&amp;CatNode&#123;&#125;</span><br><span class="line">   cat1:=&amp;CatNode&#123;</span><br><span class="line">      no:<span class="number">1</span>,</span><br><span class="line">      name:<span class="string">"tom"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   cat2:=&amp;CatNode&#123;</span><br><span class="line">      no:<span class="number">2</span>,</span><br><span class="line">      name:<span class="string">"lili"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//cat3:=&amp;CatNode&#123;</span></span><br><span class="line">   <span class="comment">// no:3,</span></span><br><span class="line">   <span class="comment">// name:"sb",</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line">   InsertCatNode(head,cat1)</span><br><span class="line">   InsertCatNode(head,cat2)</span><br><span class="line">   <span class="comment">//InsertCatNode(head,cat3)</span></span><br><span class="line">   head=DeleteCatNode(head,<span class="number">1</span>)</span><br><span class="line">   <span class="comment">//fmt.Println(head)</span></span><br><span class="line">   fmt.Println(<span class="string">"hahhahhhhhhhhhhhhhhhhhhhhhhh"</span>)</span><br><span class="line">   ListCircleLink(head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用链表知识解决约瑟夫问题"><a href="#用链表知识解决约瑟夫问题" class="headerlink" title="用链表知识解决约瑟夫问题"></a>用链表知识解决约瑟夫问题</h3><p>设编号为1、2、。。。。。。n的n个人围坐一圈，约定编号为k(1&lt;k&lt;n)的人从1开始报数，数到m的人出列，它的下一位又从1开始报数，数到m的人又出列，以此类推直到所有人出列为止，由此产生一个出队编号的序列</p><p>思路</p><p>用一个不带头节点的循环链表来处理约瑟夫问题：先构成一个有n个节点的单循环链表，然后由k节点从1开始计数，记到m时，对应节点从链表种删除，然后从被删除节点的下一节点开始</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建boy结构体</span></span><br><span class="line"><span class="keyword">type</span> Boy <span class="keyword">struct</span> &#123;</span><br><span class="line">   No <span class="keyword">int</span> <span class="comment">//</span></span><br><span class="line">   Next *Boy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//形成单向环形链表</span></span><br><span class="line"><span class="comment">//传入小孩个数，返回头节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddBoy</span><span class="params">(num <span class="keyword">int</span>)</span>*<span class="title">Boy</span></span>&#123;</span><br><span class="line">   first:=&amp;Boy&#123;&#125;</span><br><span class="line">   curBoy:=&amp;Boy&#123;&#125;</span><br><span class="line">   <span class="keyword">if</span> num&lt;<span class="number">1</span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"num的值错误"</span>)</span><br><span class="line">      <span class="keyword">return</span> first</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//循环构建环形链表</span></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=num ;i++  &#123;</span><br><span class="line">      boy:=&amp;Boy&#123;</span><br><span class="line">         No:i,</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//形成循环链表curBoy作为辅助节点</span></span><br><span class="line">      <span class="keyword">if</span> i==<span class="number">1</span>&#123;</span><br><span class="line">         first=boy</span><br><span class="line">         curBoy=boy</span><br><span class="line">         curBoy.Next=first</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         curBoy.Next=boy</span><br><span class="line">         curBoy=boy</span><br><span class="line">         curBoy.Next=first</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示环形链表【遍历】</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowBoy</span><span class="params">(first *Boy)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//处理一下环形链表为空</span></span><br><span class="line">   <span class="keyword">if</span> first==<span class="literal">nil</span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"环形链表为空"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建一个指针帮助遍历说明至少有一个</span></span><br><span class="line">   curBoy:=first</span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      fmt.Printf(<span class="string">"小孩编号=%d -&gt;"</span>,curBoy.No)</span><br><span class="line">      <span class="keyword">if</span> curBoy.Next==first&#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      curBoy=curBoy.Next</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设编号为1、2、。。。。。。n的n个人围坐一圈，约定编号为k(1&lt;k&lt;n)的人从1开始报数，</span></span><br><span class="line"><span class="comment">// 数到m的人出列，它的下一位又从1开始报数，数到m的人又出列，</span></span><br><span class="line"><span class="comment">// 以此类推直到所有人出列为止，由此产生一个出队编号的序列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PlayGame</span><span class="params">(first *Boy,startNo <span class="keyword">int</span> ,countNum <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   <span class="comment">//1处理一下如果环形链表为空</span></span><br><span class="line">   <span class="keyword">if</span> first.Next==<span class="literal">nil</span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"链表为空，无法开始游戏"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//留一个，判断startNo&lt;=小孩总数</span></span><br><span class="line">   <span class="comment">//2定义辅助指针帮助我们删除小孩</span></span><br><span class="line">   tail:=first</span><br><span class="line">   <span class="comment">//3让辅助节点指向队尾</span></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> tail.Next==first&#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      tail=tail.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4让first移动到startNo后面删除时以first为准</span></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=startNo<span class="number">-1</span>;i++&#123;</span><br><span class="line">      first=first.Next</span><br><span class="line">      tail=tail.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5开始数countNum，然后删除指向的小孩</span></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="comment">//开始数countNum-1</span></span><br><span class="line">      <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=countNum<span class="number">-1</span>;i++ &#123;</span><br><span class="line">         first=first.Next</span><br><span class="line">         tail=tail.Next</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">"小孩编号为%d,出列-&gt;\n"</span>,first.No)</span><br><span class="line">      <span class="comment">//删除first指向的节点</span></span><br><span class="line">      first=first.Next</span><br><span class="line">      tail.Next=first</span><br><span class="line">      <span class="keyword">if</span> tail==first&#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//fmt.Printf("小孩编号为%d,出列-&gt;\n",first.No)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   first:=AddBoy(<span class="number">5</span>)</span><br><span class="line">   ShowBoy(first)</span><br><span class="line">   fmt.Println(<span class="string">"\n"</span>)</span><br><span class="line">   PlayGame(first,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、排序"><a href="#4、排序" class="headerlink" title="4、排序"></a>4、排序</h1><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><p>针对所有的元素重复以上的步骤，除了最后一个。</p><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">        length := <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">                <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; length<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line">                        <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">                                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。arr[n]经过n-1次</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">        length := <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length<span class="number">-1</span>; i++ &#123;</span><br><span class="line">                min := i</span><br><span class="line">                <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; length; j++ &#123;</span><br><span class="line">                        <span class="keyword">if</span> arr[min] &gt; arr[j] &#123;</span><br><span class="line">                                min = j</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[i], arr[min] = arr[min], arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> arr &#123;</span><br><span class="line">                preIndex := i - <span class="number">1</span></span><br><span class="line">                current := arr[i]</span><br><span class="line">            <span class="comment">//从大到小</span></span><br><span class="line">                <span class="keyword">for</span> preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current &#123;</span><br><span class="line">                        arr[preIndex+<span class="number">1</span>] = arr[preIndex]<span class="comment">//数据向后移一位</span></span><br><span class="line">                        preIndex -= <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                arr[preIndex+<span class="number">1</span>] = current</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速"><a href="#快速" class="headerlink" title="快速"></a>快速</h3><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、left表示数组左边的下表</span></span><br><span class="line"><span class="comment">//2、right表示数组右边的下表</span></span><br><span class="line"><span class="comment">//3、array表示要排序的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(left <span class="keyword">int</span>,right <span class="keyword">int</span>,array *[6]<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">l:=left</span><br><span class="line">r:=right</span><br><span class="line"><span class="comment">//pivot是中轴</span></span><br><span class="line">pivot:= array[(left+right)/<span class="number">2</span>]</span><br><span class="line">temp:=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for循环的目的是将比pivot小的放在左边，大的放在右边</span></span><br><span class="line"><span class="keyword">for</span> l&lt;r&#123;</span><br><span class="line"><span class="comment">//从pivot左边找到大于等于pivot的值</span></span><br><span class="line"><span class="keyword">for</span> array[l]&lt;pivot&#123;</span><br><span class="line">l++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从pivot右边边找到小于等于pivot的值</span></span><br><span class="line"><span class="keyword">for</span> array[r]&gt;pivot &#123;</span><br><span class="line">r--</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if l&gt;r&#123;</span></span><br><span class="line"><span class="comment">//break</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">temp=array[l]</span><br><span class="line">array[l]=array[r]</span><br><span class="line">array[r]=temp</span><br><span class="line"><span class="keyword">if</span> array[l]==pivot&#123;</span><br><span class="line">r--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> array[r]==pivot &#123;</span><br><span class="line">l++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向左递归</span></span><br><span class="line"><span class="keyword">if</span> left&lt;r&#123;</span><br><span class="line">QuickSort(left,r,array)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向右递归</span></span><br><span class="line"><span class="keyword">if</span> right&gt;l&#123;</span><br><span class="line">QuickSort(l,right,array)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、栈"><a href="#5、栈" class="headerlink" title="5、栈"></a>5、栈</h1><p>先入后出的有序序列（可以类比弹夹里面的子弹，先压进去的最后才打出来）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"prisma/errors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span>&#123;</span><br><span class="line">   MaxTop <span class="keyword">int</span> <span class="comment">//表示栈的最大可存放个数</span></span><br><span class="line">   Top       <span class="keyword">int</span><span class="comment">//表示栈顶，因为栈顶固定因此直接使用top</span></span><br><span class="line">   arr       [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在栈中添加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span><span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span><span class="params">(err error)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//先判断是否满</span></span><br><span class="line">   <span class="keyword">if</span> this.Top==this.MaxTop<span class="number">-1</span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"Stack full"</span>)</span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">"Stack full"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   this.Top++</span><br><span class="line">   this.arr[this.Top]=val</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span><span class="title">List</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   <span class="keyword">if</span> this.Top==<span class="number">-1</span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"Stack empty"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i:=this.Top;i&gt;=    <span class="number">0</span> ;i--  &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"arr[%d]=%d\n"</span>,i,this.arr[i])</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span><span class="title">Pop</span><span class="params">()</span><span class="params">(val <span class="keyword">int</span> ,err error)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> this.Top==<span class="number">-1</span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"Stack empty"</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>,errors.New(<span class="string">"Stack empty"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//先取值，再this.Top--</span></span><br><span class="line">   val=this.arr[this.Top]</span><br><span class="line">   this.Top--</span><br><span class="line">   <span class="keyword">return</span> val,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   stack:=&amp;Stack&#123;</span><br><span class="line">      MaxTop:<span class="number">5</span>,</span><br><span class="line">      Top:<span class="number">-1</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//入栈</span></span><br><span class="line">   stack.Push(<span class="number">1</span>)</span><br><span class="line">   stack.Push(<span class="number">2</span>)</span><br><span class="line">   stack.Push(<span class="number">3</span>)</span><br><span class="line">   stack.Push(<span class="number">4</span>)</span><br><span class="line">   stack.Push(<span class="number">5</span>)</span><br><span class="line">   <span class="comment">//显示</span></span><br><span class="line">   stack.List()</span><br><span class="line">   val,_:=stack.Pop()</span><br><span class="line">   fmt.Println(<span class="string">"出栈"</span>,val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、递归"><a href="#6、递归" class="headerlink" title="6、递归"></a>6、递归</h1><p>迷宫问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个函数，完成老鼠招录</span></span><br><span class="line"><span class="comment">//myMap *[8][7]int:地图，保证是同一个地图 ，使用引用</span></span><br><span class="line"><span class="comment">//i，j表示对地图的那个点进行测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetWay</span><span class="params">(myMap *[8][7]<span class="keyword">int</span>,i <span class="keyword">int</span>,j <span class="keyword">int</span>)</span><span class="title">bool</span></span>&#123;</span><br><span class="line">   <span class="comment">//分析什么情况下有出路</span></span><br><span class="line">   <span class="comment">//myMap[6][5]=2</span></span><br><span class="line">   <span class="keyword">if</span> myMap[<span class="number">6</span>][<span class="number">5</span>]==<span class="number">2</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//说明还有继续找</span></span><br><span class="line">      <span class="keyword">if</span> myMap[i][j]==<span class="number">0</span>&#123;<span class="comment">//说明这个点可以探测</span></span><br><span class="line">         <span class="comment">//假设这个点可以通，但是上下左右需要探测</span></span><br><span class="line">         myMap[i][j]=<span class="number">2</span></span><br><span class="line">         <span class="keyword">if</span> SetWay(myMap,i+<span class="number">1</span>,j)&#123;<span class="comment">//下</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span> SetWay(myMap,i,j+<span class="number">1</span>)&#123;<span class="comment">//向右</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span> SetWay(myMap,i<span class="number">-1</span>,j)&#123;<span class="comment">//向上</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span> SetWay(myMap,i,j<span class="number">-1</span>)&#123;<span class="comment">//向左</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;<span class="comment">//死路</span></span><br><span class="line">            myMap[i][j]=<span class="number">3</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span>  <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//先创建一个二维数组，模拟迷宫地图</span></span><br><span class="line">   <span class="comment">//1、如果元素值为1表示墙</span></span><br><span class="line">   <span class="comment">//2、值为0表示没有走过的点</span></span><br><span class="line">   <span class="comment">//3、 2表示通路</span></span><br><span class="line">   <span class="comment">//4、 3表示走过但是不通</span></span><br><span class="line">   <span class="keyword">var</span> myMap [<span class="number">8</span>][<span class="number">7</span>]<span class="keyword">int</span></span><br><span class="line">   <span class="comment">//先把地图最上和最下设置味1</span></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">7</span>;i++  &#123;</span><br><span class="line">      myMap[<span class="number">0</span>][i]=<span class="number">1</span></span><br><span class="line">      myMap[<span class="number">7</span>][i]=<span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//先把地图最左和最右设置味1</span></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">8</span> ;i++  &#123;</span><br><span class="line">      myMap[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">      myMap[i][<span class="number">6</span>]=<span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   myMap[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">   myMap[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//输出地图</span></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">8</span> ;i++  &#123;</span><br><span class="line">      <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="number">7</span> ;j++  &#123;</span><br><span class="line">         fmt.Print(myMap[i][j],<span class="string">" "</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用测试</span></span><br><span class="line">   SetWay(&amp;myMap,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">   fmt.Println(<span class="string">"探测完毕。。。。。。。。。。。"</span>)</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">8</span> ;i++  &#123;</span><br><span class="line">      <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="number">7</span> ;j++  &#123;</span><br><span class="line">         fmt.Print(myMap[i][j],<span class="string">" "</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7、哈希（散列）"><a href="#7、哈希（散列）" class="headerlink" title="7、哈希（散列）"></a>7、哈希（散列）</h1><p>Hash算法可以将一个数据转换为一个标志，这个标志和源数据的每一个字节都有十分紧密的关系。Hash算法还具有一个特点，就是很难找到逆向规律。</p><p>Hash算法是一个广义的算法，也可以认为是一种思想，使用Hash算法可以提高存储空间的利用率，可以提高数据的查询效率，也可以做<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/212550" target="_blank" rel="noopener">数字签名</a>来保障数据传递的安全性。所以Hash算法被广泛地应用在互联网应用中。 [1] </p><p>Hash算法也被称为散列算法，Hash算法虽然被称为算法，但实际上它更像是一种思想。Hash算法没有一个固定的公式，只要符合散列思想的算法都可以被称为是Hash算法（可以理解为通过一个映射函数将数据以某种规律存储至数组（或其他））</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义emp</span></span><br><span class="line"><span class="keyword">type</span> Emp <span class="keyword">struct</span> &#123;</span><br><span class="line">   Id <span class="keyword">int</span></span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">   Next *Emp</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法待定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Emp)</span><span class="title">ShowMe</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">"链表%d，找到该雇员 %d \n"</span>,this.Id%<span class="number">7</span>,this.Id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义EmpLink</span></span><br><span class="line"><span class="comment">//不带表头，第一个节点就存放雇员</span></span><br><span class="line"><span class="keyword">type</span> EmpLink <span class="keyword">struct</span> &#123;</span><br><span class="line">   Head *Emp</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示当前链表的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *EmpLink)</span><span class="title">ShowLink</span><span class="params">(no <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> this.Head==<span class="literal">nil</span>&#123;</span><br><span class="line">      fmt.Printf(<span class="string">"链表%d 为空\n"</span>,no)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//遍历当前链表，并显示数据</span></span><br><span class="line">   cur:=this.Head</span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> cur!=<span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Printf(<span class="string">"链表%d 雇员id=%d 名字=%s -&gt;"</span>,no,cur.Id,cur.Name)</span><br><span class="line">         cur=cur.Next</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据id删除对应雇员</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *EmpLink)</span><span class="title">DeleteById</span><span class="params">(id <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> this.FindById(id)==<span class="literal">nil</span>&#123;</span><br><span class="line">      fmt.Printf(<span class="string">"id=%d的员工不存在，请检查是否输错\n"</span>,id)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   cur:=this.Head</span><br><span class="line">   <span class="comment">//helper:=this.Head</span></span><br><span class="line">   <span class="comment">//将</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> cur.Id==id&#123;</span><br><span class="line">         cur.Next=cur.Next.Next</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      cur=cur.Next</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据id查找对应的雇员，如果没有就返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *EmpLink)</span><span class="title">FindById</span><span class="params">(id <span class="keyword">int</span>)</span>*<span class="title">Emp</span></span>&#123;</span><br><span class="line">   cur :=this.Head</span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> cur!=<span class="literal">nil</span>&amp;&amp;cur.Id==id&#123;</span><br><span class="line">         <span class="keyword">return</span> cur</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> cur==<span class="literal">nil</span>&#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      cur=cur.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加员工的方法包主从小到大</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *EmpLink)</span><span class="title">Insert</span><span class="params">(emp *Emp)</span></span>  &#123;</span><br><span class="line">   cur :=this.Head</span><br><span class="line">   <span class="keyword">var</span> pre *Emp=<span class="literal">nil</span> <span class="comment">//辅助指针 pre在cur前面</span></span><br><span class="line">   <span class="comment">//判断是否为空</span></span><br><span class="line">   <span class="keyword">if</span> cur==<span class="literal">nil</span>&#123;</span><br><span class="line">      this.Head=emp</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//非空给emp找到对应位置插入</span></span><br><span class="line">   <span class="keyword">for</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> cur!=<span class="literal">nil</span>&#123;</span><br><span class="line">         <span class="comment">//比较</span></span><br><span class="line">         <span class="keyword">if</span> cur.Id&gt;=emp.Id&#123;</span><br><span class="line">            <span class="comment">//找到位置</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         pre=cur</span><br><span class="line">         cur=cur.Next</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   pre.Next=emp</span><br><span class="line">   emp.Next=cur</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义hashtable，含有一个链表数组</span></span><br><span class="line"><span class="keyword">type</span> HashTable <span class="keyword">struct</span> &#123;</span><br><span class="line">   LinkArr [<span class="number">7</span>]EmpLink</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//给HashTable编写Insert方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *HashTable)</span><span class="title">Insert</span><span class="params">(emp *Emp)</span></span>&#123;</span><br><span class="line">   <span class="comment">//使用散列函数，确定将该雇员添加到哪个散列</span></span><br><span class="line">   linkNo:=this.HashFun(emp.Id)</span><br><span class="line">   <span class="comment">//使用对应的链表添加</span></span><br><span class="line">   this.LinkArr[linkNo].Insert(emp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写方法显示hashtable所有雇员</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *HashTable)</span><span class="title">ShowAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt; <span class="built_in">len</span>(this.LinkArr);i++&#123;</span><br><span class="line">      this.LinkArr[i].ShowLink(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个散列方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *HashTable)</span><span class="title">HashFun</span><span class="params">(id <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> id%<span class="number">7</span><span class="comment">//得到对应链表的下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个方法完成查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *HashTable)</span><span class="title">FindById</span><span class="params">(id <span class="keyword">int</span>)</span>*<span class="title">Emp</span></span>&#123;</span><br><span class="line">   linkNo:=this.HashFun(id)</span><br><span class="line">   <span class="keyword">return</span> this.LinkArr[linkNo].FindById(id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个方法完成删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *HashTable)</span><span class="title">DeleteById</span><span class="params">(id <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   linkNo:=this.HashFun(id)</span><br><span class="line">   this.LinkArr[linkNo].DeleteById(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   key:=<span class="string">""</span></span><br><span class="line">   id:=<span class="number">0</span></span><br><span class="line">   name:=<span class="string">""</span></span><br><span class="line">   <span class="keyword">var</span> hashtable HashTable</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"==========================雇员系统菜单================================"</span>)</span><br><span class="line">      fmt.Println(<span class="string">"input表示添加雇员"</span>)</span><br><span class="line">      fmt.Println(<span class="string">"show表示显示雇员"</span>)</span><br><span class="line">      fmt.Println(<span class="string">"delete表示查找雇员"</span>)</span><br><span class="line">      fmt.Println(<span class="string">"find表示查找雇员"</span>)</span><br><span class="line">      fmt.Println(<span class="string">"exit表示退出"</span>)</span><br><span class="line">      fmt.Println(<span class="string">"请输入选择"</span>)</span><br><span class="line">      fmt.Scanln(&amp;key)</span><br><span class="line">      <span class="keyword">switch</span> key &#123;</span><br><span class="line">      <span class="keyword">case</span><span class="string">"input"</span>:</span><br><span class="line">         fmt.Println(<span class="string">"输入雇员id"</span>)</span><br><span class="line">         fmt.Scanln(&amp;id)</span><br><span class="line">         fmt.Println(<span class="string">"输入雇员name"</span>)</span><br><span class="line">         fmt.Scanln(&amp;name)</span><br><span class="line">         emp:=&amp;Emp&#123;</span><br><span class="line">            Id:id,</span><br><span class="line">            Name:name,</span><br><span class="line">         &#125;</span><br><span class="line">         hashtable.Insert(emp)</span><br><span class="line">      <span class="keyword">case</span><span class="string">"show"</span> :</span><br><span class="line">         hashtable.ShowAll()</span><br><span class="line">      <span class="keyword">case</span><span class="string">"find"</span>:</span><br><span class="line">         fmt.Println(<span class="string">"输入雇员id"</span>)</span><br><span class="line">         fmt.Scanln(&amp;id)</span><br><span class="line">         emp:=hashtable.FindById(id)</span><br><span class="line">         <span class="keyword">if</span> emp==<span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"id=%d 的雇员不存在\n"</span>,id)</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            emp.ShowMe()</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"delete"</span>:</span><br><span class="line">         fmt.Println(<span class="string">"输入雇员id"</span>)</span><br><span class="line">         fmt.Scanln(&amp;id)</span><br><span class="line">         hashtable.DeleteById(id)</span><br><span class="line">      <span class="keyword">case</span><span class="string">"exit"</span>:</span><br><span class="line">         os.Exit(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">"输入错误"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8、二叉树"><a href="#8、二叉树" class="headerlink" title="8、二叉树"></a>8、二叉树</h1><p>二叉树的前序，中序，后序遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="keyword">type</span> Hero <span class="keyword">struct</span> &#123;</span><br><span class="line">   No <span class="keyword">int</span></span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">   Left *Hero</span><br><span class="line">   Right *Hero</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历【先输出root节点，其次是左子树，最后是又子树】</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreOder</span><span class="params">(node *    Hero)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> node!=<span class="literal">nil</span>&#123;</span><br><span class="line">      fmt.Printf(<span class="string">"no=%d name=%s\n"</span>,node.No,node.Name)</span><br><span class="line">      PreOder(node.Left)</span><br><span class="line">      PreOder(node.Right)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历【先输出root的左子树，然后是root最后是root的右子树】</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InfixOrder</span><span class="params">(node *Hero)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> node!=<span class="literal">nil</span>&#123;</span><br><span class="line">      InfixOrder(node.Left)</span><br><span class="line">      fmt.Printf(<span class="string">"no=%d name=%s\n"</span>,node.No,node.Name)</span><br><span class="line">      InfixOrder(node.Right)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostOder</span><span class="params">(node *Hero)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> node!=<span class="literal">nil</span>&#123;</span><br><span class="line">      PostOder(node.Left)</span><br><span class="line">      PostOder(node.Right)</span><br><span class="line">      fmt.Printf(<span class="string">"no=%d name=%s\n"</span>,node.No,node.Name)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   root:=&amp;Hero&#123;</span><br><span class="line">      No:<span class="number">1</span>,</span><br><span class="line">      Name:<span class="string">"迪迦"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   left1:=&amp;Hero&#123;</span><br><span class="line">      No:<span class="number">2</span>,</span><br><span class="line">      Name:<span class="string">"大古"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   node10:=&amp;Hero&#123;</span><br><span class="line">      No:<span class="number">10</span>,</span><br><span class="line">      Name:<span class="string">"tom"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   node12:=&amp;Hero&#123;</span><br><span class="line">      No:<span class="number">12</span>,</span><br><span class="line">      Name:<span class="string">"jack"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   left1.Left=node10</span><br><span class="line">   left1.Right=node12</span><br><span class="line">   right1:=&amp;Hero&#123;</span><br><span class="line">      No:<span class="number">3</span>,</span><br><span class="line">      Name:<span class="string">"泰罗"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   root.Left=left1</span><br><span class="line">   root.Right=right1</span><br><span class="line">   right2:=&amp;Hero&#123;</span><br><span class="line">      No:<span class="number">4</span>,</span><br><span class="line">      Name:<span class="string">"雷欧"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   right1.Right=right2</span><br><span class="line">   <span class="comment">//PreOder(root)</span></span><br><span class="line">   InfixOrder(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、稀疏数组sparsearry&quot;&gt;&lt;a href=&quot;#1、稀疏数组sparsearry&quot; class=&quot;headerlink&quot; title=&quot;1、稀疏数组sparsearry&quot;&gt;&lt;/a&gt;1、稀疏数组sparsearry&lt;/h1&gt;&lt;p&gt;当一个数组中大部分元素为0，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux基本命令</title>
    <link href="http://yoursite.com/2020/06/22/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/06/22/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2020-06-22T10:51:53.000Z</published>
    <updated>2020-11-19T12:27:11.175Z</updated>
    
    <content type="html"><![CDATA[<p>1、显示日期与时间的命令：date<br>2、显示日历的命令：cal<br>3、简单好用的计算器：bc<br>4、热键“命令补全或文件补齐”：Tab<br>5、热键“中断目前程序”：Ctrl+C<br>6、热键“键盘输入结束（End of File）相当与输入exit”：Ctrl+D<br>7、在线求助：man 【command】或 info 【command】，按q退出<br>8、数据同步写入磁盘：sync<br>9、关机命令：shutdown -h 【now | 10(分钟) | 20：25】<br>10、重启命令：reboot<br>11、改变文件所属用户组：chgrp<br>12、改变文件所有者：chown [-R]  ‘groupname’ ‘dirname/filename’<br>     chgrp -R usergroup /home/yang/a.txt<br>13、改变文件的属性：chmod<br>       chmod [-R] 帐号名称 文件或目录<br>       chmod [-R] 帐号名称：组名 文件或目录<br>   chmod yangyuqin:root /home/hadoop/bb.txt<br>14、改变权限：chmod<br>        chmod [-R] xyz 文件或目录<br>        u,g,o表示user,group,other这3种身份的权限，a表示all，即全部的身份。+加入，-除去，=设置。r读，w写，x执行，4读，2写，1执行。<br>   chmod 777 /home/hadoop/a.txt<br>   chmod u+rwx,g+rx,o+r /home/hadoop/a.txt<br>15、目录<br>1）.    代表此层目录<br>2）..   代表上一层目录<br>3）-    代表前一个工作目录<br>4）～  代表“目前用户身份”所在的主文件夹<br>5）～account 代表account这个用户的主文件夹（account是个帐号名称）<br>16、切换目录：cd<br>      cd 【相对路径或绝对路径】<br>17、显示目前所在的目录：pwd<br>       pwd [-P]<br>      -P 如果是连接文件，会不以连接文件的数据显示，而是显示正确的完整路径，即获取连接文件的真正路径。<br>18、新建新目录：mkdir<br>      mkdir [-mp]  目录名称<br>      -m ： 配置文件的权限，mkdir -m 711 test1；<br>      -p  ： 帮助你直接将所需要的目录（包含上层目录）递归创建起来，如果没有这个参数，只能一层一层建立目录,mkdir -p /home/a/b/c/d.<br>19、删除“空”的目录：rmdir<br>       rmdir [-p] 目录名称<br>20、查看文件与目录：ls<br>        ls [-aAdfFhilnrRSt] 目录名称<br>        ls [–color={never,auto,always}] 目录名称<br>        ls [–full-time] 目录名称<br>    -a：全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）<br>    -d：仅列出目录本身，而不是列出目录内的文件数据（常用）<br>    -f：直接列出结果，而不进行排序(ls默认会以文件名排序)</p><p>​    -F：根据文件、目录等信息给予附加数据结构，例如：*：代表可执行文件，/：代表目录，=：代表socket文件，|：代表FIFO文件</p><p>​    -h：将文件容量以人类较易读的方式(例如GB，KB等)列出来</p><p>​    -l：列出长数据串，包含文件的属性与权限等数据（常用）</p><p>​    -r：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小</p><p>​    -R：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来</p><p>​    -S：以文件容量大小排序，而不是用文件名排序</p><p>​    -t：依时间排序，而不是用文件名</p><p>​    –color=never：不要依据文件特性给予颜色显示</p><p>​    –color=always：显示颜色</p><p>​    –color=auto：让系统自行依据设置来判断是否给予颜色</p><p>​    –full-time：以完整时间模式（包含年、月、日、时、分）输出</p><p>​    –time={atime，ctime}：输出访问时间或改变权限属性时间（ctime），而非内容更改时间（modification time）  </p><p>21、复制文件或目录：cp</p><p>​    cp [-adfilprsu] 源文件(source) 目标文件(destination)</p><p>​    cp [option] source1,source2,source3, … directory</p><p>​    -a：相当于-pdr 的意思</p><p>​    -d：若源文件为连接文件的属性(link file)，则复制连接文件属性而非文件本身</p><p>​    -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)</p><p>​    -r：递归持续复制，用于目录的复制行为(常用)</p><p>​    -i：若目标文件(destination)已经存在时，  在覆盖时会先询问操作的进行(常用)</p><p>​    -l：进行硬链接（hard link）的连接文件创建，而非复制文件本身</p><p>​    -s：复制成为符号链接文件(symbolic link)，即“快捷方式”文件</p><p>​    -u：若destination 比source旧才更新destination<br>    注意：如果源文件有两个以上，则最后一个目的文件一定要是“目录”才行</p><p>22、移除文件或目录：rm</p><p>​    rm [-fir] 文件或目录</p><p>​    -f：就是force的意思，忽略不存在的文件，不会出现警告信息</p><p>​    -i：互动模式，在删除前会询问用户是否操作</p><p>​    -r：递归删除。最常用在目录的删除。但是很危险！！！</p><p>23、移动文件或目录，或更名：mv</p><p>​    mv [-fiu] source destination</p><p>​    mv [options] source1,source2,source3,…..,directory</p><p>​    </p><p>24、直接查看文件内容：cat（concatenate）</p><p>​    cat [-AbEnTv]</p><p>​    -A：相当于-vET的整合参数，可列出一些特殊字符，而不是空白而已</p><p>​    -n：打印出行号，连同空白行也会有行号，与-b的参数不同</p><p>​    -b：列出行号，仅针对非空白行做行号显示，空白行不标行号</p><p>​    -E：将结尾的断行字符$显示出来</p><p>​    -T：将[Tab]按键以^I显示出来</p><p>​    -v：列出一些看不出来的特殊字符</p><p>25：反向列示：tac</p><p>​    </p><p>26、添加行号打印：nl</p><p>27、可翻页查看(只向后)：more，按q停止</p><p>28、可翻页查看(可向前或向后)：less，按q停止</p><p>29、取出前面几行：head</p><p>​    head [-n number] 文件</p><p>​    head -n 20 /home/test</p><p>​    head -n -100 /home/test           //不打印后面100行的数据，只是显示前面的数据</p><p>30、取出后面几行：tail</p><p>​    tail [-n number] 文件</p><p>​    tail -n 20 /home/test</p><p>​    tail -n +100 /home/test          //只是列出100行以后的数据 </p><p>31、文件时间：</p><p>​    1）modification time(mtime)：当该文件的“内容数据”更改时，就会更新这个时间。内容数据指的是文件的内容，而不是文件的属性或权限。</p><p>​    2）status time(ctime)：当该文件的“状态”(status)改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间。</p><p>​    3）access time(atime)：当“该文件的内容被取用”时，就会更新这个读取时间(access)。举例来说，我们使用cat去读取文件的时候，就会更新该文件的atime。</p><p>32、修改文件时间或创建新文件：touch</p><p>33、查看文件类型：file</p><p>34、寻找“执行文件”：which</p><p>​    which [-a] command</p><p>​    -a：将所有由PATH目录中可以找到的命令均列出，而不只第一个被找到的命令名称</p><p>​    which ipconfig</p><p>​    which hadoop</p><p>35、从whereis数据库文件中寻找特定的文件：whereis</p><p>​    whereis [-bmsu] 文件或目录</p><p>​    -b：只找二进制格式的文件</p><p>​    -m：只找在说明文件manual路径下的文件</p><p>​    -s：只找source源文件</p><p>​    -u：查找不在上述三个选项当中的其他特殊文件</p><p>​    whereis ifconfig</p><p>36、从以创建的数据库/var/lib/mlocate/数据库中寻找特定的文件：locate<br>    locate [-ir] keyword<br>    -i：忽略大小写的差异<br>    -r：后面可接正则表达式的显示方式<br>    locate passwd       //从系统中找出与passwd相关的文件名</p><p>​    </p><p>37、从文件系统寻找特定的文件：find<br>    find [PATH] [option] [action]<br>    参数：<br>    1）与时间有关的参数：共有-atime、-ctime、-mtime，以-mtime说明<br>            -mtime n：n为数字，意义为n天之前的“1天之内”被更改过的文件<br>            -mtime +n：列出在n天之前（不含n天本身）被更改过的文件名<br>            -mtime -n：列出在n天之内（含n天本身）被更改过的文件名<br>            -newer file：file为一个存在的文件，列出比file还要新的文件名<br>        find / -mtime 0        //将过去系统上24小时内有改动(mtime)的文件列出，数字0代表目前的时间，所以是从现在开始到24小时前<br>        find / -mtime 3        //列出3天前的24小时内有改动的文件<br>        find /etc -newer /etc/passwd     //寻租/etc目录下的文件，如果文件日期比/etc/passwd新的就列出来，可用于分辨两个文件之间的新旧关系<br>    2）与用户或用户组名有关的参数：<br>            -uid n：n为数字，这个数字是用户的帐号ID，即UID ，这个UID 是记录在/etc/passwd里面与帐号名称对应的数字<br>            -gid n：n为数字，这个数字是用户组名的ID，即GID，这个GID 记录在/etc/group中<br>            -user name：name为用户帐号名称，例如dmtsai<br>            -group name：name为用户组名，例如users<br>            -nouser：寻找文件的所有者不存在/etc/passwd的人<br>            -nogroup：寻找文件的所有用户组不存在与/etc/group的人<br>        find /home -user vbird      //查找/home下面属于bird用户的文件，可将属于某个用户的所有文件都找出来<br>        find / -nouser                        //查找系统中不属于任何人的文件<br>    3）与文件权限及名称有关的参数：<br>            -name filename：查找文件名为filename的文件<br>            -size [+-]SIZE：查找比SIZE 还要大(+)或小(-)的文件。这个SIZE的规格有：c：代表byte，k：代表1024bytes。所以，要找比50KB还要大的文件，就是“-size +50k”<br>            -type TYPE：查找文件的类型为TYPE的，类型主要有：一般正规文件(f)、设备文件(b，c)、目录(d)、连接文件(l)、socket(s)及FIFO(p)等属性<br>            -perm mode：查找文件权限”刚好等于”mode的文件，这个mode为类似chmod的属性值，举例来说，-rwxr-xr-x的属性为0755<br>            -perm -mode：查找文件权限“必须要全部包含mode的权限”的文件，举例来说，我们要查找-rwxr–r–，即0744的文件，使用-perm -0744，当一个文件的权限为-rwxr-xr-x，即755时，也会被列出来，因为-rwxr-xr-x的属性已经包括了-rwxr–r–的属性 了<br>            -perm +mode：查找文件权限“包含任一mode的权限”的我文件，举例来说，我们查找-rwxr-xr-x，即-perm +0755，但一个文件是-rw——-也会被列出来，因为它有-rw……的属性存在<br>        find / -name passwd     //找出文件名为passwd的这个文件<br>        find /var -type s              //找出/var目录下文件类型为socket的文件名<br>        find / -perm +0755       //查找文件当中含有-rwxr-xr-x中的任一属性<br>    4）其他可进行的操作：<br>            -exec command：command为其他命令，-exec后面可再接其他的命令来处理查找到的结果<br>            -print：将结果打印到屏幕上，这个操作是默认值<br>        find /etc -name passwd -exec cat {} ;         //将找到文件名为passwd的文件作为命令的输入<br>38、列出文件系统的整体磁盘使用量：df<br>        df [-ahikHTm]   [目录或文件名]<br>        -a：列出所有的文件系统，包括系统特有的/proc等文件系统；<br>        -k：以KB的容量显示各文件系统<br>        -m：以MB的容量显示各文件系统<br>        -h：以人们较易阅读的GB、MB、KB等格式自行显示<br>        -H：以M=1000K 替代M=1024K 的进位方式<br>        -T：连同该分区的文件系统名称(例如ext3)也列出<br>        -i：不用硬盘容量，而已inode的数量来显示<br>    df      //将系统内所有的文件系统列出来，在Linux下如果df没有加任何参数，那么默认会将系统内所有的(不含特殊内存内的文件系统与swap)都以1KB的容量列出来。<br>    df -h    //将容量结果以易读的容量格式显示出来<br>    df -aT    //将系统内所有的特殊文件格式及名称都列出来<br>    df -h /etc        //将/etc下面的可用的磁盘容量以易读的容量格式显示，这样就可以知道某个目录下还有多少容量可以使用了<br>    df -ih             //将目前各个分区当中可用的inode数量列出来<br>39、评估文件系统的磁盘使用量（常用于评估目录所占容量）：du<br>        du [-ahskm] 文件或目录名称<br>        -a：列出所有的文件与目录容量，因为默认仅统计目录下面的文件量而已<br>        -h：以人们较易读的容量格式(G/M)显示<br>        -s：列出容量而已，而不列出每个各别的目录占用容量<br>        -S：不包含子目录下的总计，与-s有点差别<br>        -k：以KB列出容量显示<br>        -m：以MB列出容量显示<br>    du        //列出当前目录下的所有文件容量，但仅会显示目录容量(不含文件)<br>    du -a    //除了显示目录容量，还会显示文件容量<br>    du  -sm  ./*     //检查当前目录下面每个目录所占用的容量，可检查某个目录下那个子目录占用最大的容量<br>40、连接文件：ln<br>1）硬连接或实际连接：hard link<br>        ln /etc/crotab .<br>2）符号连接，也即是快捷方式：symbolic link<br>        ln -s /etc/crotab1 crotab2<br>41、变量的显示：echo<br>    echo $PATH<br>    echo helloworld<br>42、查看环境变量与常见环境变量说明：env<br>43、查看所有变量（含环境变量与自定义变量）：set<br>44、查看历史命令：history<br>45、提示符的设置：PS1<br>46、显示结果的语系变量：locale<br>47、命令别名设置：alias<br>            alias lm=’ls -l | more’<br>48、管道命令：pipe<br>            ls -al /etc | less<br>49、将同一行里面的数据进行分解，取出想要的数据：cut<br>        cut -d’分隔字符’ -f fields     //用于分隔字符<br>        cut -c 字符范围                        //用于排列整齐的信息<br>        -d：后面接分隔字符，与-f一起使用<br>        -f：依据-d的分隔字符将一段信息切割成为数据，与-f取出第几段的意思<br>        -c：以字符(characters)的单位取出固定字符区间<br>        echo $PATH | cut -d ‘:’ -f 5            //将PATH变量取出，以:为分割符，取出第五个路径<br>        echo $PATH | cut -d ‘:’  -f 3,5        //将PATH变量取出，以:为分割符，取出第3到第5个路径<br>        export | cut -c 12-                //将export输出的信息取得第12字符以后的所有字符串，但是在处理多空格相连的数据时会比较复杂<br>50、分析一行信息，若匹配想找的数据则将该行取出来：grep<br>        grep [-acinv] [–color=auto] ‘查找字符串’ filename<br>        -a：将binary文件以text文件的方法查找数据<br>        -c：计算找到“查找字符串”的次数<br>        -i：忽略大小写的不同，所以大小写视为相同<br>        -n：顺便输出行号<br>        -v：顺便输出行号<br>        –color=auto：可以将找到的关键字部分加上颜色显示<br>        history | grep ‘ls’<br>51、排序命令：sort<br>        sort [-fbMnrtuk] [file or stdin]<br>        -f：忽略大小写的差异，例如A与a视为编码相同<br>        -b：忽略最前面的空格符部分<br>        -M：以月份的名字来排序，例如JAN,DEC等的排序方法<br>        -n：使用“纯数字”进行排序（默认是以文字类型来排序的）<br>        -r：反向排序<br>        -u：就是uniq，相同的数据中，仅出现一行代表<br>        -t：分隔符，默认是用[Tab]键来分隔<br>        -k：以那个区间（field）来进行排序的意思<br>        cat /etc/passwd | sort<br>        cat /etc/passwd | sort -t ‘:’ -k 3<br>52、排序完成但是将重复的数据仅列出一个显示：uniq<br>        uniq [-ic]<br>        -i：忽略大小写字符的不同<br>        -c：进行计数<br>        last | cut -d ‘ ‘ -f  1 | sort | uniq -c<br>53、统计文件的字、行、字符：wc<br>        wc [-lwm]<br>        -l：仅列出行<br>        -w：仅列出多少字（英文单字）<br>        -m：多少字符<br>        cat /etc/man.config | wc      //输出三个数字分别为行、字数、字符数<br>54、数据的替换、删除、新增、选取工具：sed<br>        sed [-nefr] [动作]<br>1）参数：<br>        -n：使用安静（silent）模式。在一般sed的用法中，所有来自STDIN的数据一般都会被列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的那一行（或者操作）才会被列出来<br>        -e：直接在命令模式上进行sed的动作编辑<br>        -f：直接将sed的动作写在一个文件内，-f filename则可以在filename内的sed动作<br>        -r：sed的动作支持的是扩展型正则表达式的语法（默认是基础正则表达式语法）<br>        -i：直接修改读取的文件内容，而不是由屏幕输出<br>2）动作说明：[n1  [,n2]] function<br>        n1,n2：不见得会存在，一般代表选择进行动作的行数，举例来说，如果我的动作是需要在10到20行之间进行的，则“10，20[动作行为]”<br>function常用的参数：<br>        a：新增，a的后面可以接字符串，而这些字符串会在新的一行出现(目前的下一行)<br>        c：整行替换，c的后面可以接字符串，这些字符串可以替换n1,n2之间的行<br>        d：删除，因为是删除，所以d后面通常不接任何参数<br>        i：插入，i的后面可以接字符串，而这些字符串会在新的一行出现（目前上一行）<br>        p：打印，也就是将某个选择的数据打印出来，通常p会与参数sed -n一起运行<br>        s：部分替换，可以直接进行替换的工作，通常这个s的动作可以搭配正则表达式！例如1,20s/old/new/g<br>3）以行为单位的新增/删除功能<br>        nl /etc/passwd | sed ‘2,5d’        //将/etc/passwd的内容列出并且打印行号，同时，将第2～5行删除<br>4）在第二行后面（即加在第3行）加上“drink tea？“字样<br>        nl /etc/passwd | sed ‘2a drink tea?’<br>5）在第二行前面（即加在第2行）插入“drink tea？“字样<br>        nl /etc/passwd | sed ‘2i drink tea?’<br>6）在第二行后面加入两行字，例如”Drink tea or “ 与”drink beer？”<br>        -&gt; nl /etc/passwd | sed ‘2a Drink tea or  \<br>        -&gt; dirnk beer? ‘<br>7）以行为单位的替换与显示功能<br>        nl /etc/passwd | sed ‘2,5c No 2-5 number’       //将第2-5行的内容替换成为“No 2-5 number”<br>8）仅打印部分数据<br>        nl /etc/passwd | sed -n ‘5,7p’     //-n表示只会打印处理后的数据，如果不加-n，那处理后的数据会打印两次<br>9）部分数据的查找并替换的功能<br>        sed ‘s/要被替换的字符串/新的字符串/g’<br>    hadoop@hadoop-ThinkPad:<del>$ /sbin/ifconfig eth0<br>    eth0    Link encap:Ethernet  HWaddr b8:88:e3:3c:89:f9<br>                  inet addr:10.130.26.21  Bcast:10.130.26.127  Mask:255.255.255.128<br>                  inet6 addr: fe80::ba88:e3ff:fe3c:89f9/64 Scope:Link<br>                  UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br>                  RX packets:143999 errors:0 dropped:1 overruns:0 frame:0<br>                  TX packets:88285 errors:0 dropped:0 overruns:0 carrier:0<br>                  collisions:0 txqueuelen:1000<br>                  RX bytes:39104286 (39.1 MB)  TX bytes:39602666 (39.6 MB)<br>        sbin/ifconfig eth0 | grep ‘inet addr’ | sed ‘s/^.<em>addr://g’ | sed ‘s/Bcast.</em>$//g’            //从ifconfig文件中抽取出本机的ip地址<br>        cat /etc/man.config | grep ‘MAN’ | sed ‘s/#.*$//g’ | sed ‘/^$/d’<br>55、数据处理工具：awk<br>        sed常常作用于一整行的处理，awk则比较倾向于将一行分成数个“字段”来处理，awk相当适合处理小型的数据处理。<br>        awk ‘条件类型1{动作1}  条件类型2{动作2} … ‘  filename<br>        awk 主要是处理每一行的字段内的数据，而默认的字段的分隔符为空格键或[tab]键<br>        awk的处理流程是：<br>            1）读入第一行，并将第一行的数据填入$0,$1,$3等变量当中，$0代表一整行数据<br>            2）依据条件类型的限制，判断是否需要进行后面的动作<br>            3）做完所有的动作与条件类型<br>            4）所还有后续的“行”的数据，则重复上面1～3的步骤，直到所有的数据都读完为止<br>        awk的内置变量：<br>                NF  ：    每一行（$0）拥有的字段总数<br>                NR  ：   目前awk所处理的是“第几行”数据<br>                FS    ：   目前的分隔字符，默认是空格键<br>        awk运算符：<br>                &gt;：大于      &lt;：小于       &gt;=：大于或等于      &lt;=：小于或等于      ==：等于     ！=：不等于<br>        last -n 5 | awk ‘{print $1 “\t” $3}’      //打印第一列和第3列<br>        last -n 5 | awk ‘{print $1 “\t lines: “ NR “\t columes:” NF}’        //打印第一列，第几行，每一行的列数<br>        cat /etc/passwd | awk  ‘{FS=”:”}  $3 &lt; 10  {print  $1  “\t”  $3}’       //分隔为:，打印第三列小于10以下的数据，并且仅列出帐号与第三列<br>        新建一个文件：pay.txt<br>                    Name    1st     2nd     3th<br>                    VBird   23000   24000   25000<br>                    DMTsai  21000   20000   23000<br>                    Bird2   43000   42000   41000<br>        第一行只是说明，所以第一行不要进行加总（NR==1时处理）<br>        第二行以后就会有加总的情况出现（NR》=2以后处理）<br>       hadoop@hadoop-ThinkPad:</del>$ cat pay.txt | awk ‘NR==1{printf “%10s %10s %10s %10s %10s\n”,$1,$2,$3,$4,”Total”}<br>                                                                         NR&gt;=2{total=$2+$3+$4<br>                                                                           printf “%10s %10d %10d %10d %10.2f\n”,$1,$2,$3,$4,total}’<br>                          Name        1st        2nd        3th      Total<br>                          VBird      23000      24000      25000   72000.00<br>                          DMTsai      21000      20000      23000   64000.00<br>                          Bird2      43000      42000      41000  126000.00<br>56、文件比较工具：diff<br>        diff [-bBi] from-filr to-file<br>57、新增用户：useradd<br>        useradd [-u UID] [-g 初始化用户组] [-G 次要用户组] [-mM] [-c 说明栏] [-d 主文件夹绝对路径] [-s shell] 用户帐号名<br>        useradd vbird1<br>        useradd -u 123 -g users vbird2<br>58、设置密码：passwd<br>        passwd 123456<br>59、删除用户：userdel<br>        userdel vbird1<br>60、新增用户组：groupadd<br>        groupadd [-g gid] [-r] 用户组名<br>61、删除用户组：groupdel<br>        groupdel [groupname]<br>62、切换身份：su<br>        su [-lm] [-c 命令] [username]<br>        - ：单纯使用 - 如“su - ”，代表使用login-shell的变量文件读取方式来登录系统，若用户名称没有加上去，则代表切换为root身份<br>        -l：与 - 类似，但后面需要加欲切换的用户帐号，也是login-shell的方式<br>        -m：-m与-p是一样的，表示使用目前的环境设置，而不读取新用户的配置文件<br>        -c：仅进行一次命令<br>63、切换到root身份：sudo<br>64、查看当前用户的id：id<br>65、查看目前登录在系统上的用户：who或w<br>66、每个帐号的最近登录时间：lastlog<br>67、直接将命令丢到后台中“执行”：&amp;<br>        tar -zvf /tmp/etc.tar.gz /etc &amp;<br>68、将目前的工作丢到后台中“暂停‘：Ctrl+z<br>69、查看目前的后台工作状态：jobs<br>        jobs [-lrs]<br>        -l：除了列出job number与命令串之外，同时列出PID的号码<br>        -r：仅列出正在后台run的工作<br>        -s：仅列出正在后台当中暂停（stop）的工作<br>70、管理后台当中的工作：kill<br>        kill -signal %jobnumber<br>        kill -l      //-l列出目前kill能够使用的信号(signal)有哪些，signal代表给予后面接的那个工作什么样的指示。<br>        -1：重新读取一次参数的配置文件（reload）<br>        -2：代表与由键盘输入[ctrl]-c同样的操作；<br>        -9：立即强制删除一个工作<br>        -15：以正常的程序方式终止一项工作，与-9不同<br>        kill -9 %2; jobs<br>71、查看某个时间点的进行状况：ps<br>        ps aux        //查看系统所有的进程数据<br>        ps -lA         //也是能够查看所有系统的数据<br>        ps axjf        //连同部分进行树状态<br>        -A：所有的进程均显示出来，与-e具有相同的作用<br>        -a：不与termial有关的所有进程<br>        -u：有效用户相关的进程<br>        x：通常与a这个参数一起使用，可列出较完整的信息<br>        输出格式：<br>        l：较长、较详细地将该PID的信息列出<br>        j：工作的格式（jobs format）<br>        -f：做一个更为完整的输出<br>    1）仅查看自己的bash相关进程：ps -l<br>    2）查看系统所有进程：ps aux<br>                                                      ps aux | grep ‘syslog’<br>72、查看内存使用情况：free<br>        free [-b|-k|-m|-g] [-t]<br>        -b：直接输入free时，显示的是KB ，我们可以使用b（bytes）、m（MB），k（KB）及g（GB）来显示单位<br>        -t：在输出的最终结果中显示物理内存与swap的总量<br>73、查看系统与内核相关信息：uname<br>        uname [-asrmpi]<br>        -a：所有系统相关的信息<br>74、查看系统启动时间与工作负载：uptime<br>75、跟踪网络：netstat<br>76、查看网卡信息：ifconfig<br>        ifconfig eth0 192.168.0.1 netmask 255.255.255.0    //配置网卡ip地址<br>77、远程登录linux主机：ssh<br>        ssh [-l login_name] [-p port] [user@]hostname<br>        ssh 192.168.0.11<br>        ssh -l root 192.168.0.11  或  ssh <a href="mailto:root@192.168.0.11">root@192.168.0.11</a>        //指定用户<br>        ssh -l root -p 12333 216.230.230.114<br>78、远程拷贝：scp<br>        scp -r /home/administrator/test/  <a href="mailto:root@192.168.1.100">root@192.168.1.100</a>:/root/           //拷贝本机/home/administrator/test整个目录至远程主机192.168.1.100的/root目录下<br>        scp  /home/administrator/Desktop/old/driver/test/test.txt <a href="mailto:root@192.168.1.100">root@192.168.1.100</a>:/root/       //拷贝单个文件至远程主机<br>        scp -r <a href="mailto:root@192.168.62.10">root@192.168.62.10</a>:/root/  /home/administrator/Desktop/new/                                        //远程文件/文件夹下载<br>79、查看服务：service<br>        service –status-all</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、显示日期与时间的命令：date&lt;br&gt;2、显示日历的命令：cal&lt;br&gt;3、简单好用的计算器：bc&lt;br&gt;4、热键“命令补全或文件补齐”：Tab&lt;br&gt;5、热键“中断目前程序”：Ctrl+C&lt;br&gt;6、热键“键盘输入结束（End of File）相当与输入exit”：C
      
    
    </summary>
    
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>vue</title>
    <link href="http://yoursite.com/2020/03/03/vue/"/>
    <id>http://yoursite.com/2020/03/03/vue/</id>
    <published>2020-03-03T13:49:20.000Z</published>
    <updated>2020-03-03T13:58:54.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、vue基本v-指令vue-js"><a href="#一、vue基本v-指令vue-js" class="headerlink" title="一、vue基本v-指令vue.js"></a>一、vue基本v-指令vue.js</h1><h2 id="1、el挂载点"><a href="#1、el挂载点" class="headerlink" title="1、el挂载点"></a>1、el挂载点</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>el:挂载点<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">"body"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span> &#123;&#123; message &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// el:"#app",</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">// el:".app",</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">// el:"div",</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">//el后面接的是#加上需要绑定的标签id</span></span></span><br><span class="line"><span class="actionscript">      el:<span class="string">"#body"</span>,</span></span><br><span class="line">      data:&#123;</span><br><span class="line"><span class="actionscript">        message:<span class="string">"黑马程序员"</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、数据对象"><a href="#2、数据对象" class="headerlink" title="2、数据对象"></a>2、数据对象</h2><p><strong>和 v-text 可能有点重复，但是这条是为了明晰怎样在各种数据类型中取值</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>data:数据对象<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123; message &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span> &#123;&#123; school.name &#125;&#125; &#123;&#123; school.mobile &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; campus[0] &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; campus[3] &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="actionscript">                message:<span class="string">"你好 小黑!"</span>,</span></span><br><span class="line">                school:&#123;</span><br><span class="line"><span class="actionscript">                    name:<span class="string">"哈哈哈嘿嘿嘿"</span>,</span></span><br><span class="line"><span class="actionscript">                    mobile:<span class="string">"00110011"</span></span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="actionscript">                campus:[<span class="string">"北京校区"</span>,<span class="string">"上海校区"</span>,<span class="string">"广州校区"</span>,<span class="string">"深圳校区"</span>]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、v-text"><a href="#3、v-text" class="headerlink" title="3、v-text"></a>3、v-text</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-text指令<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- &#123;&#123;变量名&#125;&#125;两个大括号下面的三种方式都可以 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">"message+'!'"</span>&gt;</span>河北<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">"info+'!'"</span>&gt;</span>河北<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message +'!'&#125;&#125;河北<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="actionscript">                message:<span class="string">"哈哈哈!!!"</span>,</span></span><br><span class="line"><span class="actionscript">                info:<span class="string">"嘿嘿嘿"</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4、v-show"><a href="#4、v-show" class="headerlink" title="4、v-show"></a>4、v-show</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-show指令<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @click绑定事务，点击之后的操作--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换显示状态"</span> @<span class="attr">click</span>=<span class="string">"changeIsShow"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"累加年龄"</span> @<span class="attr">click</span>=<span class="string">"addAge"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-show 可以处理简单的逻辑，当逻辑不符合时只是将标签隐藏，注意和v-if的区别，v-if是将标签剔除，更加消耗性能--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span> <span class="attr">src</span>=<span class="string">"./img/monkey.gif"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-show</span>=<span class="string">"age&gt;=18"</span> <span class="attr">src</span>=<span class="string">"./img/monkey.gif"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">          isShow:<span class="literal">false</span>,</span></span><br><span class="line">          age:17</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">          changeIsShow:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.isShow = !<span class="keyword">this</span>.isShow;</span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          addAge:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.age++;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5、v-if"><a href="#5、v-if" class="headerlink" title="5、v-if"></a>5、v-if</h2><p>可以和v-show联合记忆</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-if指令<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换显示"</span> @<span class="attr">click</span>=<span class="string">"toggleIsShow"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>&gt;</span>嘿嘿嘿 - v-show修饰<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">"temperature&gt;=35"</span>&gt;</span>热死啦<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="actionscript">                isShow:<span class="literal">false</span>,</span></span><br><span class="line">                temperature:20</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="actionscript">                toggleIsShow:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.isShow = !<span class="keyword">this</span>.isShow;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6、v-model"><a href="#6、v-model" class="headerlink" title="6、v-model"></a>6、v-model</h2><p><strong>双向数据绑定</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-model指令<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"修改message"</span> @<span class="attr">click</span>=<span class="string">"setM"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--在这里改变的数据也会在script标签里面改变--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span> @<span class="attr">keyup.enter</span>=<span class="string">"getM"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="actionscript">                message:<span class="string">"哈哈哈"</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="actionscript">                getM:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                    alert(<span class="keyword">this</span>.message);</span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="actionscript">                setM:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.message =<span class="string">"酷丁鱼"</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7、v-for"><a href="#7、v-for" class="headerlink" title="7、v-for"></a>7、v-for</h2><p><strong>很简单，类似后台语言的for循环</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-for指令<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"添加数据"</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"移除数据"</span> @<span class="attr">click</span>=<span class="string">"remove"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--ul是无序标签，ol是有序标签--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(it,index) in arr"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--li标签自动换行--&gt;</span></span><br><span class="line">                &#123;&#123; index+1 &#125;&#125;黑马程序员校区:&#123;&#123; it &#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-for</span>=<span class="string">"item in vegetables"</span> <span class="attr">v-bind:title</span>=<span class="string">"item.name"</span>&gt;</span></span><br><span class="line">            &#123;&#123; item.name &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="actionscript">                arr:[<span class="string">"北京"</span>,<span class="string">"上海"</span>,<span class="string">"广州"</span>,<span class="string">"深圳"</span>],</span></span><br><span class="line">                vegetables:[</span><br><span class="line"><span class="actionscript">                    &#123;name:<span class="string">"西兰花炒蛋"</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                    &#123;name:<span class="string">"蛋炒西蓝花"</span>&#125;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="actionscript">                add:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.vegetables.push(&#123; name:<span class="string">"花菜炒蛋"</span> &#125;);</span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="actionscript">                <span class="comment">//移除最左侧的值</span></span></span><br><span class="line"><span class="actionscript">                remove:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.vegetables.shift();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="8、v-bind"><a href="#8、v-bind" class="headerlink" title="8、v-bind"></a>8、v-bind</h2><p><strong>设置元素的属性</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-bind指令<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.active</span>&#123;</span></span><br><span class="line">            border: 1px solid red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"imgSrc"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"imgSrc"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">:title</span>=<span class="string">"imgTitle+'!!!'"</span> <span class="attr">:class</span>=<span class="string">"isActive?'active':''"</span> @<span class="attr">click</span>=<span class="string">"toggleActive"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"imgSrc"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">:title</span>=<span class="string">"imgTitle+'!!!'"</span> <span class="attr">:class</span>=<span class="string">"&#123;active:isActive&#125;"</span> @<span class="attr">click</span>=<span class="string">"toggleActive"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="actionscript">                imgSrc:<span class="string">"http://www.itheima.com/images/logo.png"</span>,</span></span><br><span class="line"><span class="actionscript">                imgTitle:<span class="string">"黑马程序员"</span>,</span></span><br><span class="line"><span class="actionscript">                isActive:<span class="literal">false</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="actionscript">                toggleActive:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.isActive = !<span class="keyword">this</span>.isActive;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9、v-html"><a href="#9、v-html" class="headerlink" title="9、v-html"></a>9、v-html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>v-html指令<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当数据是有html结构时用v-html没用html结构时，二者都一样--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="handlebars"><span class="xml">                content:"<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'www.baidu.com'</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span>"</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="10、v-on"><a href="#10、v-on" class="headerlink" title="10、v-on"></a>10、v-on</h2><p>事件执行</p><p>v-on click= “js函数名”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-video-play&quot; @click&#x3D;&quot;start&quot;&gt;启动测试&lt;&#x2F;el-button&gt;</span><br></pre></td></tr></table></figure><h2 id="11、axios-vue"><a href="#11、axios-vue" class="headerlink" title="11、axios+vue"></a>11、axios+vue</h2><p><strong>axios.get或post方法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>axios+vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"获取笑话"</span> @<span class="attr">click</span>=<span class="string">"getJoke"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123; joke &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 官网提供的 axios 在线地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        /*</span><br><span class="line">            接口:随机获取一条笑话</span><br><span class="line"><span class="actionscript">            请求地址:https:<span class="comment">//autumnfish.cn/api/joke</span></span></span><br><span class="line"><span class="actionscript">            请求方法:<span class="keyword">get</span></span></span><br><span class="line">            请求参数:无</span><br><span class="line">            响应内容:随机笑话</span><br><span class="line">        */</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="actionscript">                joke:<span class="string">"很好笑的笑话"</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="actionscript">                getJoke:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// console.log(this.joke);</span></span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="actionscript">                    axios.get(<span class="string">"https://autumnfish.cn/api/joke"</span>).then(<span class="function"><span class="keyword">function</span><span class="params">(response)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                        <span class="comment">// console.log(response)</span></span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(response.data);</span></span><br><span class="line"><span class="actionscript">                        <span class="comment">// console.log(this.joke);</span></span></span><br><span class="line">                        that.joke = response.data;</span><br><span class="line"><span class="actionscript">                    &#125;,<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;  &#125;)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="二、vue脚手架的使用"><a href="#二、vue脚手架的使用" class="headerlink" title="二、vue脚手架的使用"></a>二、vue脚手架的使用</h1><table><thead><tr><th align="left">build</th><th align="left">项目构建(webpack)相关代码</th></tr></thead><tbody><tr><td align="left">config</td><td align="left">配置目录，包括端口号等。我们初学可以使用默认的。</td></tr><tr><td align="left">node_modules</td><td align="left">配置目录，包括端口号等。我们初学可以使用默认的。</td></tr><tr><td align="left">src</td><td align="left">这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：assets: 放置一些图片，如logo等。components: 目录里面放了一个组件文件，可以不用。App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。main.js: 项目的核心文件。</td></tr><tr><td align="left">static</td><td align="left">静态资源目录，如图片、字体等。</td></tr><tr><td align="left">test</td><td align="left">初始测试目录，可删除</td></tr><tr><td align="left">index.html</td><td align="left">首页入口文件，你可以添加一些 meta 信息或统计代码啥的。</td></tr><tr><td align="left">package.json</td><td align="left">项目配置文件。</td></tr><tr><td align="left">README.md</td><td align="left">项目的说明文档，markdown 格式</td></tr></tbody></table><p>当运行打包命令时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm run build</span><br></pre></td></tr></table></figure><p>在dist目录下的index.html文件就是项目最后打包形态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src文件的详解</span><br><span class="line">​assets静态资源css js image</span><br><span class="line">commpoents主要vue元件（返回的不同页面）</span><br><span class="line">routervue的主路由（访问不同路径，匹配不同commpoents的页面）</span><br><span class="line">App.vue主要的样板档案，包含一个案例</span><br><span class="line">main.jsvue js的主档案</span><br><span class="line">index.js静态档案</span><br></pre></td></tr></table></figure><h2 id="1、所有的标签都要被template包在里面"><a href="#1、所有的标签都要被template包在里面" class="headerlink" title="1、所有的标签都要被template包在里面"></a>1、所有的标签都要被template包在里面</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">   <span class="comment">// var app = new Vue(&#123;</span></span></span><br><span class="line"><span class="actionscript">   <span class="comment">//   el:"#app",</span></span></span><br><span class="line"><span class="actionscript">   <span class="comment">// data:&#123;</span></span></span><br><span class="line"><span class="actionscript">   <span class="comment">//   message:"哈哈哈!!!",</span></span></span><br><span class="line"><span class="actionscript">   <span class="comment">// info:"嘿嘿嘿"</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//&#125;</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//  &#125;)</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        data()&#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="actionscript">                msg:<span class="string">"hello vue"</span>,</span></span><br><span class="line">                obj:&#123;</span><br><span class="line"><span class="actionscript">                    name:<span class="string">"张三"</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="actionscript">            <span class="comment">//方法都是根据v-on来绑定事件的</span></span></span><br><span class="line">            getmsg()&#123;</span><br><span class="line"><span class="actionscript">                <span class="comment">//alert("vue方法执行了")</span></span></span><br><span class="line"><span class="actionscript">                alert(<span class="keyword">this</span>.msg)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、ref"><a href="#2、ref" class="headerlink" title="2、ref"></a>2、ref</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">ref</span>=<span class="string">"userinfo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"getInputValue()"</span>&gt;</span>获取input里的数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"box"</span>&gt;</span>我是一个box<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        data()&#123;&#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            getInputValue()&#123;</span><br><span class="line"><span class="actionscript">                <span class="comment">//获取ref定义的dom节点</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.$ref.userinfo)</span></span><br><span class="line"><span class="actionscript">                <span class="comment">//原生js的box操作</span></span></span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.$ref.box.style.background=<span class="string">"red"</span>   </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted()&#123;</span><br><span class="line"><span class="actionscript">        <span class="comment">//生命周期函数，加载就开始获取，感觉像init()函数</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">//vue页面刷新就会触发的方法</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、localStorage"><a href="#3、localStorage" class="headerlink" title="3、localStorage"></a>3、localStorage</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将数据保存到本地</span></span><br><span class="line"><span class="comment">//JSON.stringify(value)将序列化为字符串形式</span></span><br><span class="line">localStorage.setItem(key,<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.list))</span><br><span class="line"><span class="comment">//在缓存中取出list并将起反序列化</span></span><br><span class="line"><span class="keyword">var</span> list=<span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">"list"</span>))</span><br></pre></td></tr></table></figure><h2 id="4、文件引入"><a href="#4、文件引入" class="headerlink" title="4、文件引入"></a>4、文件引入</h2><p>Storage.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> storage=&#123;</span><br><span class="line">    <span class="keyword">set</span>(key,value)&#123;</span><br><span class="line">        localStorage.setItem(key,<span class="built_in">JSON</span>.stringify(value));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>(key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(localStorage.getItem(key));</span><br><span class="line">    &#125;,</span><br><span class="line">    remove(key)&#123;</span><br><span class="line">        localStorage.removeItem(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将storage暴露出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> storage</span><br><span class="line"><span class="comment">//********************************</span></span><br><span class="line"><span class="comment">//.vue或者其他界面引入</span></span><br><span class="line"><span class="keyword">import</span> storage <span class="keyword">from</span><span class="string">"./Storage.js"</span></span><br></pre></td></tr></table></figure><h2 id="5、组件、"><a href="#5、组件、" class="headerlink" title="5、组件、"></a>5、组件、</h2><p>vue中的组件指的是.vue文件比如在根组件app.vue中挂载home.vue和其他组件。组件的使用可以拓展html，提高代码的复用率</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在模板中使用组件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">v-home</span>&gt;</span><span class="tag">&lt;/<span class="name">v-home</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span>                 </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//1、引入组件</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">"./home.vue"</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">//2、挂载组件</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">//components和data()、methods同级</span></span></span><br><span class="line">components:&#123;</span><br><span class="line"><span class="actionscript">    <span class="string">"v-home"</span>:home</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="6、生命周期函数"><a href="#6、生命周期函数" class="headerlink" title="6、生命周期函数"></a>6、生命周期函数</h2><p>组件挂载、组件更新、组件销毁的时侯触发的一系列方法这些方法就叫生命周期函数</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt=""></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        data()&#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">                msg:<span class="string">"hahahaha"</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            setMsg()&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"实例创建之前"</span>)</span></span><br><span class="line">        &#125;,</span><br><span class="line">        created()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"实例创建完成"</span>)</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"模板编译之前"</span>)</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="comment">//最重要请求数据放在这里</span></span></span><br><span class="line">        mounted()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"模板编译完成"</span>)</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate()&#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"数据更新之前"</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">        updated()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"数据更新完毕"</span>)</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="comment">//页面销毁之前需要保存一些数据，可以监听这个生命周期函数</span></span></span><br><span class="line">        beforeDestory()&#123;</span><br><span class="line"><span class="actionscript">            consloe.log(<span class="string">"实例销毁之前"</span>)</span></span><br><span class="line">        &#125;,</span><br><span class="line">        destoryed()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"实例销毁"</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7、vue请求数据-axios"><a href="#7、vue请求数据-axios" class="headerlink" title="7、vue请求数据+axios"></a>7、vue请求数据+axios</h2><h3 id="7-1vue-resource"><a href="#7-1vue-resource" class="headerlink" title="7.1vue-resource"></a>7.1vue-resource</h3><p>1安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install vue-resource --save</span><br></pre></td></tr></table></figure><p><a href="https://github.com/pagekit/vue-resource" target="_blank" rel="noopener">vue-resource源码</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        methods:&#123;</span><br><span class="line">            getData()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> api = <span class="string">"www.baidu.com"</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.$http.get(api).then(<span class="function"><span class="keyword">function</span><span class="params">(response)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(response)</span></span><br><span class="line"><span class="actionscript">                &#125;,<span class="function"><span class="keyword">function</span><span class="params">(err)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(err)</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、在main.js引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">"./app.vue"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> VueResource <span class="keyword">from</span> <span class="string">'vue-resource'</span></span><br><span class="line"><span class="comment">//3Vue.use(VueResource)</span></span><br><span class="line">Vue.use(VueResource);</span><br></pre></td></tr></table></figure><p>4在组件中直接使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.get(api).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-2axios"><a href="#7-2axios" class="headerlink" title="7.2axios"></a>7.2axios</h3><p><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios源码地址</a></p><p>1安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install axios --save</span><br></pre></td></tr></table></figure><p>2哪里使用就在那里引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    import Axios from &#39;axios&#39;</span><br><span class="line">    export default&#123;</span><br><span class="line">        methods:&#123;</span><br><span class="line">            getData()&#123;</span><br><span class="line">                var api &#x3D;&#39;www.baidu.com&#39;</span><br><span class="line">                Axios.get(api).then((response)&#x3D;&gt;&#123;</span><br><span class="line">                    console.log(response)</span><br><span class="line">                &#125;).catch(()&#x3D;&gt;&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="8、父子组件之间传值"><a href="#8、父子组件之间传值" class="headerlink" title="8、父子组件之间传值"></a>8、父子组件之间传值</h2><p>不同的父组件调用同一子组件时返回的值不同</p><p>8.1父组件给子组件传值</p><p>1.父组件调用子组件时绑定动态属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;v-header :title&#x3D;&#39;title&#39;&gt;</span><br><span class="line">&lt;&#x2F;v-header&gt;</span><br></pre></td></tr></table></figure><p>2.在子组件中通过props接受父组件传过来的数据</p><p>首先说一下父子组件就是在一个vue文件中引入另一个vue文件，被引入vue文件就是子组件，引入vue文件的vue文件就是父组件。而在父组件中是不能直接调用子组件中的变量值的。下面详细说一下，父子组件之间怎么传值。</p><p>先说一下父组件引入子组件的方法。</p><h3 id="1、路由配置："><a href="#1、路由配置：" class="headerlink" title="1、路由配置："></a>1、路由配置：</h3><p>使用children属性实现路由嵌套，嵌套的组件关系就是父子组件关系</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      path: <span class="string">'/father'</span>,</span><br><span class="line">      name: <span class="string">'father'</span>,</span><br><span class="line">      component: father,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'son'</span>,</span><br><span class="line">          name: <span class="string">'son'</span>,</span><br><span class="line">          component: son</span><br><span class="line">        &#125;</span><br><span class="line">      ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、组件传值-父组件向子组件传值"><a href="#2、组件传值-父组件向子组件传值" class="headerlink" title="2、组件传值-父组件向子组件传值"></a>2、组件传值-父组件向子组件传值</h3><p>第一步：父组件 在引用子组件时，通过属性绑定（v-bind：）的形式，把需要传递给子组件的数据，传递到子组件内部，供子组件使用 </p><p>父组件：father.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;父组件&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;router-view v-bind:fData&#x3D;&quot;data1&quot; :fMessage&#x3D;&quot;data2&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data1: &#39;父组件数据data1&#39;,</span><br><span class="line">      data2: &#39;父组件数据data2&#39;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>第二步：把父组件传递过来的数据， 在 props数组 中定义一下</p><ol><li>组件中的 所有props 中的数据，都是通过父组件传递给子组件的</li><li>props 中的数据都是只读的，无法重新赋值</li></ol><p>第三步：在该子组件中使用props数组 中定义好的数据</p><p>子组件：son.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;子组件&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;下面是父组件传过来的数据&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;第一个数据：&#123;&#123;fData&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;第二个数据：&#123;&#123;fMessage&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;fData&#39;, &#39;fMessage&#39;],</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="3、组件传值-父组件把方法传递给子组件"><a href="#3、组件传值-父组件把方法传递给子组件" class="headerlink" title="3、组件传值-父组件把方法传递给子组件"></a>3、组件传值-父组件把方法传递给子组件</h3><p>第一步：父组件向子组件传递方法，使用事件绑定机制 v-on，自定义一个事件属性，传递给子组件</p><p>父组件：father.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;父组件&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;router-view @show="showFather"&gt;&lt;/</span>router-view&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    showFather (a, b) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'触发了父组件的方法'</span> + <span class="string">'======'</span> + a + <span class="string">'======'</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：在子组件中定义一个方法，在方法中，利用  $emit  触发 父组件传递过来的，挂载在当前实例上的事件，还可以传递参数</p><p>第三步：在子组件中调用定义的那个方法，就可以触发父组件传递过来的方法了</p><p>子组件：son.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;子组件&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;Button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;sonClick&quot;&gt;触发父组件方法&lt;&#x2F;Button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sonClick () &#123;</span><br><span class="line">      this.$emit(&#39;show&#39;, 111, 222);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="4、组件传值-子组件通过事件调用向父组件传值"><a href="#4、组件传值-子组件通过事件调用向父组件传值" class="headerlink" title="4、组件传值-子组件通过事件调用向父组件传值"></a>4、组件传值-子组件通过事件调用向父组件传值</h3><p>在子组件中，利用  $emit  触发 父组件传递过来的方法的时候，可以将子组件的数据当做参数传递给父组件</p><p>父组件：father.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;父组件&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;router-view @show&#x3D;&quot;showFather&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      fromSon1: &#39;&#39;,</span><br><span class="line">      fromSon2: &#39;&#39;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    showFather (a, b) &#123;</span><br><span class="line">      this.fromSon1 &#x3D; a;</span><br><span class="line">      this.fromSon2 &#x3D; b;</span><br><span class="line">      console.log(&#39;触发了父组件的方法&#39; + &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39; + a + &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39; + b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>子组件：son.vue </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;子组件&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;Button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;sonClick&quot;&gt;触发父组件方法&lt;&#x2F;Button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;fData&#39;, &#39;fMessage&#39;],</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      sonMessage: &#39;子组件数据sonMessage&#39;,</span><br><span class="line">      sonData: &#39;子组件数据sonData&#39;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sonClick () &#123;</span><br><span class="line">      this.$emit(&#39;show&#39;, this.sonMessage, this.sonData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="5、父子组件之间相互传值"><a href="#5、父子组件之间相互传值" class="headerlink" title="5、父子组件之间相互传值"></a>5、父子组件之间相互传值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;父组件&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;Button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;getData&quot;&gt;获取数据&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;router-view v-bind:fData&#x3D;&quot;data1&quot; :fMessage&#x3D;&quot;data2&quot; @show&#x3D;&quot;showFather&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data1: &#39;父组件数据data1&#39;,</span><br><span class="line">      data2: &#39;父组件数据data2&#39;,</span><br><span class="line">      fromSon1: &#39;&#39;,</span><br><span class="line">      fromSon2: &#39;&#39;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    showFather (a, b) &#123;</span><br><span class="line">      this.fromSon1 &#x3D; a;</span><br><span class="line">      this.fromSon2 &#x3D; b;</span><br><span class="line">      console.log(&#39;触发了父组件的方法&#39; + &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39; + a + &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39; + b);</span><br><span class="line">    &#125;,</span><br><span class="line">    getData () &#123;</span><br><span class="line">      console.log(this.fromSon1);</span><br><span class="line">      console.log(this.fromSon2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;子组件&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;下面是父组件传过来的数据&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;第一个数据：&#123;&#123;fData&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;第二个数据：&#123;&#123;fMessage&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;Button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;sonClick&quot;&gt;触发父组件方法&lt;&#x2F;Button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;fData&#39;, &#39;fMessage&#39;],</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      sonMessage: &#39;子组件数据sonMessage&#39;,</span><br><span class="line">      sonData: &#39;子组件数据sonData&#39;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sonClick () &#123;</span><br><span class="line">      this.$emit(&#39;show&#39;, this.sonMessage, this.sonData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="9、vue-路由"><a href="#9、vue-路由" class="headerlink" title="9、vue 路由"></a>9、vue 路由</h2><p>在router.js的文件里写入每个独立页面的路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    routes: [&#123;</span><br><span class="line">        path: <span class="string">'/'</span>,</span><br><span class="line">        name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">        component: HelloWorld</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="10、mint-ui"><a href="#10、mint-ui" class="headerlink" title="10、mint-ui"></a>10、mint-ui</h2><p><a href="http://mint-ui.github.io/" target="_blank" rel="noopener">mint-ui官网</a></p><p>mint-ui和element-ui一样都是饿了么公司开发的ui， mint-ui是移动端ui，element-ui是网页端的ui。</p><p>1安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install mint-ui --save</span><br></pre></td></tr></table></figure><p>2引入mintUI的css和插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Mint from &#39;mint-ui&#39;</span><br><span class="line">Vue.use(Mint);</span><br><span class="line">import &#39;mint-ui&#x2F;lib&#x2F;style.css&#39;</span><br></pre></td></tr></table></figure><p>3直接使用</p><h2 id="11、element-ui"><a href="#11、element-ui" class="headerlink" title="11、element-ui"></a>11、element-ui</h2><p><a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener">element-ui官网</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://unpkg.com/element-ui/lib/theme-chalk/index.css"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入组件库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/element-ui/lib/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在main.js中引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ElementUI from &#39;element-ui&#39;</span><br><span class="line">import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;</span><br><span class="line">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、vue基本v-指令vue-js&quot;&gt;&lt;a href=&quot;#一、vue基本v-指令vue-js&quot; class=&quot;headerlink&quot; title=&quot;一、vue基本v-指令vue.js&quot;&gt;&lt;/a&gt;一、vue基本v-指令vue.js&lt;/h1&gt;&lt;h2 id=&quot;1、el挂
      
    
    </summary>
    
    
    
      <category term="node.js" scheme="http://yoursite.com/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>node.js及express</title>
    <link href="http://yoursite.com/2020/03/03/node-js%E5%8F%8Aexpress/"/>
    <id>http://yoursite.com/2020/03/03/node-js%E5%8F%8Aexpress/</id>
    <published>2020-03-03T09:53:01.000Z</published>
    <updated>2020-03-03T09:54:38.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习日志"><a href="#学习日志" class="headerlink" title="学习日志"></a>学习日志</h1><p>[TOC]</p><h1 id="一web框架基础"><a href="#一web框架基础" class="headerlink" title="一web框架基础"></a>一web框架基础</h1><p>Web应用（网站）：</p><p>​    浏览器（socket客户端）</p><p>​        2、访问域名网址（ip，端口）</p><p>​            app.listen(port)    </p><p>​        5、接收</p><p>​        6、连接断开</p><p>​    网站（socket服务端）</p><p>​        1、监听ip和端口（）</p><p>​            while True:</p><p>​            用户=等待用户连接</p><p>​        3、收到’‘i want…’’</p><p>​        4、响应：</p><p>​            用户断开</p><p>​    WEB应用(网站)</p><pre><code>HTTP协议：</code></pre><p>​                发送：</p><h1 id="二express框架学习笔记"><a href="#二express框架学习笔记" class="headerlink" title="二express框架学习笔记"></a>二express框架学习笔记</h1><p>(写在前面：</p><p>express项目建立流程操作</p><p>（脚手架全局安装npm install express-generator -g ）</p><p>1、新建一个项目文件夹</p><p>2、在VS code里打开文件夹</p><p>3、按crtl和~键打开终端 </p><p>4、在终端输入npm i express</p><p>5、在文件夹根目录下新建server.js(此文件为项目入口文件，注意以.js为后缀名)</p><h2 id="1、目录结构"><a href="#1、目录结构" class="headerlink" title="1、目录结构"></a>1、目录结构</h2><p><strong>bin</strong>    存放启动项目的脚本文件 </p><p>​    www无后缀，项目的入口文件，配置web服务端口和监听</p><p><strong>node_modules</strong>,存放所有项目依赖库。之后导入的包也会放入比如连接数据库的mongoose模块</p><p><strong>public</strong>，静态文件（css，js，img）</p><p><strong>routes,</strong>路由文件（MVC中C,controller）路由模块，其中默认了index.js和user.js在这里其实也包括一般后台语言中的控制器内容，当然在大的项目上是可以分离开来的 </p><p><strong>views,</strong>页面文件（Ejs模板）</p><p><strong>package.json</strong>,项目依赖配置及开发这信息</p><p><strong>app.js</strong>,应用核心配置文件</p><h2 id="2、package-json"><a href="#2、package-json" class="headerlink" title="2、package.json"></a>2、package.json</h2><p>​    package.json用于项目依赖配置及开发者信息，scripts属性是用于定义操作命令的，可以非常方便的增加启                动命令，比如默认的start，用npm start代表执行node ./bin/www命令 。查看package.json文件。 </p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#123;&#96;</span><br><span class="line"></span><br><span class="line"> &quot;name&quot;: &quot;express4-demo&quot;,</span><br><span class="line"></span><br><span class="line"> &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, </span><br><span class="line"></span><br><span class="line">&#96;&quot;scripts&quot;: &#123;&#96;</span><br><span class="line"></span><br><span class="line"> &quot;start&quot;: &quot;node .&#x2F;bin&#x2F;www&quot;</span><br><span class="line"></span><br><span class="line"> &#125;, </span><br><span class="line"></span><br><span class="line">&quot;dependencies&quot;: &#123; </span><br><span class="line"></span><br><span class="line">&quot;body-parser&quot;: &quot;~1.10.2&quot;, </span><br><span class="line"></span><br><span class="line">&#96;&quot;cookie-parser&quot;: &quot;~1.3.3&quot;,&#96;</span><br><span class="line"></span><br><span class="line"> &quot;debug&quot;: &quot;~2.1.1&quot;, &quot;ejs&quot;: &quot;~2.2.3&quot;, </span><br><span class="line"></span><br><span class="line">&quot;express&quot;: &quot;~4.11.1&quot;, </span><br><span class="line"></span><br><span class="line">&quot;morgan&quot;: &quot;~1.5.1&quot;, </span><br><span class="line"></span><br><span class="line">&quot;serve-favicon&quot;: &quot;~2.2.0&quot; </span><br><span class="line"></span><br><span class="line">&#96;&#125;&#96;</span><br></pre></td></tr></table></figure><h2 id="3、app-js核心文件"><a href="#3、app-js核心文件" class="headerlink" title="3、app.js核心文件"></a>3、app.js核心文件</h2><p>​    从Express3.x升级到Express4.x，主要的变化就在app.js文件中。查看app.js文件 </p><p>​    // 加载依赖库，原来这个类库都封装在connect中，现在需地注单独加载</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">var expreess&#x3D;require(&#39;express&#39;);</span><br><span class="line"></span><br><span class="line">var createError &#x3D; require(&#39;http-errors&#39;);</span><br><span class="line"></span><br><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line"></span><br><span class="line">var path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">var cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class="line"></span><br><span class="line">var logger &#x3D; require(&#39;morgan&#39;);</span><br><span class="line"></span><br><span class="line">var ejs&#x3D;require(&#39;ejs&#39;);</span><br><span class="line"></span><br><span class="line">varfavion&#x3D;require(&#39;serve-favicon&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加载路由控制</span><br><span class="line"></span><br><span class="line">var indexRouter &#x3D; require(&#39;.&#x2F;routes&#x2F;index&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;var usersRouter&#x3D;require(&#39;.&#x2F;routes&#x2F;users&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建项目实例</span><br><span class="line"></span><br><span class="line">var app &#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; view engine setup</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义ejs模板引擎和模板文件位置，也可以使用jade或其他模型引擎</span><br><span class="line"></span><br><span class="line">app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;));</span><br><span class="line"></span><br><span class="line">app.set(&#39;view engine&#39;, &#39;ejs&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义icon图标</span><br><span class="line"></span><br><span class="line">app.use(favion(__dirname + &#39;&#x2F;public&#x2F;favion.ico&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义日志和输出级别</span><br><span class="line"></span><br><span class="line">app.use(logger(&#39;dev&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义数据解析器</span><br><span class="line"></span><br><span class="line">app.use(express.json());</span><br><span class="line"></span><br><span class="line">app.use(express.urlencoded(&#123; extended: false &#125;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义cookie解析器</span><br><span class="line"></span><br><span class="line">app.use(cookieParser());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义静态文件目录public，静态文件(css,js,img)</span><br><span class="line"></span><br><span class="line">app.use(express.static(path.join(__dirname, &#39;public&#39;)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;匹配路径和路由</span><br><span class="line"></span><br><span class="line">app.use(&#39;&#x2F;&#39;,routes);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;app.use(&#39;&#x2F;users&#39;, usersRouter);</span><br><span class="line"></span><br><span class="line">app.use(&#39;&#x2F;&#39;, indexRouter);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; catch 404 and forward to error handler错误处理</span><br><span class="line"></span><br><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line"></span><br><span class="line">  next(createError(404));</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; error handler</span><br><span class="line"></span><br><span class="line">app.use(function(err, req, res, next) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; set locals, only providing error in development 开发环境，500错误处理和错误堆栈跟踪</span><br><span class="line"></span><br><span class="line">  res.locals.message &#x3D; err.message;</span><br><span class="line"></span><br><span class="line">  res.locals.error &#x3D; req.app.get(&#39;env&#39;) &#x3D;&#x3D;&#x3D; &#39;development&#39; ? err : &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; render the error page&#x2F;&#x2F; 生产环境，500错误处理</span><br><span class="line"></span><br><span class="line">  res.status(err.status || 500);</span><br><span class="line"></span><br><span class="line">  res.render(&#39;error&#39;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">    module.exports &#x3D; app;</span><br></pre></td></tr></table></figure><h2 id="4、路由功能"><a href="#4、路由功能" class="headerlink" title="4、路由功能"></a>4、路由功能</h2><p>​    <em>路由</em>是指应用程序的端点（URI）如何响应客户端请求。有关路由的介绍，请参阅<a href="http://www.expressjs.com.cn/en/starter/basic-routing.html" target="_blank" rel="noopener">基本路由</a>。</p><p>您可以使用Express <code>app</code>对象的方法定义路由，这些方法对应于HTTP方法; 例如，<code>app.get()</code>处理GET请求和<code>app.post</code>处理POST请求。有关完整列表，请参阅<a href="http://www.expressjs.com.cn/en/4x/api.html#app.METHOD" target="_blank" rel="noopener">app.METHOD</a>。您还可以使用<a href="http://www.expressjs.com.cn/en/4x/api.html#app.all" target="_blank" rel="noopener">app.all（）</a>来处理所有HTTP方法，并使用<a href="http://www.expressjs.com.cn/en/4x/api.html#app.use" target="_blank" rel="noopener">app.use（）</a>将中间件指定为回调函数（有关详细信息，请参阅<a href="http://www.expressjs.com.cn/en/guide/using-middleware.html" target="_blank" rel="noopener">使用中间件</a>）。</p><p>这些路由方法指定当应用程序收到对指定路由（端点）和HTTP方法的请求时调用的回调函数（有时称为“处理函数”）。换句话说，应用程序“侦听”与指定路由和方法匹配的请求，并且当它检测到匹配时，它将调用指定的回调函数。</p><p>实际上，路由方法可以有多个回调函数作为参数。使用多个回调函数时，重要的是提供<code>next</code>回调函数的参数，然后<code>next()</code>在函数体内调用以将控制权移交给下一个回调函数。</p><p>以下代码是一个非常基本的路由示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;)</span><br><span class="line">var app &#x3D; express()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; respond with &quot;hello world&quot; when a GET request is made to the homepage</span><br><span class="line">app.get(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;hello world&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路线方法"><a href="#路线方法" class="headerlink" title="路线方法"></a>路线方法</h3><p>路由方法从其中一个HTTP方法派生，并附加到<code>express</code>类的实例。</p><p>以下代码是为应用程序根目录的GET和POST方法定义的路由示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GET method route</span><br><span class="line">app.get(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;GET request to the homepage&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; POST method route</span><br><span class="line">app.post(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;POST request to the homepage&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Express支持与所有HTTP请求方法对应的方法：<code>get</code>，<code>post</code>等等。有关完整列表，请参阅<a href="http://www.expressjs.com.cn/en/4x/api.html#app.METHOD" target="_blank" rel="noopener">app.METHOD</a>。</p><p>有一种特殊的路由方法，<code>app.all()</code>用于在路径上为<em>所有</em> HTTP请求方法加载中间件函数。例如，无论是使用GET，POST，PUT，DELETE还是<a href="https://nodejs.org/api/http.html#http_http_methods" target="_blank" rel="noopener">http模块</a>支持的任何其他HTTP请求方法，都会对路由“/ secret”的请求执行以下处理程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.all(&#39;&#x2F;secret&#39;, function (req, res, next) &#123;</span><br><span class="line">  console.log(&#39;Accessing the secret section ...&#39;)</span><br><span class="line">  next() &#x2F;&#x2F; pass control to the next handler</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路线路径"><a href="#路线路径" class="headerlink" title="路线路径"></a>路线路径</h3><p>路径路径与请求方法结合，定义可以进行请求的端点。路径路径可以是字符串，字符串模式或正则表达式。</p><p>字符<code>?</code>，<code>+</code>，<code>*</code>，和<code>()</code>是他们的正则表达式的对应的子集。连字符（<code>-</code>）和点（<code>.</code>）按字面顺序由基于字符串的路径解释。</p><p>如果你需要<code>$</code>在路径字符串中使用美元字符（），请将其包含在<code>([</code>和中<code>])</code>。例如，“ <code>/data/$book</code>” 处的请求的路径字符串将是“ <code>/data/([\$])book</code>”。</p><p>Express使用<a href="https://www.npmjs.com/package/path-to-regexp" target="_blank" rel="noopener">path-to-regexp</a>来匹配路径路径; 有关定义路径路径的所有可能性，请参阅path-to-regexp文档。<a href="http://forbeslindesay.github.io/express-route-tester/" target="_blank" rel="noopener">Express Route Tester</a>是一个用于测试基本Express路线的便捷工具，尽管它不支持模式匹配。</p><p>查询字符串不是路径路径的一部分。</p><p>以下是基于字符串的路径路径的一些示例。</p><p>此路由路径将匹配对根路由的请求，<code>/</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;root&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此路径路径将匹配请求<code>/about</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;about&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;about&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此路径路径将匹配请求<code>/random.text</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;random.text&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;random.text&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以下是基于字符串模式的路径路径的一些示例。</p><p>此路径路径将匹配<code>acd</code>和<code>abcd</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;ab?cd&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;ab?cd&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这条路线的路径将会匹配<code>abcd</code>，<code>abbcd</code>，<code>abbbcd</code>，等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;ab+cd&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;ab+cd&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这条路线的路径将会匹配<code>abcd</code>，<code>abxcd</code>，<code>abRANDOMcd</code>，<code>ab123cd</code>，等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;ab*cd&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;ab*cd&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此路径路径将匹配<code>/abe</code>和<code>/abcde</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;ab(cd)?e&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;ab(cd)?e&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>基于正则表达式的路径路径示例：</p><p>此路径路径将匹配其中包含“a”的任何内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x2F;a&#x2F;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;&#x2F;a&#x2F;&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这条路线的路径将匹配<code>butterfly</code>和<code>dragonfly</code>，但不<code>butterflyman</code>，<code>dragonflyman</code>等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x2F;.*fly$&#x2F;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;&#x2F;.*fly$&#x2F;&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路线参数"><a href="#路线参数" class="headerlink" title="路线参数"></a>路线参数</h3><p>路径参数是命名的URL段，用于捕获在URL中的位置指定的值。捕获的值将填充在<code>req.params</code>对象中，路径参数的名称在路径中指定为其各自的键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route path: &#x2F;users&#x2F;:userId&#x2F;books&#x2F;:bookId</span><br><span class="line">Request URL: http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;34&#x2F;books&#x2F;8989</span><br><span class="line">req.params: &#123; &quot;userId&quot;: &quot;34&quot;, &quot;bookId&quot;: &quot;8989&quot; &#125;</span><br></pre></td></tr></table></figure><p>要使用路由参数定义路由，只需在路径路径中指定路由参数，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;users&#x2F;:userId&#x2F;books&#x2F;:bookId&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(req.params)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>路径参数的名称必须由“单词字符”（[A-Za-z0-9_]）组成。</p><p>由于连字符（<code>-</code>）和点（<code>.</code>）按字面解释，因此它们可以与路由参数一起使用以用于有用的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route path: &#x2F;flights&#x2F;:from-:to</span><br><span class="line">Request URL: http:&#x2F;&#x2F;localhost:3000&#x2F;flights&#x2F;LAX-SFO</span><br><span class="line">req.params: &#123; &quot;from&quot;: &quot;LAX&quot;, &quot;to&quot;: &quot;SFO&quot; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route path: &#x2F;plantae&#x2F;:genus.:species</span><br><span class="line">Request URL: http:&#x2F;&#x2F;localhost:3000&#x2F;plantae&#x2F;Prunus.persica</span><br><span class="line">req.params: &#123; &quot;genus&quot;: &quot;Prunus&quot;, &quot;species&quot;: &quot;persica&quot; &#125;</span><br></pre></td></tr></table></figure><p>要更好地控制路由参数可以匹配的确切字符串，可以在括号（<code>()</code>）中附加正则表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route path: &#x2F;user&#x2F;:userId(\d+)</span><br><span class="line">Request URL: http:&#x2F;&#x2F;localhost:3000&#x2F;user&#x2F;42</span><br><span class="line">req.params: &#123;&quot;userId&quot;: &quot;42&quot;&#125;</span><br></pre></td></tr></table></figure><p>因为正则表达式通常是文字字符串的一部分，所以请确保<code>\</code>使用额外的反斜杠转义任何字符<code>\\d+</code>。</p><p>在Express 4.x中，<a href="https://github.com/expressjs/express/issues/2495" target="_blank" rel="noopener">正则表达式中</a><a href="https://github.com/expressjs/express/issues/2495" target="_blank" rel="noopener">的<code>*</code>字符不以通常的方式解释</a>。作为一种解决方法，请使用<code>{0,}</code>而不是<code>*</code>。这可能会在Express 5中修复。</p><h3 id="路线处理程序"><a href="#路线处理程序" class="headerlink" title="路线处理程序"></a>路线处理程序</h3><p>您可以提供多个回调函数，其行为类似于<a href="http://www.expressjs.com.cn/en/guide/using-middleware.html" target="_blank" rel="noopener">中间件</a>来处理请求。唯一的例外是这些回调可能会调用<code>next(&#39;route&#39;)</code>以绕过剩余的路由回调。您可以使用此机制对路径施加前置条件，然后在没有理由继续当前路由的情况下将控制权传递给后续路由。</p><p>路由处理程序可以是函数，函数数组或两者的组合形式，如以下示例所示。</p><p>单个回调函数可以处理路由。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;example&#x2F;a&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;Hello from A!&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>多个回调函数可以处理路径（确保指定<code>next</code>对象）。例如</strong>：next的使用在多个回调函数的基础上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;example&#x2F;b&#39;, function (req, res, next) &#123;</span><br><span class="line">  console.log(&#39;the response will be sent by the next function ...&#39;)</span><br><span class="line">  next()</span><br><span class="line">&#125;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;Hello from B!&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一组回调函数可以处理路由。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var cb0 &#x3D; function (req, res, next) &#123;</span><br><span class="line">  console.log(&#39;CB0&#39;)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cb1 &#x3D; function (req, res, next) &#123;</span><br><span class="line">  console.log(&#39;CB1&#39;)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cb2 &#x3D; function (req, res) &#123;</span><br><span class="line">  res.send(&#39;Hello from C!&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;example&#x2F;c&#39;, [cb0, cb1, cb2])</span><br></pre></td></tr></table></figure><p>独立函数和函数数组的组合可以处理路径。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var cb0 &#x3D; function (req, res, next) &#123;</span><br><span class="line">  console.log(&#39;CB0&#39;)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cb1 &#x3D; function (req, res, next) &#123;</span><br><span class="line">  console.log(&#39;CB1&#39;)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;example&#x2F;d&#39;, [cb0, cb1], function (req, res, next) &#123;</span><br><span class="line">  console.log(&#39;the response will be sent by the next function ...&#39;)</span><br><span class="line">  next()</span><br><span class="line">&#125;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;Hello from D!&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="回应方法"><a href="#回应方法" class="headerlink" title="回应方法"></a>回应方法</h3><p><code>res</code>下表中响应对象（）的方法可以向客户端发送响应，并终止请求 - 响应周期。如果没有从路由处理程序调用这些方法，则客户端请求将保持挂起状态。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.expressjs.com.cn/en/4x/api.html#res.download" target="_blank" rel="noopener">res.download()</a></td><td>提示下载文件。</td></tr><tr><td><a href="http://www.expressjs.com.cn/en/4x/api.html#res.end" target="_blank" rel="noopener">重发（）</a></td><td>结束响应过程。=&gt;  res.end()</td></tr><tr><td><a href="http://www.expressjs.com.cn/en/4x/api.html#res.json" target="_blank" rel="noopener">res.json（）</a></td><td>发送JSON响应。</td></tr><tr><td><a href="http://www.expressjs.com.cn/en/4x/api.html#res.jsonp" target="_blank" rel="noopener">res.jsonp（）</a></td><td>使用JSONP支持发送JSON响应。</td></tr><tr><td><a href="http://www.expressjs.com.cn/en/4x/api.html#res.redirect" target="_blank" rel="noopener">res.redirect（）</a></td><td>重定向请求。</td></tr><tr><td><a href="http://www.expressjs.com.cn/en/4x/api.html#res.render" target="_blank" rel="noopener">res.render（）</a></td><td>渲染视图模板。</td></tr><tr><td><a href="http://www.expressjs.com.cn/en/4x/api.html#res.send" target="_blank" rel="noopener">res.send（）</a></td><td>发送各种类型的回复。</td></tr><tr><td><a href="http://www.expressjs.com.cn/en/4x/api.html#res.sendFile" target="_blank" rel="noopener">res.sendFile（）</a></td><td>将文件作为八位字节流发送。</td></tr><tr><td><a href="http://www.expressjs.com.cn/en/4x/api.html#res.sendStatus" target="_blank" rel="noopener">res.sendStatus（）</a></td><td>设置响应状态代码并将其字符串表示形式作为响应主体发送。</td></tr></tbody></table><h3 id="app-route（）"><a href="#app-route（）" class="headerlink" title="app.route（）"></a>app.route（）</h3><p>您可以使用创建路径路径的可链路径处理程序<code>app.route()</code>。由于路径是在单个位置指定的，因此创建模块化路由很有帮助，同时减少冗余和拼写错误。有关路由的更多信息，请参阅：<a href="http://www.expressjs.com.cn/en/4x/api.html#router" target="_blank" rel="noopener">Router（）文档</a>。</p><p>以下是使用定义的链接路由处理程序的示例<code>app.route()</code>。和前面基本分路由的效果一样但是使用app.route代码量更少</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.route(&#39;&#x2F;book&#39;)</span><br><span class="line">  .get(function (req, res) &#123;</span><br><span class="line">    res.send(&#39;Get a random book&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .post(function (req, res) &#123;</span><br><span class="line">    res.send(&#39;Add a book&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .put(function (req, res) &#123;</span><br><span class="line">    res.send(&#39;Update the book&#39;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="express-Router"><a href="#express-Router" class="headerlink" title="express.Router"></a>express.Router</h3><p>使用<code>express.Router</code>该类创建模块化，可安装的路由处理程序。一个<code>Router</code>实例是一个完整的中间件和路由系统; 因此，它通常被称为“迷你app”。</p><p>以下示例将路由器创建为模块，在其中加载中间件功能，定义一些路由，并将路由器模块安装在主应用程序中的路径上。</p><p>创建<code>birds.js</code>app目录中指定的路由器文件，其中包含以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;)</span><br><span class="line">var router &#x3D; express.Router()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; middleware that is specific to this router</span><br><span class="line">router.use(function timeLog (req, res, next) &#123;</span><br><span class="line">  console.log(&#39;Time: &#39;, Date.now())</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; define the home page route</span><br><span class="line">router.get(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;Birds home page&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; define the about route</span><br><span class="line">router.get(&#39;&#x2F;about&#39;, function (req, res) &#123;</span><br><span class="line">  res.send(&#39;About birds&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; router</span><br></pre></td></tr></table></figure><p>然后，在应用程序中加载路由器模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var birds &#x3D; require(&#39;.&#x2F;birds&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">app.use(&#39;&#x2F;birds&#39;, birds)</span><br></pre></td></tr></table></figure><p>该应用程序现在能够处理请求<code>/birds</code>和<code>/birds/about</code>，以及调用<code>timeLog</code>中间件功能是特定的路线。</p><h2 id="5、静态文件托管"><a href="#5、静态文件托管" class="headerlink" title="5、静态文件托管"></a>5、静态文件托管</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D;require(&#39;express&#39;);</span><br><span class="line"></span><br><span class="line">const app&#x3D;express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态文件托管</span><br><span class="line"></span><br><span class="line">app.use(&#39;&#x2F;&#39;,express.static(&#39;public&#39;))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;,function(req,res)&#123;</span><br><span class="line"></span><br><span class="line">    res.send(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;product&#39;,function(req,res)&#123;</span><br><span class="line"></span><br><span class="line">    res.send([</span><br><span class="line"></span><br><span class="line">        &#123;id:1,title:&#39;a&#39;&#125;,</span><br><span class="line"></span><br><span class="line">        &#123;id:2,title:&#39;b&#39;&#125;</span><br><span class="line"></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000,()&#x3D;&gt;&#123;</span><br><span class="line"></span><br><span class="line">    console.log(&#39;app listen on port 1000&#39;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另一种写法：app.use(‘/static’,express.static(‘public’)) </p><p>但是相应的访问连接变成了localhost:3000/static/index.html</p><h2 id="6跨域请求"><a href="#6跨域请求" class="headerlink" title="6跨域请求"></a>6跨域请求</h2><p>域：一个ip+端口号为一个域，在相同ip和端口的均属同域</p><p>在终端输入npm i cors 安装一个叫做cors的包</p><p>在server.js文件中写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(require(&#39;cors&#39;)());&#x2F;&#x2F;解决跨域问题</span><br></pre></td></tr></table></figure><h2 id="7express与数据库"><a href="#7express与数据库" class="headerlink" title="7express与数据库"></a>7express与数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var mongo &#x3D; require(&quot;mongodb&quot;); &#x2F;&#x2F;引入mongodb模块</span><br><span class="line">var assert &#x3D; require(&quot;assert&quot;); &#x2F;&#x2F;引入断言模块 </span><br><span class="line"></span><br><span class="line">var MongoClient &#x3D; mongo.MongoClient;  &#x2F;&#x2F;开启服务 </span><br><span class="line"></span><br><span class="line">var Urls &#x3D; &quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;demo2&quot;;  &#x2F;&#x2F;url储存  放在连接池中。 MongoClient.connect(Urls,function(err,db)&#123;  &#x2F;&#x2F;获取连接 </span><br><span class="line">assert.equal(null,err);  &#x2F;&#x2F;使用断言模块代替以前的 if判断 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;修改数据 </span><br><span class="line">db.collection(&quot;t1&quot;).update(&#123;&quot;name&quot;:&quot;zhangsan1&quot;&#125;,&#123;$set:&#123;&quot;name&quot;:&quot;xiaoming&quot;&#125;&#125;,function(err,result)&#123; &#x2F;&#x2F;连接到数据库上面，并使用参数传入集合</span><br><span class="line">assert.equal(null,err);</span><br><span class="line">console.log(result); db.close();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="（1）mongoose的基础知识"><a href="#（1）mongoose的基础知识" class="headerlink" title="（1）mongoose的基础知识"></a>（1）mongoose的基础知识</h3><p>​    <strong>最重要的是，连接数据库之后，不会直接建立一个自己命名的数据库，必须要建立一个collection也就是说，必须要对自己建立的数据库有个具体的操作，才能够在数据库可视化软件上看到结果</strong>。</p><p>　Mongooose中，有三个比较重要的概念，分别是Schema、Model、Entity。它们的关系是：Schema生成Model，Model创造Document，Model和Document都可对数据库操作造成影响，但Model比Document更具操作性</p><p><code>Schema</code>用于定义数据库的结构。类似创建表时的数据定义(不仅仅可以定义文档的结构和属性，还可以定义文档的实例方法、静态模型方法、复合索引等)，每个<code>Schema</code>会映射到mongodb中的一个collection，<code>Schema</code>不具备操作数据库的能力</p><p>　　Model是由Schema编译而成的构造器，具有抽象属性和行为，可以对数据库进行增删查改。Model的每一个实例（instance）就是一个文档document</p><p>　　Document是由Model创建的实体，它的操作也会影响数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;1、引入mongoose</span><br><span class="line"></span><br><span class="line">const mongoose&#x3D;require(&#39;mongoose&#39;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、建立连接</span><br><span class="line"></span><br><span class="line">mongoose.connect(&#39;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;hahaha&#39;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、操作表单（集合） 定义一个Schema(不具备操作数据库的能力)</span><br><span class="line"></span><br><span class="line">var MessageSchema&#x3D;mongoose.Schema(&#123;</span><br><span class="line"></span><br><span class="line">    name:String,</span><br><span class="line"></span><br><span class="line">    adress:String,</span><br><span class="line"></span><br><span class="line">    telephone:Number,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4、定义数据库模型  操作数据库</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;model中的第一个参数1首字母大写2和数据库表对应</span><br><span class="line"></span><br><span class="line">var Message&#x3D;mongoose.model(&#39;Message&#39;,MessageSchema);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;5查询messages表的数据</span><br><span class="line"></span><br><span class="line">Message.find(&#123;&#125;,function(err,doc)&#123;</span><br><span class="line"></span><br><span class="line">    if(err)&#123;</span><br><span class="line"></span><br><span class="line">        console.log(err);</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(doc);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;6增加数据</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;6.1实例化model 通过实例化message model创建增加的数据</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;6.2实例.save</span><br><span class="line"></span><br><span class="line">var message&#x3D;new Message(&#123;name:&#39;xx&#39;, adress:&#39;xxl&#39;,telephone:33&#125;);</span><br><span class="line"></span><br><span class="line">message.save(function(err)&#123;</span><br><span class="line"></span><br><span class="line">    if (err)&#123;</span><br><span class="line"></span><br><span class="line">        console.log(err);</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(&#39;搞定！&#39;)</span><br><span class="line"></span><br><span class="line">&#125;);&#x2F;&#x2F;save方法本身就是一个document，只能接受插入一条数据，插入多条数据用insertMary</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;7、修改数据</span><br><span class="line">&#x2F;&#x2F;第一个对象是查询条件，第二个是修改内容，function是回调函数</span><br><span class="line">Message.updateOne(&#123;&#39;_id&#39;:&#39;5c9f19a8c6d8b6504ac19e8f&#39;&#125;,&#123;&#39;name&#39;:&#39;聪哥&#39;&#125;,function(err,doc)&#123;</span><br><span class="line"></span><br><span class="line">    if (err)&#123;</span><br><span class="line"></span><br><span class="line">        return console.log(err);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    console.log(doc)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;8、删除数据</span><br><span class="line"></span><br><span class="line">Message.deleteOne(&#123;&#39;_id&#39;:&#39;5c9f19a8c6d8b6504ac19e8f&#39;&#125;,(err,doc)&#x3D;&gt;&#123;</span><br><span class="line"></span><br><span class="line">    if (err)&#123;</span><br><span class="line"></span><br><span class="line">        return console.log(err);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    console.log(doc)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="（2）连接和断开数据库"><a href="#（2）连接和断开数据库" class="headerlink" title="（2）连接和断开数据库"></a>（2）连接和断开数据库</h3><p>首先在终端</p><p>npm i mongoose</p><p>然后在server.js文件内写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const mongoose&#x3D;require(&#39;mongooose&#39;);&#x2F;&#x2F;引入mongoose模块</span><br><span class="line"></span><br><span class="line">mongoose.connect(&#39;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;express-test&#39;，&#123; useNewUrlParser: true &#125;)&#x2F;&#x2F;默认端口是27017固定格式express-test是数据库名</span><br><span class="line">&#x2F;&#x2F;定义一个模型，把相同类的模型放到同一个表内，Product为模型名，new mongoose.Schema(&#123;&#125;)为表结构&#123;&#125;表示传递一个对象参数产品模型的各种属性（类似于字典）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const Product&#x3D;mongoose.model(&#39;Product&#39;,new mongoose.Schema(&#123;</span><br><span class="line">    title:String,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;product&#39;,async function(req,res)&#123;</span><br><span class="line">    res.send(await Product.find())&#x2F;*await,表示异步进行，在函数的返回部分出现“await“，function前要加上”async“find方法表示查询*&#x2F;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>【connect()】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(url);</span><br></pre></td></tr></table></figure><p>　　connect()最简单的使用方式，就是只要传入url参数即可，如下所示。连接到本地localhost的db1服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(&#39;mongodb:&#x2F;&#x2F;localhost&#x2F;db1&#39;);</span><br></pre></td></tr></table></figure><p>　　如果还需要传递用户名、密码，则可以使用如下方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(&#39;mongodb:&#x2F;&#x2F;username:password@host:port&#x2F;database?options...&#39;);</span><br></pre></td></tr></table></figure><p>　　connect()方法还接受一个选项对象options，该对象将传递给底层驱动程序。这里所包含的所有选项优先于连接字符串中传递的选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(uri, options);</span><br></pre></td></tr></table></figure><p>　　可用选项如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db            -数据库设置</span><br><span class="line">server        -服务器设置</span><br><span class="line">replset       -副本集设置</span><br><span class="line">user          -用户名</span><br><span class="line">pass          -密码</span><br><span class="line">auth          -鉴权选项</span><br><span class="line">mongos        -连接多个数据库</span><br><span class="line">promiseLibrary</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var options &#x3D; &#123;</span><br><span class="line">  db: &#123; native_parser: true &#125;,</span><br><span class="line">  server: &#123; poolSize: 5 &#125;,</span><br><span class="line">  replset: &#123; rs_name: &#39;myReplicaSetName&#39; &#125;,</span><br><span class="line">  user: &#39;myUserName&#39;,</span><br><span class="line">  pass: &#39;myPassword&#39;</span><br><span class="line">&#125;</span><br><span class="line">mongoose.connect(uri, options);</span><br></pre></td></tr></table></figure><p>　　如果要连接多个数据库，只需要设置多个url以<code>,</code>隔开，同时设置<code>mongos</code>为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(&#39;urlA,urlB,...&#39;, &#123;</span><br><span class="line">   mongos : true </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>　　connect()函数还接受一个回调参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(uri, options, function(error) &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 　　执行下列代码后，控制台输出“连接成功”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">mongoose.connect(&quot;mongodb:&#x2F;&#x2F;localhost&#x2F;test&quot;, function(err) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&#39;连接失败&#39;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&#39;连接成功&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 　　如果开启鉴权控制，以用户名”u1”，密码”123456”登录’db1’数据库。执行代码后，控制台输出“连接成功”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">mongoose.connect(&quot;mongodb:&#x2F;&#x2F;u1:123456@localhost&#x2F;db1&quot;, function(err) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&#39;连接失败&#39;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&#39;连接成功&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>【disconnect()】 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.disconnect()</span><br></pre></td></tr></table></figure><p>　　 使用disconnect()方法可以断开连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">mongoose.connect(&quot;mongodb:&#x2F;&#x2F;u1:123456@localhost&#x2F;db1&quot;, function(err) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&#39;连接失败&#39;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&#39;连接成功&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    mongoose.disconnect(function()&#123;</span><br><span class="line">        console.log(&quot;断开连接&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, 2000);</span><br></pre></td></tr></table></figure><p><img src="https://images2015.cnblogs.com/blog/740839/201707/740839-20170720232404255-1533749216.gif" alt="img"></p><h3 id="（3）数据库中查找数据"><a href="#（3）数据库中查找数据" class="headerlink" title="（3）数据库中查找数据"></a>（3）数据库中查找数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Product.find()&#x2F;&#x2F;不传入参数，表示查找全部</span><br><span class="line"></span><br><span class="line">Product.find().skip.(1)limit(2)&#x2F;&#x2F;跳过1限制两条输出2，3</span><br><span class="line"></span><br><span class="line">Product.find().where(&#123;</span><br><span class="line"></span><br><span class="line">title:&#39;产品2&#39;</span><br><span class="line"></span><br><span class="line">&#125;)&#x2F;&#x2F;where表示查询条件&#123;&#125;为一个对象表示title&#x3D;产品2的一项</span><br><span class="line"></span><br><span class="line">Product.find().sort(&#123;_id:-1&#125;)&#x2F;&#x2F;按id从小到大排（-1表示倒序）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;product&#x2F;:id&#39;,async function(req,res)&#123;</span><br><span class="line">const data&#x3D;Product.findByid(req.params.id)&#x2F;*req.params表示客户端传过来的url中所有数据.id表示通过id获取的，如果前面路由是“：name”，后面就要写req.params.name*&#x2F;</span><br><span class="line">   res.send(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="（4）数据库中增加数据"><a href="#（4）数据库中增加数据" class="headerlink" title="（4）数据库中增加数据"></a>（4）数据库中增加数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Product.insertMany([</span><br><span class="line"></span><br><span class="line">    &#123;title:&#39;产品1&#39;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;title:&#39;产品2&#39;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;title:&#39;产品3&#39;&#125;,</span><br><span class="line"></span><br><span class="line">])&#x2F;&#x2F;inserMany插入多条数据，（）为传入参数[]表示传入一个列表</span><br></pre></td></tr></table></figure><p>　文档新增有三种方法，一种是使用上面介绍过的文档的save()方法，另一种是使用模型model的create()方法，最后一种是模型model的insertMany()方法</p><p>【save()】</p><p>　　[注意]回调函数可以省略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save([options], [options.safe], [options.validateBeforeSave], [fn])</span><br></pre></td></tr></table></figure><p>　　新建{age:10,name:’save’}文档，并保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">mongoose.connect(&quot;mongodb:&#x2F;&#x2F;u1:123456@localhost&#x2F;db1&quot;, function(err) &#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        var schema &#x3D; new mongoose.Schema(&#123; age:Number, name: String&#125;);        </span><br><span class="line">        var temp &#x3D; mongoose.model(&#39;temp&#39;, schema);</span><br><span class="line">        &#x2F;&#x2F;使用链式写法    </span><br><span class="line">        new temp(&#123;age:10,name:&#39;save&#39;&#125;).save(function(err,doc)&#123;</span><br><span class="line">            &#x2F;&#x2F;[ &#123; _id: 59720bc0d2b1125cbcd60b3f, age: 10, name: &#39;save&#39;, __v: 0 &#125; ]</span><br><span class="line">            console.log(doc);        </span><br><span class="line">        &#125;);         </span><br><span class="line">    &#125;           </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>【create()】</p><p>　　使用save()方法，需要先实例化为文档，再使用save()方法保存文档。而create()方法，则直接在模型Model上操作，并且可以同时新增多个文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model.create(doc(s), [callback])</span><br></pre></td></tr></table></figure><p>　　新增{name:”xiaowang”}，{name:”xiaoli”}这两个文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">mongoose.connect(&quot;mongodb:&#x2F;&#x2F;u1:123456@localhost&#x2F;db1&quot;, function(err) &#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        var schema &#x3D; new mongoose.Schema(&#123; age:Number, name: String&#125;);        </span><br><span class="line">        var temp &#x3D; mongoose.model(&#39;temp&#39;, schema);   </span><br><span class="line">        temp.create(&#123;name:&quot;xiaowang&quot;&#125;,&#123;name:&quot;xiaoli&quot;&#125;,function(err,doc1,doc2)&#123;</span><br><span class="line">            &#x2F;&#x2F;&#123; __v: 0, name: &#39;xiaowang&#39;, _id: 59720d83ad8a953f5cd04664 &#125;</span><br><span class="line">            console.log(doc1); </span><br><span class="line">            &#x2F;&#x2F;&#123; __v: 0, name: &#39;xiaoli&#39;, _id: 59720d83ad8a953f5cd04665 &#125;</span><br><span class="line">            console.log(doc2); </span><br><span class="line">        &#125;);       </span><br><span class="line">    &#125;           </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>【insertMany()】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model.insertMany(doc(s), [options], [callback])</span><br></pre></td></tr></table></figure><p>　　新增{name:”a”}，{name:”b”}这两个文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">mongoose.connect(&quot;mongodb:&#x2F;&#x2F;u1:123456@localhost&#x2F;db1&quot;, function(err) &#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        var schema &#x3D; new mongoose.Schema(&#123; age:Number, name: String&#125;);        </span><br><span class="line">        var temp &#x3D; mongoose.model(&#39;temp&#39;, schema);   </span><br><span class="line">        temp.insertMany([&#123;name:&quot;a&quot;&#125;,&#123;name:&quot;b&quot;&#125;],function(err,docs)&#123;</span><br><span class="line">            &#x2F;&#x2F;[ &#123; __v: 0, name: &#39;a&#39;, _id: 59720ea1bbf5792af824b30c &#125;,</span><br><span class="line">            &#x2F;&#x2F;&#123; __v: 0, name: &#39;b&#39;, _id: 59720ea1bbf5792af824b30d &#125; ]</span><br><span class="line">            console.log(docs); </span><br><span class="line">        &#125;);       </span><br><span class="line"></span><br><span class="line">    &#125;           </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【post接口】后台开发</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.use(express.json()) </span><br><span class="line"></span><br><span class="line">server.post(&#39;&#x2F;message&#39;,async function(req,res)&#123;</span><br><span class="line"></span><br><span class="line">    const data &#x3D;req.body</span><br><span class="line"></span><br><span class="line">    res.send(data)</span><br><span class="line"></span><br><span class="line">    await Message.create(data)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【put接口】修改数据库</span><br><span class="line"></span><br><span class="line">server.put(&#39;&#x2F;message&#x2F;:id&#39;,async function(req,res)&#123;</span><br><span class="line"></span><br><span class="line">    const message&#x3D;await Message.findById(req.params.id)&#x2F;&#x2F;通过id先找到要改的值</span><br><span class="line"></span><br><span class="line">    message.name&#x3D;req.body.name&#x2F;&#x2F;令要改的部分等于客户端传来的部分</span><br><span class="line"></span><br><span class="line">    await message.save()</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【delete接口】</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除数据</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.delete(&#39;&#x2F;message&#x2F;:id&#39;,async function(req,res)&#123;</span><br><span class="line"></span><br><span class="line">    const message&#x3D;await Message.findById(req.params.id)&#x2F;&#x2F;通过id先找到要改的值</span><br><span class="line"></span><br><span class="line">    await message.remove()</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="8登陆验证功能"><a href="#8登陆验证功能" class="headerlink" title="8登陆验证功能"></a>8登陆验证功能</h2><p>app.post</p><h1 id="三、node-js对文件操作"><a href="#三、node-js对文件操作" class="headerlink" title="三、node.js对文件操作"></a>三、node.js对文件操作</h1><h2 id="1、-txt文件"><a href="#1、-txt文件" class="headerlink" title="1、.txt文件"></a>1、.txt文件</h2><p>1-1写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var wfs&#x3D;require(&#39;fs&#39;); </span><br><span class="line">wfs.appendFile(&#39;.&#x2F;data.txt&#39;,&#39;待写入的内容&#39;,function(err)&#123;</span><br><span class="line">if(err)console.log(err);</span><br><span class="line">else console.log(&#39;success&#39;);                        </span><br><span class="line">&#125;)&#x2F;&#x2F;.appendFile()方法是在原文件中添加.write()方法是覆盖原文件的内容均为异步写入</span><br></pre></td></tr></table></figure><p>1-2读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&#39;.&#x2F;path&#39;,callback)</span><br></pre></td></tr></table></figure><h2 id="2、-json文件"><a href="#2、-json文件" class="headerlink" title="2、.json文件"></a>2、.json文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let str&#x3D;JSON.stringify(standardata,&#39;&#39;,&#39;\t&#39;)&#x2F;&#x2F;standardata是取得的对象，把对象保存为json格式\t跳格（移至下一列）</span><br><span class="line"></span><br><span class="line">fs.appendFile(&#39;.&#x2F;data.json&#39;,str,function(err)&#123;</span><br><span class="line"></span><br><span class="line">    if(err)console.log(err);</span><br><span class="line"></span><br><span class="line">    else console.log(&#39;成功写入&#39;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="四、udp网络通信"><a href="#四、udp网络通信" class="headerlink" title="四、udp网络通信"></a>四、udp网络通信</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const dgram&#x3D;require(&quot;dgram&quot;);</span><br><span class="line"></span><br><span class="line">const server&#x3D;dgram.createSocket(&#39;udp4&#39;);</span><br><span class="line"></span><br><span class="line">server.on(&#39;message&#39;,function(msg,rinfo)&#123;&#x2F;&#x2F;message事件&#x2F;解析全部在message事件里</span><br><span class="line"></span><br><span class="line">    var  data &#x3D; msg.toString(&#39;Hex&#39;)&#x2F;&#x2F;将16进制转为字符串</span><br><span class="line">    parase_1(data)+parase_2(data)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.bind(56789,&#39;172.16.101.250&#39;);&#x2F;&#x2F;绑定IP和端口</span><br><span class="line"></span><br><span class="line">server.on(&#39;listening&#39;,function()&#123;</span><br><span class="line"></span><br><span class="line">    console.log(&#39;开始监听&#39;)&#x2F;&#x2F;listening事件</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="五、对常见内容的操作"><a href="#五、对常见内容的操作" class="headerlink" title="五、对常见内容的操作"></a>五、对常见内容的操作</h1><h2 id="5-1对字符串的操作"><a href="#5-1对字符串的操作" class="headerlink" title="5-1对字符串的操作"></a>5-1对字符串的操作</h2><p>（1）取某一位置的值，根据索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str&#x3D;&#39;hello&#39;</span><br><span class="line"></span><br><span class="line">str[0] &#x3D;&gt; h</span><br></pre></td></tr></table></figure><p>（2）切片取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.substring(0,2)&#x2F;&#x2F;从索引0到2不包括2</span><br><span class="line">str.substring(-1,-2)&#x2F;&#x2F;倒叙取值</span><br></pre></td></tr></table></figure><h3 id="（3）字符串转为数组"><a href="#（3）字符串转为数组" class="headerlink" title="（3）字符串转为数组"></a>（3）字符串转为数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.split(&#39;分割符&#39;)&#x2F;&#x2F;以字符串中某一特定元素为分割</span><br></pre></td></tr></table></figure><h2 id="5-2对数组的操作"><a href="#5-2对数组的操作" class="headerlink" title="5-2对数组的操作"></a>5-2对数组的操作</h2><p>（1）取某一位置的值同字符串</p><p>（2）取切片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;[1,2,3,&#39;hello&#39;,&#39;world&#39;]</span><br><span class="line"></span><br><span class="line">arr.slice(0,3)</span><br></pre></td></tr></table></figure><p>（3）增加元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.push(&#39;x&#39;)&#x2F;&#x2F;向末尾添加若干元素</span><br><span class="line"></span><br><span class="line">arr.unshift(&#39;x&#39;)&#x2F;&#x2F;向头部添加若干元素</span><br></pre></td></tr></table></figure><p>（4）删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr.pop()&#x2F;&#x2F;删除最后一个元素</span><br><span class="line"></span><br><span class="line">arr.shift()&#x2F;&#x2F;删除第一个元素</span><br><span class="line">　　去除字符串内所有的空格：str &#x3D; str.replace(&#x2F;\s*&#x2F;g,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">　　去除字符串内两头的空格：str &#x3D; str.replace(&#x2F;^\s*|\s*$&#x2F;g,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">　　去除字符串内左侧的空格：str &#x3D; str.replace(&#x2F;^\s*&#x2F;,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">　　去除字符串内右侧的空格：str &#x3D; str.replace(&#x2F;(\s*$)&#x2F;g,&quot;&quot;);</span><br></pre></td></tr></table></figure><p>splice</p><p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];</span><br><span class="line">&#x2F;&#x2F; 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</span><br><span class="line">&#x2F;&#x2F; 只删除,不添加:</span><br><span class="line">arr.splice(2, 2); &#x2F;&#x2F; [&#39;Google&#39;, &#39;Facebook&#39;]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]</span><br><span class="line">&#x2F;&#x2F; 只添加,不删除:</span><br><span class="line">arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回[],因为没有删除任何元素</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</span><br></pre></td></tr></table></figure><p>（5）数组拼接</p><p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">var added &#x3D; arr.concat([1, 2, 3]);</span><br></pre></td></tr></table></figure><h3 id="（6）数组转字符串"><a href="#（6）数组转字符串" class="headerlink" title="（6）数组转字符串"></a>（6）数组转字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3];</span><br><span class="line">arr.join(&#39;-&#39;); &#x2F;&#x2F; &#39;A-B-C-1-2-3&#39;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习日志&quot;&gt;&lt;a href=&quot;#学习日志&quot; class=&quot;headerlink&quot; title=&quot;学习日志&quot;&gt;&lt;/a&gt;学习日志&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一web框架基础&quot;&gt;&lt;a href=&quot;#一web框架基础&quot; class=&quot;headerl
      
    
    </summary>
    
    
    
      <category term="node.js" scheme="http://yoursite.com/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>gin框架</title>
    <link href="http://yoursite.com/2020/02/25/gin%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2020/02/25/gin%E6%A1%86%E6%9E%B6/</id>
    <published>2020-02-25T13:39:04.000Z</published>
    <updated>2020-02-25T13:41:55.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gin框架"><a href="#gin框架" class="headerlink" title="gin框架"></a>gin框架</h1><p>写在前面的话，用好任何的工具都通用的方法—去查看官方文档</p><p><a href="https://gin-gonic.com/zh-cn/docs/" target="_blank" rel="noopener">gin中文文档</a></p><h2 id="1、框架的安装"><a href="#1、框架的安装" class="headerlink" title="1、框架的安装"></a>1、框架的安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><h2 id="2、使用实例"><a href="#2、使用实例" class="headerlink" title="2、使用实例"></a>2、使用实例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个默认的路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// GET：请求方式；/hello：请求的路径</span></span><br><span class="line"><span class="comment">// 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数</span></span><br><span class="line">r.GET(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// c.JSON：返回JSON格式的数据</span></span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: <span class="string">"Hello world!"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动HTTP服务，默认在0.0.0.0:8080启动服务</span></span><br><span class="line">    <span class="comment">//r.Run(":8080")</span></span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置路由的处理函数的写法有点像node.js的express框架的写法可以互相印证着记忆。不同的是gin框架在路由和处理函数之间可以加入任意多的中间件来实现自己所需的功能</p><h2 id="3、参数处理"><a href="#3、参数处理" class="headerlink" title="3、参数处理"></a>3、参数处理</h2><p>1、querystring参数</p><p>指的是url中 <strong>？</strong>后面的所携带的参数例如*<em>/login?username=haha&amp;password=123 *</em>这种方式一般都是get方法，把参数暴露在url中很不安全</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">"/user/search"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">username := c.DefaultQuery(<span class="string">"username"</span>, <span class="string">"haha"</span>)</span><br><span class="line"><span class="comment">//username := c.Query("username")</span></span><br><span class="line">address := c.Query(<span class="string">"address"</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>:  <span class="string">"ok"</span>,</span><br><span class="line"><span class="string">"username"</span>: username,</span><br><span class="line"><span class="string">"address"</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、获取form参数（这个一般是主要的）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">"/user/search"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// DefaultPostForm取不到值时会返回指定的默认值</span></span><br><span class="line"><span class="comment">//username := c.DefaultPostForm("username", "小王子")</span></span><br><span class="line">username := c.PostForm(<span class="string">"username"</span>)</span><br><span class="line">address := c.PostForm(<span class="string">"address"</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>:  <span class="string">"ok"</span>,</span><br><span class="line"><span class="string">"username"</span>: username,</span><br><span class="line"><span class="string">"address"</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3、获取path参数</p><p>请求的参数通过URL路径传递，例如：<code>/user/search/小王子/沙河</code>。 获取请求URL路径中的参数的方式如下。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">"/user/search/:username/:address"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">username := c.Param(<span class="string">"username"</span>)</span><br><span class="line">address := c.Param(<span class="string">"address"</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>:  <span class="string">"ok"</span>,</span><br><span class="line"><span class="string">"username"</span>: username,</span><br><span class="line"><span class="string">"address"</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4、参数绑定<strong><em>c.ShouldBind(&amp;login)</em></strong></p><p>利用c.ShouldBind(&amp;“实例化的结构体名”)将需绑定的数据绑定到实例化的结构体中</p><p>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的<code>Content-Type</code>识别请求数据类型并利用反射机制自动提取请求中<code>QueryString</code>、<code>form表单</code>、<code>JSON</code>、<code>XML</code>等参数到结构体中。 下面的示例代码演示了<code>.ShouldBind()</code>强大的功能，它能够基于请求自动提取<code>JSON</code>、<code>form表单</code>和<code>QueryString</code>类型的数据，并把值绑定到指定的结构体对象。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Binding from JSON</span></span><br><span class="line"><span class="keyword">type</span> Login <span class="keyword">struct</span> &#123;</span><br><span class="line">User     <span class="keyword">string</span> <span class="string">`form:"user" json:"user" binding:"required"`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`form:"password" json:"password" binding:"required"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定JSON的示例 (&#123;"user": "q1mi", "password": "123456"&#125;)</span></span><br><span class="line">router.POST(<span class="string">"/loginJSON"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> login Login</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"login info:%#v\n"</span>, login)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"user"</span>:     login.User,</span><br><span class="line"><span class="string">"password"</span>: login.Password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"error"</span>: err.Error()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定form表单示例 (user=q1mi&amp;password=123456)</span></span><br><span class="line">router.POST(<span class="string">"/loginForm"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> login Login</span><br><span class="line"><span class="comment">// ShouldBind()会根据请求的Content-Type自行选择绑定器</span></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"user"</span>:     login.User,</span><br><span class="line"><span class="string">"password"</span>: login.Password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"error"</span>: err.Error()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定QueryString示例 (/loginQuery?user=q1mi&amp;password=123456)</span></span><br><span class="line">router.GET(<span class="string">"/loginForm"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> login Login</span><br><span class="line"><span class="comment">// ShouldBind()会根据请求的Content-Type自行选择绑定器</span></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"user"</span>:     login.User,</span><br><span class="line"><span class="string">"password"</span>: login.Password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"error"</span>: err.Error()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen and serve on 0.0.0.0:8080</span></span><br><span class="line">router.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、文件上传"><a href="#4、文件上传" class="headerlink" title="4、文件上传"></a>4、文件上传</h2><p>前端页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>上传文件示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/upload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"f1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后台</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line"><span class="comment">// 处理multipart forms提交文件时默认的内存限制是32 MiB</span></span><br><span class="line"><span class="comment">// 可以通过下面的方式修改</span></span><br><span class="line"><span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">router.POST(<span class="string">"/upload"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 单个文件</span></span><br><span class="line">file, err := c.FormFile(<span class="string">"f1"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusInternalServerError, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: err.Error(),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(file.Filename)</span><br><span class="line">dst := fmt.Sprintf(<span class="string">"C:/tmp/%s"</span>, file.Filename)</span><br><span class="line"><span class="comment">// 上传文件到指定的目录</span></span><br><span class="line">c.SaveUploadedFile(file, dst)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: fmt.Sprintf(<span class="string">"'%s' uploaded!"</span>, file.Filename),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">//多文件上传</span></span><br><span class="line">    router.POST(<span class="string">"/upload"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// Multipart form</span></span><br><span class="line">form, _ := c.MultipartForm()</span><br><span class="line">files := form.File[<span class="string">"file"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">log.Println(file.Filename)</span><br><span class="line">dst := fmt.Sprintf(<span class="string">"C:/tmp/%s_%d"</span>, file.Filename, index)</span><br><span class="line"><span class="comment">// 上传文件到指定的目录</span></span><br><span class="line">c.SaveUploadedFile(file, dst)</span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: fmt.Sprintf(<span class="string">"%d files uploaded!"</span>, <span class="built_in">len</span>(files)),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、重定向"><a href="#5、重定向" class="headerlink" title="5、重定向"></a>5、重定向</h2><p>http重定向</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">"/test"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.Redirect(http.StatusMovedPermanently, <span class="string">"http://www.sogo.com/"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>路由重定向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r.GET(&quot;&#x2F;test&quot;, func(c *gin.Context) &#123;</span><br><span class="line">    &#x2F;&#x2F; 指定重定向的URL</span><br><span class="line">    c.Request.URL.Path &#x3D; &quot;&#x2F;test2&quot;</span><br><span class="line">    r.HandleContext(c)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(&quot;&#x2F;test2&quot;, func(c *gin.Context) &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;&quot;hello&quot;: &quot;world&quot;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="6、路由"><a href="#6、路由" class="headerlink" title="6、路由"></a>6、路由</h2><p>Gin框架中的路由使用的是<a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">httprouter</a>这个库，其基本原理就是构造一个路由地址的前缀树。 </p><h3 id="gin普通路由"><a href="#gin普通路由" class="headerlink" title="gin普通路由"></a>gin普通路由</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">r.GET(<span class="string">"/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">r.POST(<span class="string">"/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><p>此外，还有一个可以匹配所有请求方法的<code>Any</code>方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.Any(<span class="string">"/test"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><p>为没有配置处理函数的路由添加处理程序，默认情况下它返回404代码，下面的代码为没有匹配到路由的请求都返回<code>views/404.html</code>页面。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.NoRoute(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusNotFound, <span class="string">"views/404.html"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h3><p>我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对<code>{}</code>包裹同组的路由，这只是为了看着清晰，你用不用<code>{}</code>包裹功能上没什么区别。通常我们将路由分组用在划分业务逻辑或划分API版本时。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">userGroup := r.Group(<span class="string">"/user"</span>)</span><br><span class="line">&#123;</span><br><span class="line">userGroup.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">userGroup.GET(<span class="string">"/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">userGroup.POST(<span class="string">"/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">shopGroup := r.Group(<span class="string">"/shop"</span>)</span><br><span class="line">&#123;</span><br><span class="line">shopGroup.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.GET(<span class="string">"/cart"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.POST(<span class="string">"/checkout"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">&#125;</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由组也是支持嵌套的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shopGroup := r.Group(<span class="string">"/shop"</span>)</span><br><span class="line">&#123;</span><br><span class="line">shopGroup.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.GET(<span class="string">"/cart"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.POST(<span class="string">"/checkout"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line"><span class="comment">// 嵌套路由组</span></span><br><span class="line">xx := shopGroup.Group(<span class="string">"xx"</span>)</span><br><span class="line">xx.GET(<span class="string">"/oo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、中间件"><a href="#7、中间件" class="headerlink" title="7、中间件"></a>7、中间件</h2><p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。 </p><h3 id="7-1全局中间件"><a href="#7-1全局中间件" class="headerlink" title="7.1全局中间件"></a>7.1全局中间件</h3><p>所有的请求都会经过这个中间件（可以用作tooken验证）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义中间</span></span><br><span class="line"><span class="comment">//中间件都必须是gin.HandlerFunc类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MiddleWare</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        t := time.Now()</span><br><span class="line">        fmt.Println(<span class="string">"中间件开始执行了"</span>)</span><br><span class="line">        <span class="comment">// 设置变量到Context的key中，可以通过Get()取</span></span><br><span class="line">        c.Set(<span class="string">"request"</span>, <span class="string">"中间件"</span>)</span><br><span class="line">        status := c.Writer.Status()</span><br><span class="line">        fmt.Println(<span class="string">"中间件执行完毕"</span>, status)</span><br><span class="line">        t2 := time.Since(t)</span><br><span class="line">        fmt.Println(<span class="string">"time:"</span>, t2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建路由</span></span><br><span class="line">    <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">    r := gin.Default()</span><br><span class="line">    <span class="comment">// 注册中间件</span></span><br><span class="line">    r.Use(MiddleWare())</span><br><span class="line">    <span class="comment">// &#123;&#125;为了代码规范</span></span><br><span class="line">    &#123;</span><br><span class="line">        r.GET(<span class="string">"/ce"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 取值</span></span><br><span class="line">            req, _ := c.Get(<span class="string">"request"</span>)</span><br><span class="line">            fmt.Println(<span class="string">"request:"</span>, req)</span><br><span class="line">            <span class="comment">// 页面接收</span></span><br><span class="line">            c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">"request"</span>: req&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2中间件中的Next-方法"><a href="#7-2中间件中的Next-方法" class="headerlink" title="7.2中间件中的Next()方法"></a>7.2中间件中的Next()方法</h3><p>next指的是中间件执行完成之后的一些事务，不调用该请求的剩余处理程序。可以用来写请求的计时器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义中间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MiddleWare</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        t := time.Now()</span><br><span class="line">        fmt.Println(<span class="string">"中间件开始执行了"</span>)</span><br><span class="line">        <span class="comment">// 设置变量到Context的key中，可以通过Get()取</span></span><br><span class="line">        c.Set(<span class="string">"request"</span>, <span class="string">"中间件"</span>)</span><br><span class="line">        <span class="comment">// 执行函数</span></span><br><span class="line">        c.Next()</span><br><span class="line">        <span class="comment">// 中间件执行完后续的一些事情</span></span><br><span class="line">        status := c.Writer.Status()</span><br><span class="line">        fmt.Println(<span class="string">"中间件执行完毕"</span>, status)</span><br><span class="line">        t2 := time.Since(t)</span><br><span class="line">        fmt.Println(<span class="string">"time:"</span>, t2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建路由</span></span><br><span class="line">    <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">    r := gin.Default()</span><br><span class="line">    <span class="comment">// 注册中间件</span></span><br><span class="line">    r.Use(MiddleWare())</span><br><span class="line">    <span class="comment">// &#123;&#125;为了代码规范</span></span><br><span class="line">    &#123;</span><br><span class="line">        r.GET(<span class="string">"/ce"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 取值</span></span><br><span class="line">            req, _ := c.Get(<span class="string">"request"</span>)</span><br><span class="line">            fmt.Println(<span class="string">"request:"</span>, req)</span><br><span class="line">            <span class="comment">// 页面接收</span></span><br><span class="line">            c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">"request"</span>: req&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.topgoer.com/static/gin/4.1/3.png" alt="img"> <img src="http://www.topgoer.com/static/gin/4.1/2.png" alt="img"> </p><h3 id="7-3局部中间件"><a href="#7-3局部中间件" class="headerlink" title="7.3局部中间件"></a>7.3局部中间件</h3><p>主要的区别是r.use(“中间件”)，没有那条语句，直接在每个路由中调用自己的中间件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义中间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MiddleWare</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        t := time.Now()</span><br><span class="line">        fmt.Println(<span class="string">"中间件开始执行了"</span>)</span><br><span class="line">        <span class="comment">// 设置变量到Context的key中，可以通过Get()取</span></span><br><span class="line">        c.Set(<span class="string">"request"</span>, <span class="string">"中间件"</span>)</span><br><span class="line">        <span class="comment">// 执行函数</span></span><br><span class="line">        c.Next()</span><br><span class="line">        <span class="comment">// 中间件执行完后续的一些事情</span></span><br><span class="line">        status := c.Writer.Status()</span><br><span class="line">        fmt.Println(<span class="string">"中间件执行完毕"</span>, status)</span><br><span class="line">        t2 := time.Since(t)</span><br><span class="line">        fmt.Println(<span class="string">"time:"</span>, t2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建路由</span></span><br><span class="line">    <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">    r := gin.Default()</span><br><span class="line">    <span class="comment">//局部中间键使用</span></span><br><span class="line">    r.GET(<span class="string">"/ce"</span>, MiddleWare(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 取值</span></span><br><span class="line">        req, _ := c.Get(<span class="string">"request"</span>)</span><br><span class="line">        fmt.Println(<span class="string">"request:"</span>, req)</span><br><span class="line">        <span class="comment">// 页面接收</span></span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">"request"</span>: req&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、多端口服务"><a href="#8、多端口服务" class="headerlink" title="8、多端口服务"></a>8、多端口服务</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">g errgroup.Group</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">router01</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">e := gin.New()</span><br><span class="line">e.Use(gin.Recovery())</span><br><span class="line">e.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(</span><br><span class="line">http.StatusOK,</span><br><span class="line">gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>:  http.StatusOK,</span><br><span class="line"><span class="string">"error"</span>: <span class="string">"Welcome server 01"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">router02</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">e := gin.New()</span><br><span class="line">e.Use(gin.Recovery())</span><br><span class="line">e.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(</span><br><span class="line">http.StatusOK,</span><br><span class="line">gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>:  http.StatusOK,</span><br><span class="line"><span class="string">"error"</span>: <span class="string">"Welcome server 02"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server01 := &amp;http.Server&#123;</span><br><span class="line">Addr:         <span class="string">":8080"</span>,</span><br><span class="line">Handler:      router01(),</span><br><span class="line">ReadTimeout:  <span class="number">5</span> * time.Second,</span><br><span class="line">WriteTimeout: <span class="number">10</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server02 := &amp;http.Server&#123;</span><br><span class="line">Addr:         <span class="string">":8081"</span>,</span><br><span class="line">Handler:      router02(),</span><br><span class="line">ReadTimeout:  <span class="number">5</span> * time.Second,</span><br><span class="line">WriteTimeout: <span class="number">10</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 借助errgroup.Group或者自行开启两个goroutine分别启动两个服务</span></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> server01.ListenAndServe()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> server02.ListenAndServe()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、会话控制"><a href="#9、会话控制" class="headerlink" title="9、会话控制"></a>9、会话控制</h2><p><strong><em>在会话控制这部分，我们可以根据自己要处理的业务不同自己开发自己对相应的库。毕竟很多实际项目不能完全依靠开源世界。</em></strong></p><h3 id="9-1-Cookie"><a href="#9-1-Cookie" class="headerlink" title="9.1 Cookie"></a>9.1 Cookie</h3><p>cookie可以看成是一小段信息，保存在浏览器端，不是很安全大家都能看到</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 1.创建路由</span></span><br><span class="line">   <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">   r := gin.Default()</span><br><span class="line">   <span class="comment">// 服务端要给客户端cookie</span></span><br><span class="line">   r.GET(<span class="string">"cookie"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">      <span class="comment">// 获取客户端是否携带cookie（cookie的名字是设置好的</span></span><br><span class="line">      cookie, err := c.Cookie(<span class="string">"key_cookie"</span>)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         cookie = <span class="string">"NotSet"</span></span><br><span class="line">         <span class="comment">// 给客户端设置cookie</span></span><br><span class="line">         <span class="comment">//  maxAge int, 单位为秒</span></span><br><span class="line">         <span class="comment">// path,cookie所在目录</span></span><br><span class="line">         <span class="comment">// domain string,域名</span></span><br><span class="line">         <span class="comment">//   secure 是否智能通过https访问</span></span><br><span class="line">         <span class="comment">// httpOnly bool  是否允许别人通过js获取自己的cookie</span></span><br><span class="line">         c.SetCookie(<span class="string">"key_cookie"</span>, <span class="string">"value_cookie"</span>, <span class="number">60</span>, <span class="string">"/"</span>,</span><br><span class="line">            <span class="string">"localhost"</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">"cookie的值是： %s\n"</span>, cookie)</span><br><span class="line">   &#125;)</span><br><span class="line">   r.Run(<span class="string">":8000"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-Session"><a href="#9-2-Session" class="headerlink" title="9.2 Session"></a>9.2 Session</h3><p>Session建立在Cookie的基础上更加安全</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gorilla/sessions"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个cookie存储对象</span></span><br><span class="line"><span class="comment">// something-very-secret应该是一个你自己的密匙，只要不被别人知道就行</span></span><br><span class="line"><span class="keyword">var</span> store = sessions.NewCookieStore([]<span class="keyword">byte</span>(<span class="string">"something-very-secret"</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/save"</span>, SaveSession)</span><br><span class="line">    http.HandleFunc(<span class="string">"/get"</span>, GetSession)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"HTTP server failed,err:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveSession</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Get a session. We're ignoring the error resulted from decoding an</span></span><br><span class="line">    <span class="comment">// existing session: Get() always returns a session, even if empty.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//　获取一个session对象，session-name是session的名字</span></span><br><span class="line">    session, err := store.Get(r, <span class="string">"session-name"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在session中存储值</span></span><br><span class="line">    session.Values[<span class="string">"foo"</span>] = <span class="string">"bar"</span></span><br><span class="line">    session.Values[<span class="number">42</span>] = <span class="number">43</span></span><br><span class="line">    <span class="comment">// 保存更改</span></span><br><span class="line">    session.Save(r, w)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSession</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    session, err := store.Get(r, <span class="string">"session-name"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    foo := session.Values[<span class="string">"foo"</span>]</span><br><span class="line">    fmt.Println(foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、参数验证"><a href="#10、参数验证" class="headerlink" title="10、参数验证"></a>10、参数验证</h2><h3 id="10-1自定义验证"><a href="#10-1自定义验证" class="headerlink" title="10.1自定义验证"></a>10.1自定义验证</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin/binding"</span></span><br><span class="line">    <span class="string">"gopkg.in/go-playground/validator.v8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    对绑定解析到结构体上的参数，自定义验证功能</span></span><br><span class="line"><span class="comment">    比如我们要对 name 字段做校验，要不能为空，并且不等于 admin ，类似这种需求，就无法 binding 现成的方法</span></span><br><span class="line"><span class="comment">    需要我们自己验证方法才能实现 官网示例（https://godoc.org/gopkg.in/go-playground/validator.v8#hdr-Custom_Functions）</span></span><br><span class="line"><span class="comment">    这里需要下载引入下 gopkg.in/go-playground/validator.v8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Age <span class="keyword">int</span> <span class="string">`form:"age" binding:"required,gt=10"`</span></span><br><span class="line">    <span class="comment">// 2、在参数 binding 上使用自定义的校验方法函数注册时候的名称</span></span><br><span class="line">    Name    <span class="keyword">string</span> <span class="string">`form:"name" binding:"NotNullAndAdmin"`</span></span><br><span class="line">    Address <span class="keyword">string</span> <span class="string">`form:"address" binding:"required"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自定义的校验方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nameNotNullAndAdmin</span><span class="params">(v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> value, ok := field.Interface().(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">        <span class="comment">// 字段不能为空，并且不等于  admin</span></span><br><span class="line">        <span class="keyword">return</span> value != <span class="string">""</span> &amp;&amp; !(<span class="string">"5lmh"</span> == value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将我们自定义的校验方法注册到 validator中</span></span><br><span class="line">    <span class="keyword">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class="line">        <span class="comment">// 这里的 key 和 fn 可以不一样最终在 struct 使用的是 key</span></span><br><span class="line">        v.RegisterValidation(<span class="string">"NotNullAndAdmin"</span>, nameNotNullAndAdmin)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        curl -X GET "http://127.0.0.1:8080/testing?name=&amp;age=12&amp;address=beijing"</span></span><br><span class="line"><span class="comment">        curl -X GET "http://127.0.0.1:8080/testing?name=lmh&amp;age=12&amp;address=beijing"</span></span><br><span class="line"><span class="comment">        curl -X GET "http://127.0.0.1:8080/testing?name=adz&amp;age=12&amp;address=beijing"</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    r.GET(<span class="string">"/5lmh"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> person Person</span><br><span class="line">        <span class="keyword">if</span> e := c.ShouldBind(&amp;person); e == <span class="literal">nil</span> &#123;</span><br><span class="line">            c.String(http.StatusOK, <span class="string">"%v"</span>, person)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.String(http.StatusOK, <span class="string">"person bind err:%v"</span>, e.Error())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例二</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin/binding"</span></span><br><span class="line">    <span class="string">"gopkg.in/go-playground/validator.v8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Booking contains binded and validated data.</span></span><br><span class="line"><span class="keyword">type</span> Booking <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个预约的时间大于今天的时间</span></span><br><span class="line">    CheckIn time.Time <span class="string">`form:"check_in" binding:"required,bookabledate" time_format:"2006-01-02"`</span></span><br><span class="line">    <span class="comment">//gtfield=CheckIn退出的时间大于预约的时间</span></span><br><span class="line">    CheckOut time.Time <span class="string">`form:"check_out" binding:"required,gtfield=CheckIn" time_format:"2006-01-02"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bookableDate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value,</span></span></span><br><span class="line"><span class="function"><span class="params">    field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">//field.Interface().(time.Time)获取参数值并且转换为时间格式</span></span><br><span class="line">    <span class="keyword">if</span> date, ok := field.Interface().(time.Time); ok &#123;</span><br><span class="line">        today := time.Now()</span><br><span class="line">        <span class="keyword">if</span> today.Unix() &gt; date.Unix() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    route := gin.Default()</span><br><span class="line">    <span class="comment">//注册验证</span></span><br><span class="line">    <span class="keyword">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class="line">        <span class="comment">//绑定第一个参数是验证的函数第二个参数是自定义的验证函数</span></span><br><span class="line">        v.RegisterValidation(<span class="string">"bookabledate"</span>, bookableDate)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    route.GET(<span class="string">"/5lmh"</span>, getBookable)</span><br><span class="line">    route.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBookable</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b Booking</span><br><span class="line">    <span class="keyword">if</span> err := c.ShouldBindWith(&amp;b, binding.Query); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.JSON(http.StatusOK, gin.H&#123;<span class="string">"message"</span>: <span class="string">"Booking dates are valid!"</span>&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"error"</span>: err.Error()&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// curl -X GET "http://localhost:8080/5lmh?check_in=2019-11-07&amp;check_out=2019-11-20"</span></span><br><span class="line"><span class="comment">// curl -X GET "http://localhost:8080/5lmh?check_in=2019-09-07&amp;check_out=2019-11-20"</span></span><br><span class="line"><span class="comment">// curl -X GET "http://localhost:8080/5lmh?check_in=2019-11-07&amp;check_out=2019-11-01"</span></span><br></pre></td></tr></table></figure><h3 id="10-2多语言翻译验证"><a href="#10-2多语言翻译验证" class="headerlink" title="10.2多语言翻译验证"></a>10.2多语言翻译验证</h3><p>当业务系统对验证信息有特殊需求时，例如：返回信息需要自定义，手机端返回的信息需要是中文而pc端发挥返回的信息需要时英文，如何做到请求一个接口满足上述三种情况。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">    <span class="string">"github.com/go-playground/locales/en"</span></span><br><span class="line">    <span class="string">"github.com/go-playground/locales/zh"</span></span><br><span class="line">    <span class="string">"github.com/go-playground/locales/zh_Hant_TW"</span></span><br><span class="line">    ut <span class="string">"github.com/go-playground/universal-translator"</span></span><br><span class="line">    <span class="string">"gopkg.in/go-playground/validator.v9"</span></span><br><span class="line">    en_translations <span class="string">"gopkg.in/go-playground/validator.v9/translations/en"</span></span><br><span class="line">    zh_translations <span class="string">"gopkg.in/go-playground/validator.v9/translations/zh"</span></span><br><span class="line">    zh_tw_translations <span class="string">"gopkg.in/go-playground/validator.v9/translations/zh_tw"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    Uni      *ut.UniversalTranslator</span><br><span class="line">    Validate *validator.Validate</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Username <span class="keyword">string</span> <span class="string">`form:"user_name" validate:"required"`</span></span><br><span class="line">    Tagline  <span class="keyword">string</span> <span class="string">`form:"tag_line" validate:"required,lt=10"`</span></span><br><span class="line">    Tagline2 <span class="keyword">string</span> <span class="string">`form:"tag_line2" validate:"required,gt=1"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    en := en.New()</span><br><span class="line">    zh := zh.New()</span><br><span class="line">    zh_tw := zh_Hant_TW.New()</span><br><span class="line">    Uni = ut.New(en, zh, zh_tw)</span><br><span class="line">    Validate = validator.New()</span><br><span class="line"></span><br><span class="line">    route := gin.Default()</span><br><span class="line">    route.GET(<span class="string">"/5lmh"</span>, startPage)</span><br><span class="line">    route.POST(<span class="string">"/5lmh"</span>, startPage)</span><br><span class="line">    route.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startPage</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这部分应放到中间件中</span></span><br><span class="line">    locale := c.DefaultQuery(<span class="string">"locale"</span>, <span class="string">"zh"</span>)</span><br><span class="line">    trans, _ := Uni.GetTranslator(locale)</span><br><span class="line">    <span class="keyword">switch</span> locale &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"zh"</span>:</span><br><span class="line">        zh_translations.RegisterDefaultTranslations(Validate, trans)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"en"</span>:</span><br><span class="line">        en_translations.RegisterDefaultTranslations(Validate, trans)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"zh_tw"</span>:</span><br><span class="line">        zh_tw_translations.RegisterDefaultTranslations(Validate, trans)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        zh_translations.RegisterDefaultTranslations(Validate, trans)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义错误内容</span></span><br><span class="line">    Validate.RegisterTranslation(<span class="string">"required"</span>, trans, <span class="function"><span class="keyword">func</span><span class="params">(ut ut.Translator)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ut.Add(<span class="string">"required"</span>, <span class="string">"&#123;0&#125; must have a value!"</span>, <span class="literal">true</span>) <span class="comment">// see universal-translator for details</span></span><br><span class="line">    &#125;, <span class="function"><span class="keyword">func</span><span class="params">(ut ut.Translator, fe validator.FieldError)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        t, _ := ut.T(<span class="string">"required"</span>, fe.Field())</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这块应该放到公共验证方法中</span></span><br><span class="line">    user := User&#123;&#125;</span><br><span class="line">    c.ShouldBind(&amp;user)</span><br><span class="line">    fmt.Println(user)</span><br><span class="line">    err := Validate.Struct(user)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        errs := err.(validator.ValidationErrors)</span><br><span class="line">        sliceErrs := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, e := <span class="keyword">range</span> errs &#123;</span><br><span class="line">            sliceErrs = <span class="built_in">append</span>(sliceErrs, e.Translate(trans))</span><br><span class="line">        &#125;</span><br><span class="line">        c.String(<span class="number">200</span>, fmt.Sprintf(<span class="string">"%#v"</span>, sliceErrs))</span><br><span class="line">    &#125;</span><br><span class="line">    c.String(<span class="number">200</span>, fmt.Sprintf(<span class="string">"%#v"</span>, <span class="string">"user"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11、渲染"><a href="#11、渲染" class="headerlink" title="11、渲染"></a>11、渲染</h2><h3 id="11-1-各种数据格式的响应"><a href="#11-1-各种数据格式的响应" class="headerlink" title="11.1 各种数据格式的响应"></a>11.1 各种数据格式的响应</h3><p>json、结构体、XML、YAML类似于java的properties、ProtoBuf </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin/testdata/protoexample"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多种响应方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建路由</span></span><br><span class="line">    <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">    r := gin.Default()</span><br><span class="line">    <span class="comment">// 1.json</span></span><br><span class="line">    r.GET(<span class="string">"/someJSON"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">"message"</span>: <span class="string">"someJSON"</span>, <span class="string">"status"</span>: <span class="number">200</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 2. 结构体响应</span></span><br><span class="line">    r.GET(<span class="string">"/someStruct"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> msg <span class="keyword">struct</span> &#123;</span><br><span class="line">            Name    <span class="keyword">string</span></span><br><span class="line">            Message <span class="keyword">string</span></span><br><span class="line">            Number  <span class="keyword">int</span></span><br><span class="line">        &#125;</span><br><span class="line">        msg.Name = <span class="string">"root"</span></span><br><span class="line">        msg.Message = <span class="string">"message"</span></span><br><span class="line">        msg.Number = <span class="number">123</span></span><br><span class="line">        c.JSON(<span class="number">200</span>, msg)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 3.XML</span></span><br><span class="line">    r.GET(<span class="string">"/someXML"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.XML(<span class="number">200</span>, gin.H&#123;<span class="string">"message"</span>: <span class="string">"abc"</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 4.YAML响应</span></span><br><span class="line">    r.GET(<span class="string">"/someYAML"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.YAML(<span class="number">200</span>, gin.H&#123;<span class="string">"name"</span>: <span class="string">"zhangsan"</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 5.protobuf格式,谷歌开发的高效存储读取的工具</span></span><br><span class="line">    <span class="comment">// 数组？切片？如果自己构建一个传输格式，应该是什么格式？</span></span><br><span class="line">    r.GET(<span class="string">"/someProtoBuf"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        reps := []<span class="keyword">int64</span>&#123;<span class="keyword">int64</span>(<span class="number">1</span>), <span class="keyword">int64</span>(<span class="number">2</span>)&#125;</span><br><span class="line">        <span class="comment">// 定义数据</span></span><br><span class="line">        label := <span class="string">"label"</span></span><br><span class="line">        <span class="comment">// 传protobuf格式数据</span></span><br><span class="line">        data := &amp;protoexample.Test&#123;</span><br><span class="line">            Label: &amp;label,</span><br><span class="line">            Reps:  reps,</span><br><span class="line">        &#125;</span><br><span class="line">        c.ProtoBuf(<span class="number">200</span>, data)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run(<span class="string">":8000"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-HTML模板渲染"><a href="#11-2-HTML模板渲染" class="headerlink" title="11.2 HTML模板渲染"></a>11.2 HTML模板渲染</h3><p>gin支持加载HTML模板, 然后根据模板参数进行配置并返回相应的数据，本质上就是字符串替换</p><p>LoadHTMLGlob()方法可以加载模板文件（前后端分离使得前端的html渲染在这里没啥必要）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.LoadHTMLGlob(<span class="string">"tem/*"</span>)</span><br><span class="line">    r.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.HTML(http.StatusOK, <span class="string">"index.html"</span>, gin.H&#123;<span class="string">"title"</span>: <span class="string">"我是测试"</span>, <span class="string">"ce"</span>: <span class="string">"123456"</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;.title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        fgkjdskjdsh&#123;&#123;.ce&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果需要引入静态文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.Static(<span class="string">"/assets"</span>, <span class="string">"./assets"</span>)</span><br></pre></td></tr></table></figure><h3 id="11-3-同步异步"><a href="#11-3-同步异步" class="headerlink" title="11.3 同步异步"></a>11.3 同步异步</h3><p>goroutine机制可以方便地实现异步处理</p><p>另外，在启动新的goroutine时，不应该使用原始上下文，必须使用它的只读副本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建路由</span></span><br><span class="line">    <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">    r := gin.Default()</span><br><span class="line">    <span class="comment">// 1.异步</span></span><br><span class="line">    r.GET(<span class="string">"/long_async"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 需要搞一个副本</span></span><br><span class="line">        copyContext := c.Copy()</span><br><span class="line">        <span class="comment">// 异步处理</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">            log.Println(<span class="string">"异步执行："</span> + copyContext.Request.URL.Path)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 2.同步</span></span><br><span class="line">    r.GET(<span class="string">"/long_sync"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">        log.Println(<span class="string">"同步执行："</span> + c.Request.URL.Path)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run(<span class="string">":8000"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.liwenzhou.com/" target="_blank" rel="noopener">李文周的博客</a></p><p><a href="http://www.topgoer.com/" target="_blank" rel="noopener">topergoer</a></p><p><a href="https://gin-gonic.com/zh-cn/docs/" target="_blank" rel="noopener">gin框架官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gin框架&quot;&gt;&lt;a href=&quot;#gin框架&quot; class=&quot;headerlink&quot; title=&quot;gin框架&quot;&gt;&lt;/a&gt;gin框架&lt;/h1&gt;&lt;p&gt;写在前面的话，用好任何的工具都通用的方法—去查看官方文档&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gin-g
      
    
    </summary>
    
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go基础语法</title>
    <link href="http://yoursite.com/2020/02/17/go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/17/go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-02-17T12:47:16.000Z</published>
    <updated>2020-02-17T12:51:00.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go语言笔记"><a href="#go语言笔记" class="headerlink" title="go语言笔记"></a>go语言笔记</h1><h3 id="1对文件的操作"><a href="#1对文件的操作" class="headerlink" title="1对文件的操作"></a>1对文件的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fp, err :&#x3D; os.OpenFile(&quot;disdata.json&quot;, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0755)</span><br><span class="line">&#x2F;&#x2F;0755表示json中间的参数表示写入、创建、追加、</span><br><span class="line">&#x2F;&#x2F;对json文件的读写可以转为直接写字符串</span><br><span class="line"></span><br><span class="line">savedata,err :&#x3D; json.Marshal(data)</span><br><span class="line">if err!&#x3D;nil&#123;</span><br><span class="line">   fmt.Println(&quot;marshalerr&quot;,err)</span><br><span class="line">&#125;&#x2F;&#x2F;转为json会浪费大量时间</span><br><span class="line">_,err&#x3D;fp.Write(savedata)</span><br><span class="line">if (err!&#x3D;nil)&#123;</span><br><span class="line">fmt.Println(&quot;write_data&quot;,err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">save_data:&#x3D;[]byte(fmt.Sprintf(&quot;&#123;\&quot;Index\&quot;:%v,\&quot;Disdata\&quot;:%f&#125;&quot;,count,value))</span><br><span class="line">&#x2F;&#x2F;将数据利用fmt.Sprintf格式化为自己想要的数据利用[]byte强制转为字节数组</span><br><span class="line">_,err&#x3D;fp.Write(save_data)</span><br><span class="line">if (err!&#x3D;nil)&#123;</span><br><span class="line">fmt.Println(&quot;write_data&quot;,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2切片"><a href="#2切片" class="headerlink" title="2切片"></a>2切片</h3><p>数组的长度是固定的，切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。 </p><p>切片三要素</p><p>​    地址（%p)    长度（len）    容量（cap)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:&#x3D;[...]int&#123;1,3,5,6&#125;</span><br><span class="line">b:&#x3D;a[:]</span><br><span class="line">&#x2F;&#x2F;b和a的内存地址是一样，对b的元素进行更改同样会改变a的，切片的容量为，被切片的数组（或切片）的起始位置到结束位置，和截取到的个数无关</span><br></pre></td></tr></table></figure><p>使用copy（）函数复制切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切片的定义</span></span><br><span class="line"><span class="keyword">var</span> name []T</span><br><span class="line"><span class="comment">//使用make方法构造切片</span></span><br><span class="line"><span class="built_in">make</span>([]T, size, <span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">//对数组（切片）进行切片操作得到切片</span></span><br><span class="line">b:=a[:]</span><br></pre></td></tr></table></figure><p>当切片的容量够时用append方法扩充切片不会重新申请内存地址，即每次对切片添加元素，切片的内存地址不变。当容量不够会重新申请内存地址。每次重新申请会增加2 、4、 8（2^n）个容量</p><p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code></p><h3 id="3map类型"><a href="#3map类型" class="headerlink" title="3map类型"></a>3map类型</h3><p>map的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])<span class="comment">//make(map[String]int,3)定义了一个键是字符串类型值是int类型，容量为3的map类型</span></span><br></pre></td></tr></table></figure><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value, ok :&#x3D; map[key]</span><br><span class="line">&#x2F;&#x2F;如果存在就返回这个键对应的值和ok，反之则不返回</span><br></pre></td></tr></table></figure><p>map的遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for k,v :&#x3D;range mapname&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用delete删除键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(map,key)</span><br></pre></td></tr></table></figure><p>按照指定顺序遍历map</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano()) &#x2F;&#x2F;初始化随机数种子</span><br><span class="line"></span><br><span class="line">var scoreMap &#x3D; make(map[string]int, 200)</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; 100; i++ &#123;</span><br><span class="line">key :&#x3D; fmt.Sprintf(&quot;stu%02d&quot;, i) &#x2F;&#x2F;生成stu开头的字符串</span><br><span class="line">value :&#x3D; rand.Intn(100)          &#x2F;&#x2F;生成0~99的随机整数</span><br><span class="line">scoreMap[key] &#x3D; value</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;取出map中的所有key存入切片keys</span><br><span class="line">var keys &#x3D; make([]string, 0, 200)</span><br><span class="line">for key :&#x3D; range scoreMap &#123;</span><br><span class="line">keys &#x3D; append(keys, key)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;对切片进行排序</span><br><span class="line">sort.Strings(keys)</span><br><span class="line">&#x2F;&#x2F;按照排序后的key遍历map</span><br><span class="line">for _, key :&#x3D; range keys &#123;</span><br><span class="line">fmt.Println(key, scoreMap[key])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4函数"><a href="#4函数" class="headerlink" title="4函数"></a>4函数</h3><h4 id="4-1变量的作用域"><a href="#4-1变量的作用域" class="headerlink" title="4.1变量的作用域"></a>4.1变量的作用域</h4><p>全局变量定义在函数外部的变量，在整个运行周期内都有效，在函数内部也可访问</p><p>局部变量分两种 1函数内部定义的变量无法在函数外部使用，在函数内如果局部变量和全局变量冲突优先访问局部变量还有就</p><p>接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func testLocalVar2(x, y int) &#123;</span><br><span class="line">fmt.Println(x, y) &#x2F;&#x2F;函数的参数也是只在本函数中生效</span><br><span class="line">if x &gt; 0 &#123;</span><br><span class="line">z :&#x3D; 100 &#x2F;&#x2F;变量z只在if语句块生效</span><br><span class="line">fmt.Println(z)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;fmt.Println(z)&#x2F;&#x2F;此处无法使用变量z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有我们之前讲过的for循环语句中定义的变量，也是只在for语句块中生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func testLocalVar3() &#123;</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">fmt.Println(i) &#x2F;&#x2F;变量i只在当前for语句块中生效</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;fmt.Println(i) &#x2F;&#x2F;此处无法使用变量i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2定义函数类型"><a href="#4-2定义函数类型" class="headerlink" title="4.2定义函数类型"></a>4.2定义函数类型</h4><p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type calculation func(int, int) int</span><br></pre></td></tr></table></figure><p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p><p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func add(x, y int) int &#123;</span><br><span class="line">return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sub(x, y int) int &#123;</span><br><span class="line">return x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add和sub都能赋值给calculation类型的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var c calculation</span><br><span class="line">c &#x3D; add</span><br></pre></td></tr></table></figure><h4 id="4-3可变参数"><a href="#4-3可变参数" class="headerlink" title="4.3可变参数"></a>4.3可变参数</h4><p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数实例</span><br><span class="line">func intSum2(x ...int) int &#123;</span><br><span class="line">fmt.Println(x) &#x2F;&#x2F;x是一个切片</span><br><span class="line">sum :&#x3D; 0</span><br><span class="line">for _, v :&#x3D; range x &#123;</span><br><span class="line">sum &#x3D; sum + v</span><br><span class="line">&#125;</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;函数调用实例</span><br><span class="line">ret1 :&#x3D; intSum2()</span><br><span class="line">ret2 :&#x3D; intSum2(10)</span><br><span class="line">ret3 :&#x3D; intSum2(10, 20)</span><br><span class="line">ret4 :&#x3D; intSum2(10, 20, 30)</span><br><span class="line">fmt.Println(ret1, ret2, ret3, ret4) &#x2F;&#x2F;0 10 30 60</span><br></pre></td></tr></table></figure><p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum3</span><span class="params">(x <span class="keyword">int</span>, y ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(x, y)</span><br><span class="line">sum := x</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> y &#123;</span><br><span class="line">sum = sum + v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4匿名函数和闭包"><a href="#4-4匿名函数和闭包" class="headerlink" title="4.4匿名函数和闭包"></a>4.4匿名函数和闭包</h4><p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(参数)(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将匿名函数保存到变量</span></span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 通过变量调用匿名函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自执行函数：匿名函数定义完加()直接执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，<code>闭包=函数+引用环境</code>。 首先我们来看一个例子： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f = adder()</span><br><span class="line">fmt.Println(f(<span class="number">10</span>)) <span class="comment">//10</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//60</span></span><br><span class="line"></span><br><span class="line">f1 := adder()</span><br><span class="line">fmt.Println(f1(<span class="number">40</span>)) <span class="comment">//40</span></span><br><span class="line">fmt.Println(f1(<span class="number">50</span>)) <span class="comment">//90</span></span><br><span class="line">&#125;</span><br><span class="line">变量f是一个函数并且它引用了其外部作用域中的x变量，此时f就是一个闭包。 在f的生命周期内，变量x也一直有效</span><br></pre></td></tr></table></figure><h4 id="4-5defer"><a href="#4-5defer" class="headerlink" title="4.5defer"></a>4.5defer</h4><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。 </p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;start&quot;)</span><br><span class="line">defer fmt.Println(1)</span><br><span class="line">defer fmt.Println(2)</span><br><span class="line">defer fmt.Println(3)</span><br><span class="line">fmt.Println(&quot;end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="4-6内置函数介绍"><a href="#4-6内置函数介绍" class="headerlink" title="4.6内置函数介绍"></a>4.6内置函数介绍</h4><table><thead><tr><th>内置函数名</th><th>功能介绍</th></tr></thead><tbody><tr><td>close</td><td>主要用来关闭channel</td></tr><tr><td>len</td><td>用来求长度，比如string、array、slice、map、channel</td></tr><tr><td>new</td><td>用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td>make</td><td>用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td>append</td><td>用来追加元素到数组、slice中</td></tr><tr><td>panic和recover</td><td>用来做错误处理</td></tr></tbody></table><p>程序运行期间<code>funcB</code>中引发了<code>panic</code>导致程序崩溃，异常退出了。这个时候我们就可以通过<code>recover</code>将程序恢复回来，继续往后执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func funcA() &#123;</span><br><span class="line">fmt.Println(&quot;func A&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcB() &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">err :&#x3D; recover()</span><br><span class="line">&#x2F;&#x2F;如果程序出出现了panic错误,可以通过recover恢复过来</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;recover in B&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">panic(&quot;panic in B&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcC() &#123;</span><br><span class="line">fmt.Println(&quot;func C&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">funcA()</span><br><span class="line">funcB()</span><br><span class="line">funcC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><code>recover()</code>必须搭配<code>defer</code>使用。</li><li><code>defer</code>一定要在可能引发<code>panic</code>的语句之前定义。</li></ol><h3 id="5指针"><a href="#5指针" class="headerlink" title="5指针"></a>5指针</h3><p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p><p>要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。&amp;（取地址）*（根据地址取值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; 10</span><br><span class="line">b :&#x3D; &amp;a</span><br><span class="line">fmt.Printf(&quot;a:%d ptr:%p\n&quot;, a, &amp;a) &#x2F;&#x2F; a:10 ptr:0xc00001a078</span><br><span class="line">fmt.Printf(&quot;b:%p type:%T\n&quot;, b, b) &#x2F;&#x2F; b:0xc00001a078 type:*int %p取地址</span><br><span class="line">fmt.Println(&amp;b)                    &#x2F;&#x2F; 0xc00000e018（b储存的是a的指针地址，对变量b取地址得到的是a的指针值）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new与make的区别</p><ol><li>二者都是用来做内存分配的。</li><li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li><li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li></ol><h3 id="6结构体"><a href="#6结构体" class="headerlink" title="6结构体"></a>6结构体</h3><p>（取部分不清楚的做笔记）</p><h4 id="6-1匿名结构体"><a href="#6-1匿名结构体" class="headerlink" title="6.1匿名结构体"></a>6.1匿名结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var user struct&#123;Name string; Age int&#125;</span><br><span class="line"> user.Name &#x3D; &quot;小王子&quot;</span><br><span class="line"> user.Age &#x3D; 18</span><br></pre></td></tr></table></figure><h4 id="6-2创建指针类型的结构体"><a href="#6-2创建指针类型的结构体" class="headerlink" title="6.2创建指针类型的结构体"></a>6.2创建指针类型的结构体</h4><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p2 &#x3D; new(person)</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, p2)     &#x2F;&#x2F;*main.person</span><br><span class="line">fmt.Printf(&quot;p2&#x3D;%#v\n&quot;, p2) &#x2F;&#x2F;p2&#x3D;&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针。</p><p>需要注意的是在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。结构体中的键值对占用一块连续的内存地址</p><h4 id="6-3方法和接收者"><a href="#6-3方法和接收者" class="headerlink" title="6.3方法和接收者"></a>6.3方法和接收者</h4><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p><p>方法的定义格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">name: name,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Dream</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s的梦想是学好Go语言！\n"</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">"小王子"</span>, <span class="number">25</span>)</span><br><span class="line">p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><h4 id="6-4结构体的json序列化和反序列化"><a href="#6-4结构体的json序列化和反序列化" class="headerlink" title="6.4结构体的json序列化和反序列化"></a>6.4结构体的json序列化和反序列化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span></span><br><span class="line">data, err := json.Marshal(c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"json marshal failed"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-5结构体标签"><a href="#6-5结构体标签" class="headerlink" title="6.5结构体标签"></a>6.5结构体标签</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">int</span>    <span class="string">`json:"id"`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">Gender <span class="keyword">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">name   <span class="keyword">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7包package"><a href="#7包package" class="headerlink" title="7包package"></a>7包package</h3><p>我们还可以根据自己的需要创建自己的包。一个包可以简单理解为一个存放<code>.go</code>文件的文件夹。 该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package 包名</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>一个文件夹下面直接包含的文件只能归属一个<code>package</code>，同样一个<code>package</code>的文件不能在多个文件夹下。</li><li>包名可以不和文件夹的名字一样，包名不能包含 <code>-</code> 符号。</li><li>包名为<code>main</code>的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含<code>main</code>包的源代码则不会得到可执行文件。</li></ul><p>如果想在一个包中引用另外一个包里的标识符（如变量、常量、类型、函数等）时，该标识符必须是对外可见的（public）。在Go语言中只需要将标识符的首字母大写就可以让标识符对外可见了。</p><p>举个例子， 我们定义一个包名为<code>pkg2</code>的包，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包变量可见性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span> <span class="comment">// 首字母小写，外部包不可见，只能在当前包内使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首字母大写外部包可见，可在其他包中使用</span></span><br><span class="line"><span class="keyword">const</span> Mode = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123; <span class="comment">// 首字母小写，外部包不可见，只能在当前包内使用</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首字母大写，外部包可见，可在其他包中使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span> &#123; <span class="comment">// 首字母小写，外部包不可见，只能在当前包内使用</span></span><br><span class="line"><span class="keyword">var</span> Age = <span class="number">18</span> <span class="comment">// 函数局部变量，外部包不可见，只能在当前函数内使用</span></span><br><span class="line">fmt.Println(Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体中的字段名和接口中的方法名如果首字母都是大写，外部包可以访问这些字段和方法。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="keyword">string</span> <span class="comment">//可在包外访问的方法</span></span><br><span class="line">class <span class="keyword">string</span> <span class="comment">//仅限包内访问的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Payer <span class="keyword">interface</span> &#123;</span><br><span class="line">init() <span class="comment">//仅限包内访问的方法</span></span><br><span class="line">Pay()  <span class="comment">//可在包外访问的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1重要init-初始化函数"><a href="#7-1重要init-初始化函数" class="headerlink" title="7.1重要init()初始化函数"></a>7.1重要init()初始化函数</h4><p> <code>init()</code>函数没有参数也没有返回值。 <code>init()</code>函数在程序运行时自动被调用执行，不能在代码中主动调用它。 </p><p>init函数的执行时机</p><p><img src="C:%5CUsers%5C14756%5CAppData%5CLocal%5CTemp%5C1575890691437.png" alt="1575890691437"></p><h3 id="8接口"><a href="#8接口" class="headerlink" title="8接口"></a>8接口</h3><p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。 接口是一种类型（一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个<strong>需要实现的方法列表</strong>。 ）</p><p>（接口就是个招牌。</p><p>比如说你今年放假出去杭州旅游，玩了一上午，你也有点饿了，突然看到前面有个店子，上面挂着KFC，然后你就知道今天中饭有着落了。</p><p>KFC就是接口，我们看到了这个接口，就知道这个店会卖炸鸡腿（实现接口）。</p><p>那么为神马我们要去定义一个接口涅，这个店可以直接卖炸鸡腿啊（直接写实现方法），是的，这个店可以直接卖炸鸡腿，但没有挂KFC的招牌，我们就不能直接简单粗暴的冲进去叫服务员给两个炸鸡腿了。）</p><p>Go语言提倡面向接口编程。</p><p>每个接口由数个方法组成，接口的定义格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type 接口类型名 interface&#123;</span><br><span class="line">    方法名1( 参数列表1 ) 返回值列表1</span><br><span class="line">    方法名2( 参数列表2 ) 返回值列表2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值接收者和指针接收者实现接口的区别</p><p>使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。</p><p>我们有一个<code>Mover</code>接口和一个<code>dog</code>结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>值接收者实现接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"狗会动"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现接口的是<code>dog</code>类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Mover</span><br><span class="line"><span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">x = wangcai         <span class="comment">// x可以接收dog类型</span></span><br><span class="line"><span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针*dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针<code>fugui</code>内部会自动求值。</p><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。 空接口类型的变量可以存储任意类型的变量。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义一个空接口x</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">s := <span class="string">"Hello 沙河"</span></span><br><span class="line">x = s</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">i := <span class="number">100</span></span><br><span class="line">x = i</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">b := <span class="literal">true</span></span><br><span class="line">x = b</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空接口的应用</p><p>空接口作为函数的参数使用空接口实现可以接收任意类型的函数参数。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空接口作为map的值，使用空接口实现可以保存任意值的字典。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line"><span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">studentInfo[<span class="string">"name"</span>] = <span class="string">"沙河娜扎"</span></span><br><span class="line">studentInfo[<span class="string">"age"</span>] = <span class="number">18</span></span><br><span class="line">studentInfo[<span class="string">"married"</span>] = <span class="literal">false</span></span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure><h3 id="9反射（暂时跳过）"><a href="#9反射（暂时跳过）" class="headerlink" title="9反射（暂时跳过）"></a>9反射（暂时跳过）</h3><p>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。<br>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。<br> Go程序在运行期使用reflect包访问程序的反射信息。 </p><h3 id="10并发"><a href="#10并发" class="headerlink" title="10并发"></a>10并发</h3><p>并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。</p><p>并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。</p><h4 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h4><p><strong>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程</strong>，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p><p><strong>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。</strong> </p><p>Go语言还提供<code>channel</code>（通道）在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p><p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p><p>goroutine与线程</p><p>Go语言中的操作系统线程和goroutine的关系：</p><ol><li>一个操作系统线程对应用户态多个goroutine。</li><li>go程序可以同时使用多个操作系统线程。</li><li>goroutine和OS线程是多对多的关系，即m:n。</li></ol><h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>无缓冲通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//无缓冲的通道只有在有人接收值的时候才能发送值</span></span><br></pre></td></tr></table></figure><p>有缓冲的通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br></pre></td></tr></table></figure><p><strong>单向通道</strong>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">out &lt;- i * i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//chan&lt;- int是一个只能发送的通道，可以发送但是不能接收；</span></span><br><span class="line"><span class="comment">//&lt;-chan int是一个只能接收的通道，可以接收但是不能发送。</span></span><br></pre></td></tr></table></figure><h4 id="worker-pool（goroutine池）"><a href="#worker-pool（goroutine池）" class="headerlink" title="worker pool（goroutine池）"></a>worker pool（goroutine池）</h4><p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。 （没搞懂）</p><h4 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a><strong>select多路复用</strong></h4><p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会使用遍历的方式来实现 但是效率很低</p><p>在go中使用select</p><p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">fmt.Println(x)</span><br><span class="line"><span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">            fmt.Println(<span class="string">"填充完毕"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//填充完毕</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//填充完毕</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//填充完毕</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//填充完毕</span></span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//填充完毕</span></span><br><span class="line"><span class="comment">//8</span></span><br></pre></td></tr></table></figure><p>使用<code>select</code>语句能提高代码的可读性。</p><ul><li>可处理一个或多个channel的发送/接收操作。</li><li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li><li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数。</li></ul><h4 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h4><p>有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。 </p><p><strong>1、互斥锁</strong></p><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面<code>竞态问题</code>（数据竞态）的问题： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">lock.Lock() <span class="comment">// 加锁</span></span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。 </p><p><strong>2、读写互斥锁</strong></p><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p><p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x      <span class="keyword">int64</span></span><br><span class="line">wg     sync.WaitGroup</span><br><span class="line">lock   sync.Mutex</span><br><span class="line">rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// lock.Lock()   // 加互斥锁</span></span><br><span class="line">rwlock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">rwlock.Unlock()                   <span class="comment">// 解写锁</span></span><br><span class="line"><span class="comment">// lock.Unlock()                     // 解互斥锁</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// lock.Lock()                  // 加互斥锁</span></span><br><span class="line">rwlock.RLock()               <span class="comment">// 加读锁</span></span><br><span class="line">time.Sleep(time.Millisecond) <span class="comment">// 假设读操作耗时1毫秒</span></span><br><span class="line">rwlock.RUnlock()             <span class="comment">// 解读锁</span></span><br><span class="line"><span class="comment">// lock.Unlock()                // 解互斥锁</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> read()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">end := time.Now()</span><br><span class="line">fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sync.WaitGroup</strong></p><p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法： </p><table><thead><tr><th align="left">方法名</th><th>功能</th></tr></thead><tbody><tr><td align="left"><code>(wg * WaitGroup) Add(delta int)</code></td><td>计数器+delta</td></tr><tr><td align="left"><code>(wg *WaitGroup) Done()</code></td><td>计数器-1</td></tr><tr><td align="left"><code>(wg *WaitGroup) Wait()</code></td><td>阻塞直到计数器变为0</td></tr></tbody></table><p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。 </p><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源 </p><p>当子goroutine又开启另外一个goroutine时，只需要将ctx传入即可： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> worker2(ctx)</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 等待上级通知</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker2"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 等待上级通知</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(ctx)</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">cancel() <span class="comment">// 通知子goroutine结束</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>context类型专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。 对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用<code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code>或<code>WithValue</code>创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;go语言笔记&quot;&gt;&lt;a href=&quot;#go语言笔记&quot; class=&quot;headerlink&quot; title=&quot;go语言笔记&quot;&gt;&lt;/a&gt;go语言笔记&lt;/h1&gt;&lt;h3 id=&quot;1对文件的操作&quot;&gt;&lt;a href=&quot;#1对文件的操作&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb基础</title>
    <link href="http://yoursite.com/2020/02/16/JavaWeb%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/02/16/JavaWeb%E5%9F%BA%E7%A1%80/</id>
    <published>2020-02-16T08:28:46.000Z</published>
    <updated>2020-02-16T10:51:37.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、web相关概念"><a href="#1、web相关概念" class="headerlink" title="1、web相关概念"></a>1、web相关概念</h2><p>1.软件架构</p><p>​    1、C/S：客户端/服务器端</p><p>​    2、B/S:浏览器/服务器端</p><p>2.资源分类</p><p>​    1、静态资源：所有用户访问后，得到的结果都是一样的，可以直接被浏览器解析<br>        *如：html css js</p><p>​    2、动态资源：每个用户访问相同资源后，得到的结果可能不一样 。被访问之后需要先转换为静态资源再返回给浏览器</p><p>​        *如：servlet/jsp，php，asp</p><p>3.网络通信三要素</p><p>​    1、IP：电子设备（计算机）在网络中的唯一标识</p><p>​    2、端口：应用程序在计算机中的唯一标识。0~65536</p><p>​    3、传输协议：规定了数据传输规则</p><p>​        1、基本协议：</p><p>​            1、tcp：安全协议，三次握手。速度稍慢</p><p>​            2、udp：不安全协议。速度快</p><h2 id="2、web服务器软件"><a href="#2、web服务器软件" class="headerlink" title="2、web服务器软件"></a>2、web服务器软件</h2><p>*服务器软件：接收用户的请求，处理请求做出响应</p><p>​    *web服务器软件（web容器） 可以部署web项目，让用户通过浏览器来访问这些项目</p><p>常见java相关web容器</p><p>​    webSpher，JBOSS，webLogic :大型JavaEE服务器，支持所有JavaEE规范，收费</p><p>​    Tomcat:Apache 基金组织，中小型JavaEE服务器，支持少量JavaEE规范servlet/jsp 开源免费</p><h2 id="3、Tomcat与servlet"><a href="#3、Tomcat与servlet" class="headerlink" title="3、Tomcat与servlet"></a>3、Tomcat与servlet</h2><h3 id="3-1、目录详解"><a href="#3-1、目录详解" class="headerlink" title="3.1、目录详解"></a>3.1、目录详解</h3><p>bin：可执行文件</p><p>conf：配置文件</p><p>lib：依赖jar包</p><p>logs：日志文件（监控、调试项目）</p><p>temp：临时文件</p><p>webapps：存放web项目</p><p>work：存放运行时的数据</p><h3 id="3-2、启动"><a href="#3-2、启动" class="headerlink" title="3.2、启动"></a>3.2、启动</h3><p>：在bin文件夹下双击startup.bat(win系统下)或者startup.sh(linux系统下)</p><p>出现的问题，1.黑窗口一闪而过：java环境变量出错</p><p>​            2.启动报错，看日志。如果端口冲突</p><p>​                1.关闭占用端口的服务</p><p>​                        *netstat -ano(找到占用端口的pid去任务管理器关闭)<br>                2.修改自身端口号conf目录/server.xml编辑将port（多个）改成自己喜欢的</p><p>​                    //一般会将tomcat默认端口号改为80，80端口是http协议的默认端口号（在访问时可以不用输入端口号）</p><h3 id="3-3、关闭"><a href="#3-3、关闭" class="headerlink" title="3.3、关闭"></a>3.3、关闭</h3><p>：强制关闭点击x，正常关闭bin/shutdown 或者ctrl+c</p><h3 id="3-4、配置"><a href="#3-4、配置" class="headerlink" title="3.4、配置"></a>3.4、配置</h3><h4 id="3-4-1部署项目方式"><a href="#3-4-1部署项目方式" class="headerlink" title="3.4.1部署项目方式"></a>3.4.1部署项目方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.直接将项目放到webapps目录下</span><br><span class="line"></span><br><span class="line">简化部署 将项目打包成war包，再将war包放置到webapps目录下 war包会自动解压</span><br><span class="line"></span><br><span class="line">2.配置conf&#x2F;server.xml文件</span><br><span class="line"></span><br><span class="line">在&lt;Host&gt;标签体中配置 (docBase:项目存放的路径 path：虚拟目录）</span><br><span class="line"></span><br><span class="line">&lt;Context docBase&#x3D;&quot;D:\java_project&quot; path&#x3D;&quot;&#x2F;dafnas&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">3.在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写&lt;Context docBase&#x3D;&quot;D:\java_project&quot;&gt;</span><br><span class="line"></span><br><span class="line">虚拟目录就是xml文件的名称（）热部署</span><br></pre></td></tr></table></figure><h4 id="3-4-2静态项目和动态项目"><a href="#3-4-2静态项目和动态项目" class="headerlink" title="3.4.2静态项目和动态项目"></a>3.4.2静态项目和动态项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">目录结构</span><br><span class="line"></span><br><span class="line">Java动态项目的目录结构</span><br><span class="line">项目的根目录</span><br><span class="line"></span><br><span class="line">WEB-INF目录</span><br><span class="line"></span><br><span class="line">web.xml:web项目的核心配置文件</span><br><span class="line"></span><br><span class="line">classes目录：放置字节码文件的目录</span><br><span class="line"></span><br><span class="line">lib目录：放置依赖的jar包</span><br></pre></td></tr></table></figure><h3 id="3-5、将tomcat集成到idea里面，并创建javaEE项目，部署项目"><a href="#3-5、将tomcat集成到idea里面，并创建javaEE项目，部署项目" class="headerlink" title="3.5、将tomcat集成到idea里面，并创建javaEE项目，部署项目"></a>3.5、将tomcat集成到idea里面，并创建javaEE项目，部署项目</h3><p><a href="https://www.bilibili.com/video/av74401737?p=9" target="_blank" rel="noopener">https://www.bilibili.com/video/av74401737?p=9</a></p><h3 id="3-6、Servlet：server-applet"><a href="#3-6、Servlet：server-applet" class="headerlink" title="3.6、Servlet：server applet"></a>3.6、Servlet：server applet</h3><p> （运行在服务器端的小程序）Servlet就是一个接口，定义了java类被浏览器访问到（tomcat识别）的规则</p><p>将来我们自定义一个类，实现servlet接口，复写方法</p><ul><li><p>快速入门</p><p>1、创建JavaEE项目</p><p>2、定义一个类，实现servlet接口</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class ServletDemo1 implements  Servlet</span><br></pre></td></tr></table></figure><p>  3、实现接口中的抽象方法</p><p>  4、配置servlet在web.xml中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.iteast.web.servlet.ServletDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  5、执行原理</p><ul><li><p>```</p><ul><li><p>当服务器接受到客户端浏览器的请求后，会解析请求url路径，获取访问的servlet的资源路径</p></li><li><p>查看web.xml文件，是否有对应的<url-pattern>标签体内容</p></li><li><p>如果有，则找到对应的<servlet-class>全类名</p></li><li><p>tomcat会将字节码文件加载进内存，并创建其对象</p></li><li><p>调用其方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">![1576843561466](C:\Users\14756\AppData\Local\Temp\1576843561466.png)</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure><p>7、servlet生命周期</p></li><li><p>1、被创建 ：执行init方法，只执行一次</p><p>   servlet的init方法，只能执行一次，说明一个servlet在内存只存在一个对象，Servlet是单例的</p><ul><li><p>多个用户同时访问时，可能存在线程安全问题</p></li><li><p>解决尽量不要再servlet中定义成员变量，多用局部变量。即使定义了成员变量，也不要对修改值</p></li><li><p>Servlet什么时候被创建？</p></li><li><p>默认情况下，第一次被访问时，servlet被创建</p></li><li><p>可以配置指定servlet的创建时机在<servlet>标签下配置</p></li></ul><!--指定Servlet的创建时机    1.第一次被访问时创建<load-on-startup>的值为负数    2.在服务器启动时创建<load-on-startup>的值为正整数--><ul><li><p>2、提供服务 ：执行service方法，执行多次，每次访问调用一次</p></li><li><p>3、被销毁：执行destroy方法 只有服务器正常关闭时才会执行（在销毁之前执行用于释放资源）</p></li></ul><p>8、servlet3.0</p><p>1、创建JavaEE项目</p><p>2、定义一个类，实现servlet接口</p><p>3、实现接口中的抽象方法</p><p>4、注解配置（不需要在web.xml）直接再servlet类的前面加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​```</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>​<code>java@WebServlet(&quot;/demo3&quot;)​</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.7、idea与tomcat的相关配置</span><br><span class="line"></span><br><span class="line">2、工作空间项目和tomcat部署的web项目</span><br><span class="line"></span><br><span class="line"> tomcat真正访问的时tomcat部署的web项目，tomcat部署的web项目对应着工作空间项目的web目录下的所     有资源</span><br><span class="line"></span><br><span class="line">​WEB-INF目录下的资源不能被浏览器直接访问</span><br><span class="line"></span><br><span class="line">​断点调试打断点，然后点debug运行</span><br><span class="line"></span><br><span class="line">1、idea会为每个tomcat部署的项目单独建立一个配置文件</span><br><span class="line"></span><br><span class="line">- 查看控制台的log：</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure><p>Using CATALINA_BASE:”C:\Users\14756.IntelliJIdea2018.2\system\tomcat\Tomcat_8_5_50_tomcatTest”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.8、Servlet的体系结构</span><br><span class="line"></span><br><span class="line">​GenericServlet --抽象类</span><br><span class="line"></span><br><span class="line">- GenericServlet :将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象</span><br><span class="line"></span><br><span class="line">  ​将来定义servlet类时，可以继承GeneriServlet。实现service()方法</span><br><span class="line"></span><br><span class="line">   HttpServlet--抽象类(对http协议的一种简化操作)</span><br><span class="line"></span><br><span class="line">  1、定义类继承HttpServlet</span><br><span class="line"></span><br><span class="line">  2、复写doGet&#x2F;doPost方法</span><br></pre></td></tr></table></figure><p>@WebServlet(“/demo4”)<br>public class ServletDemo4 extends HttpServlet{<br>@Override<br>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>  System.out.println(“doGet”);<br>  //super.doGet(req, resp);<br>}</p><p>@Override<br>protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>  //super.doPost(req, resp);<br>  System.out.println(“doPost”);<br>}<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><form action="/servletdemo/demo4"method="post"><input name="username"><input type="submit" value="提交"></form><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.9、servlet的相关配置</span><br><span class="line"></span><br><span class="line">1、urlpartten : Servlet访问路径：</span><br><span class="line"></span><br><span class="line">​1、webServlet(&#123;&quot;&#x2F;xl&quot;,&quot;&#x2F;xxl&quot;,&quot;&#x2F;xxxl&quot;&#125;) &#x2F;&#x2F;即同一个servlet可以用多个路径访问</span><br><span class="line"></span><br><span class="line">​2、路径定义规则（1）&#x2F;xx （2）&#x2F;xx&#x2F;yy （3）*.do</span><br><span class="line"></span><br><span class="line">## 4、http协议</span><br><span class="line"></span><br><span class="line">### 4.1、基础知识：</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>4.1.1、基本概念</p><p>超文本传输协议（1）基于tcp/ip的高级协议（2）默认端口号80（3）基于请求/响应模型的：一次请求对应一次响应（4）无状态：每次请求相互独立，不能交互数据</p><p>4.1.2、历史版本</p><pre><code>1.0 每次请求都会建立新的连接1.1 会复用连接</code></pre><p>4.1.3、请求消息数据格式</p><ul><li><p>请求行<br>请求方式         请求url    请求协议/版本<br>GET    /login.html HTTP/1.1</p><ul><li><p>请求方式 </p><ul><li><p>HTTP中的请求方式7种常用两种</p><ul><li><p>GET<br>请求参数在请求行中，在url后  例 ？username=zhangsan<br>请求的url长度有限制</p></li><li><p>POST<br>请求参数在请求体中</p><p>请求的url没有限制</p></li></ul></li></ul></li></ul></li><li><p>请求头<br>请求头名称：请求值1，请求值2</p><p>常见请求头</p><pre><code>1、User-Agent:浏览器告诉服务器，我访问你使用的浏览器版本信息    可以在服务器端根据浏览器信息解决兼容性问题2、Referer：告诉服务器我（当前请求）我从哪里来    （1）防盗链（从我付费用户来的才给资源）    （2）统计数据</code></pre></li><li><p>请求空行<br>空行 用于分割post的请求头和请求体的</p></li><li><p>请求体（正文）<br>用POST之类的方法发送的正文</p><p>封装post请求参数</p></li></ul><p>字符串格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>GET    /login.html HTTP/1.1                                                     ####请求行<br>Host: localhost:8080                                                #######从这行开始请求头<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br>Accept-Encoding: gzip, deflate<br>Connection: keep-alive<br>Cookie: Idea-a01f8499=dec260fd-41c1-4532-a9f3-c79fd43b63eb<br>Upgrade-Insecure-Requests: 1<br>If-Modified-Since: Fri, 20 Dec 2019 14:28:42 GMT<br>If-None-Match: W/“275-1576852122365”<br>Cache-Control: max-age=0<br>                                                                        #######请求空行<br>username=sdgs                                                            #########请求体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4.1.4、响应消息的数据格式</span><br><span class="line"></span><br><span class="line">### 4.2、servlet Request</span><br></pre></td></tr></table></figure><p>ServletRequest                    –接口<br>|继承<br>HttpServletRequest            –接口<br>|实现<br>org.apache.catalina.commector.RequestFacde类（tomcat）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 4.2.1、request对象的功能</span><br><span class="line"></span><br><span class="line">##### 4.2.1.1.获取请求消息数据</span><br></pre></td></tr></table></figure><pre><code>4.2.1.1.1获取请求头数据    GET /servletdemo?name=zhangsan HTTP/1.1    (1)获取请求方式GET/POST        String    getMethod()</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String method = request.getMethod(); </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>    (2)获取虚拟目录：/servletdemo        String    getContextPath()    (3)获取Servlet路径：/demo1           String    getServletPath()    (4)获取get方式请求参数 name=zhangsan        String    getQueryString()    (5)获取请求URI：/servletdemo/demo1        String    getRequestURI()        /servlet/demo        StringBuffer    getRequestURI()        http://localhost/servlet/demo1    (6)获取协议及版本：HTTP1.1        String    getProtocol()    (7)获取客户机的IP地址        String    getRemoteAddr() 4.2.1.1.2、获取请求头数据    (1)通过请求头名称获取请求头的值        String    getHeader(String name)      （2）获取所有请求头名称        Enumberation&lt;String&gt;    getHeaderNames();</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//获取所有请求头名称<br>Enumberation<String> headerNames = request.getHeaderNames();<br>//遍历<br>while(headerNames.hasMoreElements()){<br>    String name = headerNames.nextElement();<br>    //根据名称获取请求头的值<br>    String value = request.getHeader(name);<br>    System.out.println(name+”—“+value)<br>}<br>//根据名称获取请求头的值<br>String agent = request.getHeader(“user-agent”);<br>if (agent.contains(“Chrome”)){<br>    System.out.println(“谷歌浏览器”)<br>}else if(agent.contains(“Firefox”)){<br>    System.out.println(“火狐浏览器”)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.2.1.1.3、获取请求体数据<br>只有post请求方式才有请求体，在请求体中封装了post请求参数<br>步骤：<br>    （1）获取流对象<br>        BufferedReader        getReader()        获取字符输入流，只能操作字符数据<br>        ServletInputStream    getInputStream()    获取字节输入流，能操作所有类型数据<br>    （2）再从流对象中拿数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>BufferedReader br = request.getReader();<br>br.readline()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 4.2.1.1.2、其他功能</span><br></pre></td></tr></table></figure><pre><code>(1)获取请求参数的通用方式    1.String    getParameter(String name)：跟据参数名称获取参数值        username=zan&amp;password=123    2.string[]  getParameterValues(String name):根据参数名称获取参数值的数组        hobby=xx&amp;hobby=game    3.Enumeration&lt;string&gt;    getParameterNames() 获取所请求的参数名称    4.Map&lt;string,string[]&gt;    getParameterMap()获取所有参数的map集合</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>* 乱码问题</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>get方式在tomcat8已经将get方式解决<br>post方式会乱码在获取参数前，设置request的编码request.setCharacterEncoding(“utf-8”);</p><pre><code>(2）请求转发    1.步骤        1.通过request对象获取请求转发对象：RequestDispatcher    getReaquestDispatcher(String Path)        2.使用RequestDispatcher对象进行转发：forward(ServletRequest request,ServletResponse reponse)    2.特点：        1.浏览器地址路径不发生变化        2.只能转发到当前服务器内部资源        3.转发是一次请求  （3）共享数据    域对象：一个有作用范围的对象，可以在范围内共享数据    request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据    方法        void setAttribute(String name ,Object obj)         存储数据        Object getAttribute(String name )                通过键获取值        removeAttribute(String name)                    通过键移除值  （4）获取ServletContext</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4.2 response</span><br></pre></td></tr></table></figure><p>1、重定向：访问servletDemo1会自动跳转到servletDemo2资源<br>    （1）设置状态码为302<br>        response.setStatus(302);<br>    （2）设置相应头location<br>        response.setHeader(“location”,”/cong/servletDemo2);<br>    //直接简单版重定向<br>        response.sendRedirect(“/cong/servletDemo3”);<br>重定向和转发<br>    转发forward<br>    （1）地址栏不变<br>    （2）转发只能访问当前服务器的资源<br>    （3）转发是一次请求<br>    重定向redirect<br>    （1）地址栏改变<br>    （2）可以访问其他站点（服务器）<br>    （3）重定向是两次请求，不能使用request对象来共享数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4.3 ServletContext</span><br></pre></td></tr></table></figure><p>概念：代表整个web项目，可以用来和容器（服务器）通信<br>获取：request.getServletContext();通过HttpServlet获取this.getServletContext();<br>功能：<br>    （1）获取MIME类型<br>        *MIME类型 :在互联网通信过程中定义的一种文件数据类型<br>            *格式：大类型/小类型    —–text/html<br>            获取：String getMimeType(String file)<br>    （2）域对象：共享数据<br>        1.setAttribute(String name,Object value)<br>        2.getAttribute(String name)<br>        3.removeAttribute(String name)<br>        *ServletContext对象范围：所有用户的所有请求的数据<br>    （3）获取文件的真实（服务器）路径（这个项目运行的真实路径）<br>        context.getRealPath(“/WEB_INF/c.txt”)//WEB-INF目录下资源访问<br>        context.getRealPath(“/b.txt”)//web目录下资源访问<br>        context.getRealPath(“/WEB_INF/class/a.txt”);src下的目录下的资源路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4.4 文件下载案例</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5、登录案例</span><br></pre></td></tr></table></figure><p>-src<br>    -cn.cong<br>        -dao//这个包主要是操作数据库的java类，例如UserDao.java（指操作User表的类）<br>        -domain//主类的方法包一般为get,set方法（自己理解的可能有误）<br>        -util//工具类的存放包，经常复用的函数之类<br>        -web.servlet//被实现的各种servlet接口<br>-web//jsp页面或者html页面的存放地点<br>    -WEB-INF//<br>        -lib//存放jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需求<br>    1、编写login.html登录界面<br>        username &amp; password 两个输入框<br>    2、使用Druid数据库连接池技术，操作mysql，logindemo数据库中的user表<br>    3、使用jdbcTemplate技术封装JDBC<br>    4、登录成功跳转到SuccessServlet展示：登录成功！用户名，欢迎你<br>    5、登录失败跳转到FailServlet展示：登录失败，用户名或密码错误</p><p>步骤：<br>    1、创建java项目，导入html 导入jar包<br>    2、创建数据库环境<br>    3、创建包cn.cong.domain,创建User类<br>    4、创建包cn.cong.dao,创建UserDao类提供login方法（dao操作数据库的包）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>package cn.cong.domain;</p><p>public class User {<br>    private int id;<br>    private String username;<br>    private String password;</p><pre><code>public int getId() {    return id;}public void setId(int id) {    this.id = id;}public String getUsername() {    return username;}public void setUsername(String username) {    this.username = username;}public String getPassword() {    return password;}@Overridepublic String toString(){    return &quot;User{&quot;+            &quot;id=&quot;+id+            &quot;,username=&quot;+username +&apos;\&apos;&apos;+            &quot;,password=&quot;+password +&apos;\&apos;&apos;+            &quot;}&quot;;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>package web.servlet;</p><p>import cn.cong.dao.UserDao;<br>import cn.cong.domain.User;</p><p>import javax.servlet.ServletException;<br>import javax.servlet.annotation.WebServlet;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>import java.io.IOException;</p><p>@WebServlet(“/loginServlet”)<br>public class LoginServlet extends HttpServlet {<br>    @Override<br>    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>        super.doPost(req, resp);<br>    }</p><pre><code>@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    // super.doGet(req, resp);    //1设置编码    req.setCharacterEncoding(&quot;utf-8&quot;);    //2获取请求参数    String username = req.getParameter(&quot;username&quot;);    String password = req.getParameter(&quot;password&quot;);    //3封装user对象    User loginUser = new User();    loginUser.setUsername(username);    loginUser.setPassword(password);    //4调用UserDao的login方法    UserDao dao = new UserDao();    User user=dao.login(loginUser);    if(user!=null){        //登录成功转发到另一个servlet里面        req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp);        //存储数据        req.setAttribute(&quot;user&quot;,user);    }else {        //登录失败 转发到另一个servlet里面        req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp);    }   // super.doPost(req, resp);}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 6、Cookie和Session</span><br><span class="line"></span><br><span class="line">### 6.1 会话技术</span><br></pre></td></tr></table></figure><ol><li>会话：一次会话中包含多次请求和响应。<ul><li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</li></ul></li><li>功能：在一次会话的范围内的多次请求间，共享数据</li><li>方式：<ol><li>客户端会话技术：Cookie</li><li>服务器端会话技术：Session</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 6.2 Cookie</span><br></pre></td></tr></table></figure><ol><li><p>概念：客户端会话技术，将数据保存到客户端</p></li><li><p>快速入门：</p><ul><li>使用步骤：<ol><li>创建Cookie对象，绑定数据<ul><li>new Cookie(String name, String value) </li></ul></li><li>发送Cookie对象<ul><li>response.addCookie(Cookie cookie) </li></ul></li><li>获取Cookie，拿到数据<ul><li>Cookie[]  request.getCookies()  </li></ul></li></ol></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li><p>实现原理</p><ul><li>基于响应头set-cookie和请求头cookie实现</li></ul></li><li><p>cookie的细节</p><ol><li><p>一次可不可以发送多个cookie?</p><ul><li>可以</li><li>可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。</li></ul></li><li><p>cookie在浏览器中保存多长时间？</p><ol><li>默认情况下，当浏览器关闭后，Cookie数据被销毁</li><li>持久化存储：<ul><li>setMaxAge(int seconds)<ol><li>正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效</li><li>负数：默认值</li><li>零：删除cookie信息</li></ol></li></ul></li></ol></li><li><p>cookie能不能存中文？</p><ul><li>在tomcat 8 之前 cookie中不能直接存储中文数据。<ul><li>需要将中文数据转码—一般采用URL编码(%E3)</li></ul></li><li>在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析</li></ul></li><li><p>cookie共享问题？</p><ol><li><p>假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？</p><ul><li><p>默认情况下cookie不能共享</p></li><li><p>setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录</p><ul><li>如果要共享，则可以将path设置为”/“</li></ul></li></ul></li><li><p>不同的tomcat服务器间cookie共享问题？</p><ul><li>setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享<ul><li>setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</li></ul></li></ul></li></ol></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li><p>Cookie的特点和作用</p><ol><li>cookie存储数据在客户端浏览器</li><li>浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)</li></ol><ul><li>作用：<ol><li>cookie一般用于存出少量的不太敏感的数据</li><li>在不登录的情况下，完成服务器对客户端的身份识别</li></ol></li></ul></li><li><p>案例：记住上一次访问时间</p><ol><li><p>需求：</p><ol><li>访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。</li><li>如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串</li></ol></li><li><p>分析：</p><ol><li>可以采用Cookie来完成</li><li>在服务器中的Servlet判断是否有一个名为lastTime的cookie<ol><li>有：不是第一次访问<ol><li>响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20</li><li>写回Cookie：lastTime=2018年6月10日11:50:01</li></ol></li><li>没有：是第一次访问<ol><li>响应数据：您好，欢迎您首次访问</li><li>写回Cookie：lastTime=2018年6月10日11:50:01</li></ol></li></ol></li></ol></li><li><p>代码实现：<br> package cn.itcast.cookie;</p><p> import javax.servlet.ServletException;<br> import javax.servlet.annotation.WebServlet;<br> import javax.servlet.http.Cookie;<br> import javax.servlet.http.HttpServlet;<br> import javax.servlet.http.HttpServletRequest;<br> import javax.servlet.http.HttpServletResponse;<br> import java.io.IOException;<br> import java.net.URLDecoder;<br> import java.net.URLEncoder;<br> import java.text.SimpleDateFormat;<br> import java.util.Date;</p></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@WebServlet(“/cookieTest”)<br>    public class CookieTest extends HttpServlet {<br>        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>            //设置响应的消息体的数据格式以及编码<br>            response.setContentType(“text/html;charset=utf-8”);</p><pre><code>        //1.获取所有Cookie        Cookie[] cookies = request.getCookies();        boolean flag = false;//没有cookie为lastTime        //2.遍历cookie数组        if(cookies != null &amp;&amp; cookies.length &gt; 0){            for (Cookie cookie : cookies) {                //3.获取cookie的名称                String name = cookie.getName();                //4.判断名称是否是：lastTime                if(&quot;lastTime&quot;.equals(name)){                    //有该Cookie，不是第一次访问                    flag = true;//有lastTime的cookie                    //设置Cookie的value                    //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie                    Date date  = new Date();                    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);                    String str_date = sdf.format(date);                    System.out.println(&quot;编码前：&quot;+str_date);                    //URL编码*(现在Tomcat一般都支持中文cookie了)                    str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);                    System.out.println(&quot;编码后：&quot;+str_date);                    cookie.setValue(str_date);                    //设置cookie的存活时间                    cookie.setMaxAge(60 * 60 * 24 * 30);//一个月                    response.addCookie(cookie);                    //响应数据                    //获取Cookie的value，时间                    String value = cookie.getValue();                    System.out.println(&quot;解码前：&quot;+value);                    //URL解码：                    value = URLDecoder.decode(value,&quot;utf-8&quot;);                    System.out.println(&quot;解码后：&quot;+value);                    response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次访问时间为:&quot;+value+&quot;&lt;/h1&gt;&quot;);                    break;                }            }        }        if(cookies == null || cookies.length == 0 || flag == false){            //没有，第一次访问            //设置Cookie的value            //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie            Date date  = new Date();            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);            String str_date = sdf.format(date);            System.out.println(&quot;编码前：&quot;+str_date);            //URL编码            str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);            System.out.println(&quot;编码后：&quot;+str_date);            Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date);            //设置cookie的存活时间            cookie.setMaxAge(60 * 60 * 24 * 30);//一个月            response.addCookie(cookie);            response.getWriter().write(&quot;&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;&quot;);        }    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doPost(request, response);    }}            </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 6.3 JSP入门</span><br></pre></td></tr></table></figure><ol><li>概念：<ul><li>Java Server Pages： java服务器端页面<ul><li>可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码</li><li>用于简化书写！！！</li></ul></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><p>原理</p><ul><li>JSP本质上就是一个Servlet</li></ul></li><li><p>JSP的脚本：JSP定义Java代码的方式</p><ol><li>&lt;%  代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。</li><li>&lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。</li><li>&lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><p>JSP的内置对象：</p><ul><li>在jsp页面中不需要获取和创建，可以直接使用的对象</li><li>jsp一共有9个内置对象。</li><li>今天学习3个：<ul><li>request</li><li>response</li><li>out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似<ul><li>response.getWriter()和out.write()的区别：<ul><li>在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。</li><li>response.getWriter()数据输出永远在out.write()之前</li></ul></li></ul></li></ul></li></ul></li><li><p>案例:改造Cookie案例</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 6.4 Session</span><br></pre></td></tr></table></figure><ol><li><p>概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p></li><li><p>快速入门：</p><ol><li>获取HttpSession对象：<br> HttpSession session = request.getSession();</li><li>使用HttpSession对象：<br> Object getAttribute(String name)<br> void setAttribute(String name, Object value)<br> void removeAttribute(String name)  </li></ol></li><li><p>原理</p><ul><li>Session的实现是依赖于Cookie的。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><p>细节：</p><ol><li><p>当客户端关闭后，服务器不关闭，两次获取session是否为同一个？</p><ul><li>默认情况下。不是。</li><li>如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。<br>   Cookie c = new Cookie(“JSESSIONID”,session.getId());<br>   c.setMaxAge(60*60);<br>   response.addCookie(c);</li></ul></li><li><p>客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</p><ul><li>不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作<ul><li>session的钝化：<ul><li>在服务器正常关闭之前，将session对象系列化到硬盘上</li></ul></li><li>session的活化：<ul><li>在服务器启动后，将session文件转化为内存中的session对象即可。</li></ul></li></ul></li></ul></li><li><p>session什么时候被销毁？</p><ol><li>服务器关闭</li><li>session对象调用invalidate() 。</li><li>session默认失效时间 30分钟<br> 选择性配置修改     <session-config>     <session-timeout>30</session-timeout> </session-config></li></ol></li></ol><ol start="5"><li><p>session的特点</p><ol><li>session用于存储一次会话的多次请求的数据，存在服务器端</li><li>session可以存储任意类型，任意大小的数据</li></ol><ul><li>session与Cookie的区别：<ol><li>session存储数据在服务器端，Cookie在客户端</li><li>session没有数据大小限制，Cookie有</li><li>session数据安全，Cookie相对于不安全</li></ol></li></ul></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 案例：验证码</span><br></pre></td></tr></table></figure><ol><li>案例需求：<ol><li>访问带有验证码的登录页面login.jsp</li><li>用户输入用户名，密码以及验证码。<ul><li>如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误</li><li>如果验证码输入有误，跳转登录页面，提示：验证码错误</li><li>如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您<br>步骤：在cn.cong.web.servlet.checkCodeServlet.java中<br>索引为<br>（1）创建一对象，在内存中图片（验证码图片对象）<br>width = 50 height = 60<br>BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);<br>（2）美化图片</li></ul> 2.1填充背景色<br> Graphics g = image.getGraphics();//画笔对象<br> g.setColor(Color.PINK);<br> g.fillRect(0,0,width,height);<br> 2.2话边框<br> g.setColor(Color.BLUE);<br> g.drawRect(0,0,width-1,height-1);<br> 2.3写验证码<br> String str = “ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789”<br> //生成随机角标<br> for(i=0;i&lt;4;i++){<pre><code>//获取随机字符int index = ran.nextInt(str.length());  //随机字符char ch = str.charAt(index);//写验证码g.drawString(ch,width/5*i,height/2);</code></pre> }<br> 2.4画干扰线<br> //随机生成干扰线<br> int X1= ran.nextInt(width);<br> int X2= ran.nextInt(width);<br> int y1= ran.nextInt(height);<br> int y2= ran.nextInt(height);<br> g.setColor(Color.GREEN);<br> g.drawLine(X1,X2,y1,y2)<br>（3）将图片输出到页面展示<br> ImageIO.write(image,”jpg”,response.getOutputStream());</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前端界面</p><script>//点击超链接或者图片，需要换一张//1、给超链接和图片绑定事件//2、重新设定图片的src属性值window.onload = function(){    //获取图片对象    var img = document.getElementById("checkCode");    //绑定单击事件    img.onclick = function(){        //因为浏览器会缓存图片，为了是验证码改变，在连接后面加一个永不重复的参数-时间戳        var date = new Date().getTime();        image.src = "/checkCodeServlet?"+date     }}</script><body>    <img id = "checkCode" src = "/cong/checkCodeServlet"/>    <a id = "change" href="">看不清换一张<></body><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 7、JSP: 详解</span><br><span class="line"></span><br><span class="line">1.</span><br></pre></td></tr></table></figure><ol><li><p>JSP:</p><ol><li>指令</li><li>注释</li><li>内置对象</li></ol></li><li><p>MVC开发模式</p></li><li><p>EL表达式</p></li><li><p>JSTL标签</p></li><li><p>三层架构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">### 7.1 JSP</span><br></pre></td></tr></table></figure><ol><li>指令</li></ol><ul><li>作用：用于配置JSP页面，导入资源文件</li><li>格式：<br>&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 … %&gt;</li><li>分类：<ol><li>page        ： 配置JSP页面的<ul><li>contentType：等同于response.setContentType()<ol><li>设置响应体的mime类型以及字符集</li><li>设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）</li></ol></li><li>import：导包</li><li>errorPage：当前页面发生异常后，会自动跳转到指定的错误页面</li><li>isErrorPage：标识当前也是是否是错误页面。<ul><li>true：是，可以使用内置对象exception</li><li>false：否。默认值。不可以使用内置对象exception</li></ul></li></ul></li><li>include    ： 页面包含的。导入页面的资源文件<ul><li>&lt;%@include file=”top.jsp”%&gt;</li></ul></li><li>taglib    ： 导入资源<ul><li>&lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;<ul><li>prefix：前缀，自定义的</li></ul></li></ul></li></ol></li></ul><ol start="2"><li>注释:<ol><li>html注释：<!-- -->:只能注释html代码片段</li><li>jsp注释：推荐使用<br>&lt;%– –%&gt;：可以注释所有</li></ol></li><li>内置对象</li></ol><ul><li>在jsp页面中不需要创建，直接使用的对象</li><li>一共有9个：<pre><code>变量名                    真实类型                        作用</code></pre><ul><li>pageContext                PageContext                    当前页面共享数据，还可以获取其他八个内置对象</li><li>request                    HttpServletRequest            一次请求访问的多个资源(转发)</li><li>session                    HttpSession                    一次会话的多个请求间</li><li>application                ServletContext                所有用户间共享数据</li><li>response                    HttpServletResponse            响应对象</li><li>page                        Object                        当前页面(Servlet)的对象  this</li><li>out                        JspWriter                    输出对象，数据输出到页面上</li><li>config                    ServletConfig                Servlet的配置对象</li><li>exception                    Throwable                    异常对象</li></ul></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 7.2MVC开发模式</span><br></pre></td></tr></table></figure><ol><li><p>jsp演变历史</p><ol><li>早期只有servlet，只能使用response输出标签数据，非常麻烦</li><li>后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作</li><li>再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性</li></ol></li><li><p>MVC：</p><ol><li>M：Model，模型。JavaBean<ul><li>完成具体的业务操作，如：查询数据库，封装对象</li></ul></li><li>V：View，视图。JSP<ul><li>展示数据</li></ul></li><li>C：Controller，控制器。Servlet<ul><li>获取用户的输入</li><li>调用模型</li><li>将数据交给视图进行展示</li></ul></li></ol><ul><li><p>优缺点：</p><ol><li><p>优点：</p><ol><li>耦合性低，方便维护，可以利于分工协作</li><li>重用性高</li></ol></li><li><p>缺点：</p><ol><li>使得项目架构变得复杂，对开发人员要求高<br>三层架构：软件设计架构</li></ol></li></ol></li></ul></li><li><p>界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互</p></li><li><p>业务逻辑层：处理业务逻辑的。</p></li><li><p>数据访问层：操作数据存储文件。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 7.3EL表达式</span><br></pre></td></tr></table></figure><ol><li><p>概念：Expression Language 表达式语言</p></li><li><p>作用：替换和简化jsp页面中java代码的编写</p></li><li><p>语法：${表达式}</p></li><li><p>注意：</p><ul><li>jsp默认支持el表达式的。如果要忽略el表达式<ol><li>设置jsp中page指令中：isELIgnored=”true” 忽略当前jsp页面中所有的el表达式</li><li>${表达式} ：忽略当前这个el表达式</li></ol></li></ul></li><li><p>使用：</p><ol><li><p>运算：</p><ul><li>运算符：<ol><li>算数运算符： + - * /(div) %(mod)</li><li>比较运算符： &gt; &lt; &gt;= &lt;= == !=</li><li>逻辑运算符： &amp;&amp;(and) ||(or) !(not)</li><li>空运算符： empty<ul><li>功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0</li><li>${empty list}:判断字符串、集合、数组对象是否为null或者长度为0</li><li>${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0</li></ul></li></ol></li></ul></li><li><p>获取值</p><ol><li><p>el表达式只能从域对象中获取值</p></li><li><p>语法：</p><ol><li><p>${域名称.键名}：从指定域中获取指定键的值</p><ul><li>域名称：<ol><li>pageScope        –&gt; pageContext</li><li>requestScope     –&gt; request</li><li>sessionScope     –&gt; session</li><li>applicationScope –&gt; application（ServletContext）</li></ol></li><li>举例：在request域中存储了name=张三</li><li>获取：${requestScope.name}</li></ul></li><li><p>${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</p></li><li><p>获取对象、List集合、Map集合的值</p><ol><li><p>对象：${域名称.键名.属性名}</p><ul><li>本质上会去调用对象的getter方法</li></ul></li><li><p>List集合：${域名称.键名[索引]}</p></li><li><p>Map集合：</p><ul><li>${域名称.键名.key名称}</li><li>${域名称.键名[“key名称”]}</li></ul></li></ol></li></ol></li><li><p>隐式对象：</p><ul><li>el表达式中有11个隐式对象</li><li>pageContext：<ul><li>获取jsp其他八个内置对象<ul><li>${pageContext.request.contextPath}：动态获取虚拟目录</li></ul></li></ul></li></ul></li></ol></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 案例：用户信息列表展示</span><br></pre></td></tr></table></figure><ol><li><p>需求：用户信息的增删改查操作</p></li><li><p>设计：</p><ol><li>技术选型：Servlet+JSP+MySQL+JDBCTempleat+Duird+BeanUtilS+tomcat</li><li>数据库设计：<br> create database day17; – 创建数据库<br> use day17;                – 使用数据库<br> create table user(   – 创建表<pre><code>id int primary key auto_increment,name varchar(20) not null,gender varchar(5),age int,address varchar(32),qq    varchar(20),email varchar(50)</code></pre> );</li></ol></li><li><p>开发：</p><ol><li><p>环境搭建</p><ol><li>创建数据库环境</li><li>创建项目，导入需要的jar包</li></ol></li><li><p>编码</p></li></ol></li><li><p>测试</p></li><li><p>部署运维</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 8、Filter：过滤器</span><br></pre></td></tr></table></figure><ol><li><p>概念：</p><ul><li>生活中的过滤器：净水器,空气净化器，土匪、</li><li>web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</li><li>过滤器的作用：<ul><li>一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤…</li></ul></li></ul></li><li><p>快速入门：</p><ol><li><p>步骤：</p><ol><li>定义一个类，实现接口Filter</li><li>复写方法</li><li>配置拦截路径<ol><li>web.xml</li><li>注解</li></ol></li></ol></li><li><p>代码：<br> @WebFilter(“/*”)//访问所有资源之前，都会执行该过滤器<br> public class FilterDemo1 implements Filter {</p><pre><code>@Overridepublic void init(FilterConfig filterConfig) throws ServletException {}@Overridepublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {    System.out.println(&quot;filterDemo1被执行了....&quot;);                    //放行    filterChain.doFilter(servletRequest,servletResponse);}@Overridepublic void destroy() {}</code></pre><p> }</p></li></ol></li><li><p>过滤器细节：</p><ol><li><p>web.xml配置    </p> <filter>     <filter-name>demo1</filter-name>     <filter-class>cn.itcast.web.filter.FilterDemo1</filter-class> </filter> <filter-mapping>     <filter-name>demo1</filter-name>     <!-- 拦截路径 -->     <url-pattern>/*</url-pattern> </filter-mapping></li><li><p>过滤器执行流程</p><ol><li>执行过滤器</li><li>执行放行后的资源</li><li>回来执行过滤器放行代码下边的代码</li></ol></li><li><p>过滤器生命周期方法</p><ol><li>init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源</li><li>doFilter:每一次请求被拦截资源时，会执行。执行多次</li><li>destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源</li></ol></li><li><p>过滤器配置详解</p><ul><li>拦截路径配置：<ol><li>具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行</li><li>拦截目录： /user/*    访问/user下的所有资源时，过滤器都会被执行</li><li>后缀名拦截： *.jsp        访问所有后缀名为jsp资源时，过滤器都会被执行</li><li>拦截所有资源：/*        访问所有资源时，过滤器都会被执行</li></ol></li><li>拦截方式配置：资源被访问的方式<ul><li>注解配置：<ul><li>设置dispatcherTypes属性<ol><li>REQUEST：默认值。浏览器直接请求资源</li><li>FORWARD：转发访问资源</li><li>INCLUDE：包含访问资源</li><li>ERROR：错误跳转资源</li><li>ASYNC：异步访问资源</li></ol></li></ul></li><li>web.xml配置<ul><li>设置<dispatcher></dispatcher>标签即可</li></ul></li></ul></li></ul></li><li><p>过滤器链(配置多个过滤器)</p><ul><li><p>执行顺序：如果有两个过滤器：过滤器1和过滤器2</p><ol><li>过滤器1</li><li>过滤器2</li><li>资源执行</li><li>过滤器2</li><li>过滤器1 </li></ol></li><li><p>过滤器先后顺序问题：</p><ol><li>注解配置：按照类名的字符串比较规则比较，值小的先执行<ul><li>如： AFilter 和 BFilter，AFilter就先执行了。</li></ul></li><li>web.xml配置： <filter-mapping>谁定义在上边，谁先执行</li></ol></li></ul></li></ol></li><li><p>案例：</p><ol><li><p>案例1_登录验证</p><ul><li>需求：<ol><li>访问day17_case案例的资源。验证其是否登录</li><li>如果登录了，则直接放行。</li><li>如果没有登录，则跳转到登录页面，提示”您尚未登录，请先登录”。</li></ol></li></ul></li><li><p>案例2_敏感词汇过滤</p><ul><li><p>需求：</p><ol><li>对day17_case案例录入的数据进行敏感词汇过滤</li><li>敏感词汇参考《敏感词汇.txt》</li><li>如果是敏感词汇，替换为 *** </li></ol></li><li><p>分析：</p><ol><li>对request对象进行增强。增强获取参数相关方法</li><li>放行。传递代理对象</li></ol></li><li><p>增强对象的功能：</p><ul><li>设计模式：一些通用的解决固定问题的方式</li></ul><ol><li><p>装饰模式</p></li><li><p>代理模式</p><ul><li><p>概念：</p><ol><li><p>真实对象：被代理的对象</p></li><li><p>代理对象：</p></li><li><p>代理模式：代理对象代理真实对象，达到增强真实对象功能的目的</p><ul><li>实现方式：</li></ul><ol><li><p>静态代理：有一个类文件描述代理模式</p></li><li><p>动态代理：在内存中形成代理类</p><ul><li><p>实现步骤：</p><ol><li>代理对象和真实对象实现相同的接口</li><li>代理对象 = Proxy.newProxyInstance();</li><li>使用代理对象调用方法。</li><li>增强方法</li></ol></li><li><p>增强方式：</p><ol><li>增强参数列表</li><li>增强返回值类型</li><li>增强方法体执行逻辑    </li></ol></li></ul></li></ol></li></ol></li></ul></li></ol></li></ul></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 8.1 Listener：监听器</span><br></pre></td></tr></table></figure><ul><li>概念：web的三大组件之一。<ul><li>事件监听机制<ul><li>事件    ：一件事情</li><li>事件源 ：事件发生的地方</li><li>监听器 ：一个对象</li><li>注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>概念：web的三大组件之一。<ul><li>事件监听机制<ul><li>事件    ：一件事情</li><li>事件源 ：事件发生的地方</li><li>监听器 ：一个对象</li><li>注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>ServletContextListener:监听ServletContext对象的创建和销毁<ul><li>方法：<ul><li>void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法</li><li>void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法</li></ul></li><li>步骤：<ol><li>定义一个类，实现ServletContextListener接口</li><li>复写方法</li><li>配置<ol><li>web.xml<pre><code>&lt;listener&gt;  &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;</code></pre><ul><li>指定初始化参数<context-param></li></ul></li><li>注解：<ul><li>@WebListener</li></ul></li></ol></li></ol></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 9、AJAX和JSON</span><br><span class="line"></span><br><span class="line">### 9.1 AJAX</span><br></pre></td></tr></table></figure><ol><li><p>概念： ASynchronous JavaScript And XML    异步的JavaScript 和 XML</p><ol><li><p>异步和同步：客户端和服务器端相互通信的基础上</p><ul><li><p>客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。</p></li><li><p>客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。</p><p>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1]<br>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<br>传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</p><p>提升用户的体验</p></li></ul></li></ol></li><li><p>实现方式：</p><ol><li><p>原生的JS实现方式（了解）</p><pre><code> //1.创建核心对象var xmlhttp;if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari    xmlhttp=new XMLHttpRequest();}else{// code for IE6, IE5    xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);}//2. 建立连接/*    参数：        1. 请求方式：GET、POST            * get方式，请求参数在URL后边拼接。send方法为空参            * post方式，请求参数在send方法中定义        2. 请求的URL：        3. 同步或异步请求：true（异步）或 false（同步） */xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true);//3.发送请求xmlhttp.send();//4.接受并处理来自服务器的响应结果//获取方式 ：xmlhttp.responseText//什么时候获取？当服务器响应成功后再获取//当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。xmlhttp.onreadystatechange=function(){    //判断readyState就绪状态是否为4，判断status响应状态码是否为200    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)    {       //获取服务器的响应结果        var responseText = xmlhttp.responseText;        alert(responseText);    }}</code></pre></li><li><p>JQeury实现方式</p><ol><li><p>$.ajax()</p><ul><li><p>语法：$.ajax({键值对});<br>//使用$.ajax()发送异步请求<br>  $.ajax({</p><pre><code>url:&quot;ajaxServlet1111&quot; , // 请求路径type:&quot;POST&quot; , //请求方式//data: &quot;username=jack&amp;age=23&quot;,//请求参数data:{&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23},success:function (data) {    alert(data);},//响应成功后的回调函数error:function () {    alert(&quot;出错啦...&quot;)},//表示如果请求响应出现错误，会执行的回调函数dataType:&quot;text&quot;//设置接受到的响应数据的格式</code></pre><p>  });</p></li></ul></li><li><p>$.get()：发送get请求</p><ul><li>语法：$.get(url, [data], [callback], [type])<ul><li>参数：<ul><li>url：请求路径</li><li>data：请求参数</li><li>callback：回调函数</li><li>type：响应结果的类型</li></ul></li></ul></li></ul></li><li><p>$.post()：发送post请求</p><ul><li>语法：$.post(url, [data], [callback], [type])<ul><li>参数：<ul><li>url：请求路径</li><li>data：请求参数</li><li>callback：回调函数</li><li>type：响应结果的类型</li></ul></li></ul></li></ul></li></ol></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 9.2 JSON</span><br></pre></td></tr></table></figure><ol><li><p>概念： JavaScript Object Notation        JavaScript对象表示法<br> Person p = new Person();<br> p.setName(“张三”);<br> p.setAge(23);<br> p.setGender(“男”);</p><p> var p = {“name”:”张三”,”age”:23,”gender”:”男”};</p><ul><li>json现在多用于存储和交换文本信息的语法</li><li>进行数据的传输</li><li>JSON 比 XML 更小、更快，更易解析。</li></ul></li><li><p>语法：</p><ol><li><p>基本规则</p><ul><li>数据在名称/值对中：json数据是由键值对构成的<ul><li>键用引号(单双都行)引起来，也可以不使用引号</li><li>值得取值类型：<ol><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在方括号中）    {“persons”:[{},{}]}</li><li>对象（在花括号中） {“address”:{“province”：”陕西”….}}</li><li>null</li></ol></li></ul></li><li>数据由逗号分隔：多个键值对由逗号分隔</li><li>花括号保存对象：使用{}定义json 格式</li><li>方括号保存数组：[]</li></ul></li><li><p>获取数据:</p><ol><li><p>json对象.键名</p></li><li><p>json对象[“键名”]</p></li><li><p>数组对象[索引]</p></li><li><p>遍历</p><pre><code> //1.定义基本格式var person = {&quot;name&quot;: &quot;张三&quot;, age: 23, &apos;gender&apos;: true};var ps = [{&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true},    {&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true},    {&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false}];    //获取person对象中所有的键和值       //for in 循环       /* for(var key in person){        //这样的方式获取不行。因为相当于  person.&quot;name&quot;            //alert(key + &quot;:&quot; + person.key);        alert(key+&quot;:&quot;+person[key]);    }*/       //获取ps中的所有值    for (var i = 0; i &lt; ps.length; i++) {        var p = ps[i];        for(var key in p){            alert(key+&quot;:&quot;+p[key]);        }    }</code></pre></li></ol></li></ol></li><li><p>JSON数据和Java对象的相互转换</p><ul><li>JSON解析器：<ul><li>常见的解析器：Jsonlib，Gson，fastjson，jackson</li></ul></li></ul><ol><li><p>JSON转为Java对象</p><ol><li>导入jackson的相关jar包</li><li>创建Jackson核心对象 ObjectMapper</li><li>调用ObjectMapper的相关方法进行转换<ol><li>readValue(json字符串数据,Class)</li></ol></li></ol></li><li><p>Java对象转换JSON</p><ol><li><p>使用步骤：</p><ol><li><p>导入jackson的相关jar包</p></li><li><p>创建Jackson核心对象 ObjectMapper</p></li><li><p>调用ObjectMapper的相关方法进行转换</p><ol><li><p>转换方法：</p><ul><li>writeValue(参数1，obj):<br>  参数1：<pre><code>File：将obj对象转换为JSON字符串，并保存到指定的文件中Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</code></pre></li><li>writeValueAsString(obj):将对象转为json字符串</li></ul></li><li><p>注解：</p><ol><li>@JsonIgnore：排除属性。</li><li>@JsonFormat：属性值得格式化<ul><li>@JsonFormat(pattern = “yyyy-MM-dd”)</li></ul></li></ol></li><li><p>复杂java对象转换</p><ol><li>List：数组</li><li>Map：对象格式一致</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">案例</span><br></pre></td></tr></table></figure><ul><li>校验用户名是否存在<ol><li>服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：<ol><li>$.get(type):将最后一个参数type指定为”json”</li><li>在服务器端设置MIME类型<br> response.setContentType(“application/json;charset=utf-8”);</li></ol></li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 10、JQuery</span><br><span class="line"></span><br><span class="line">### 10.1 JQuery基础</span><br></pre></td></tr></table></figure><ol><li><p>概念： 一个JavaScript框架。简化JS开发</p><ul><li><p>jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨    是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优    化HTML文档操作、事件处理、动画设计和Ajax交互。</p></li><li><p>JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已</p></li></ul></li><li><p>快速入门</p><ol><li><p>步骤：</p><ol><li><p>下载JQuery</p><ul><li>目前jQuery有三个大版本：<br>  1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，<pre><code>功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)</code></pre>  2.x：不兼容ie678，很少有人使用，官方只做BUG维护，<pre><code>功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)</code></pre>  3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，<pre><code>一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）</code></pre></li><li>jquery-xxx.js 与 jquery-xxx.min.js区别：<ol><li>jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些</li><li>jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快</li></ol></li></ul></li><li><p>导入JQuery的js文件：导入min.js文件</p></li><li><p>使用<br> var div1 = $(“#div1”);<br> alert(div1.html());</p></li></ol></li></ol></li><li><p>JQuery对象和JS对象区别与转换</p><ol><li>JQuery对象在操作时，更加方便。</li><li>JQuery对象和js对象方法不通用的.</li><li>两者相互转换<ul><li>jq – &gt; js : jq对象[索引] 或者 jq对象.get(索引)</li><li>js – &gt; jq : $(js对象)</li></ul></li></ol></li><li><p>选择器：筛选具有相似特征的元素(标签)</p><ol><li><p>基本操作学习：</p><ol><li><p>事件绑定<br> //1.获取b1按钮<br> $(“#b1”).click(function(){</p><pre><code>alert(&quot;abc&quot;);</code></pre><p> });</p></li><li><p>入口函数<br>  $(function () {</p><pre><code>});</code></pre><p>  window.onload  和 $(function) 区别</p><pre><code>* window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉* $(function)可以定义多次的。</code></pre></li><li><p>样式控制：css方法<br>  // $(“#div1”).css(“background-color”,”red”);<br>   $(“#div1”).css(“backgroundColor”,”pink”);</p><ol start="2"><li>分类</li></ol></li><li><p>基本选择器</p><ol><li>标签选择器（元素选择器）<ul><li>语法： $(“html标签名”) 获得所有匹配标签名称的元素</li></ul></li><li>id选择器 <ul><li>语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素</li></ul></li><li>类选择器<ul><li>语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素</li></ul></li><li>并集选择器：<ul><li>语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素</li></ul></li></ol></li><li><p>层级选择器</p><ol><li>后代选择器<ul><li>语法： $(“A B “) 选择A元素内部的所有B元素        </li></ul></li><li>子选择器<ul><li>语法： $(“A &gt; B”) 选择A元素内部的所有B子元素</li></ul></li></ol></li><li><p>属性选择器</p><ol><li>属性名称选择器 <ul><li>语法： $(“A[属性名]”) 包含指定属性的选择器</li></ul></li><li>属性选择器<ul><li>语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器</li></ul></li><li>复合属性选择器<ul><li>语法： $(“A[属性名=’值’][]…”) 包含多个属性条件的选择器</li></ul></li></ol></li><li><p>过滤选择器</p><ol><li>首元素选择器 <ul><li>语法： :first 获得选择的元素中的第一个元素</li></ul></li><li>尾元素选择器 <ul><li>语法： :last 获得选择的元素中的最后一个元素</li></ul></li><li>非元素选择器<ul><li>语法： :not(selector) 不包括指定内容的元素</li></ul></li><li>偶数选择器<ul><li>语法： :even 偶数，从 0 开始计数</li></ul></li><li>奇数选择器<ul><li>语法： :odd 奇数，从 0 开始计数</li></ul></li><li>等于索引选择器<ul><li>语法： :eq(index) 指定索引元素</li></ul></li><li>大于索引选择器 <ul><li>语法： :gt(index) 大于指定索引元素</li></ul></li><li>小于索引选择器 <ul><li>语法： :lt(index) 小于指定索引元素</li></ul></li><li>标题选择器<ul><li>语法： :header 获得标题（h1~h6）元素，固定写法</li></ul></li></ol></li><li><p>表单过滤选择器</p><ol><li>可用元素选择器 <ul><li>语法： :enabled 获得可用元素</li></ul></li><li>不可用元素选择器 <ul><li>语法： :disabled 获得不可用元素</li></ul></li><li>选中选择器 <ul><li>语法： :checked 获得单选/复选框选中的元素</li></ul></li><li>选中选择器 <ul><li>语法： :selected 获得下拉框选中的元素</li></ul></li></ol></li></ol></li></ol></li><li><p>DOM操作</p><ol><li><p>内容操作</p><ol><li>html(): 获取/设置元素的标签体内容   <a><font>内容</font></a>  –&gt; <font>内容</font></li><li>text(): 获取/设置元素的标签体纯文本内容   <a><font>内容</font></a> –&gt; 内容</li><li>val()： 获取/设置元素的value属性值</li></ol></li><li><p>属性操作</p><ol><li><p>通用属性操作</p><ol><li>attr(): 获取/设置元素的属性</li><li>removeAttr():删除属性</li><li>prop():获取/设置元素的属性</li><li>removeProp():删除属性</li></ol><ul><li>attr和prop区别？<ol><li>如果操作的是元素的固有属性，则建议使用prop</li><li>如果操作的是元素自定义的属性，则建议使用attr</li></ol></li></ul></li><li><p>对class属性操作</p><ol><li>addClass():添加class属性值</li><li>removeClass():删除class属性值</li><li>toggleClass():切换class属性<ul><li>toggleClass(“one”): <ul><li>判断如果元素对象上存在class=”one”，则将属性值one删除掉。  如果元素对象上不存在class=”one”，则添加</li></ul></li></ul></li><li>css():</li></ol></li></ol></li><li><p>CRUD操作:</p><ol><li><p>append():父元素将子元素追加到末尾</p><ul><li>对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾</li></ul></li><li><p>prepend():父元素将子元素追加到开头</p><ul><li>对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头</li></ul></li><li><p>appendTo():</p><ul><li>对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾</li></ul></li><li><p>prependTo()：</p><ul><li>对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头</li></ul></li><li><p>after():添加元素到元素后边</p><ul><li>对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系</li></ul></li><li><p>before():添加元素到元素前边</p><ul><li>对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系</li></ul></li><li><p>insertAfter()</p><ul><li>对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系</li></ul></li><li><p>insertBefore()</p><ul><li>对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系</li></ul></li><li><p>remove():移除元素</p><ul><li>对象.remove():将对象删除掉</li></ul></li><li><p>empty():清空元素的所有后代元素。</p><ul><li>对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点</li></ul></li></ol></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 10.2 JQuery进阶</span><br></pre></td></tr></table></figure><ol><li>JQuery 高级<ol><li>动画</li><li>遍历</li><li>事件绑定</li><li>案例</li><li>插件</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>动画</p><ol><li><p>三种方式显示和隐藏元素</p><ol><li><p>默认显示和隐藏方式</p><ol><li><p>show([speed,[easing],[fn]])</p><ol><li>参数：<ol><li>speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000)</li><li>easing：用来指定切换效果，默认是”swing”，可用参数”linear”<ul><li>swing：动画执行时效果是 先慢，中间快，最后又慢</li><li>linear：动画执行时速度是匀速的</li></ul></li><li>fn：在动画完成时执行的函数，每个元素执行一次。</li></ol></li></ol></li><li><p>hide([speed,[easing],[fn]])</p></li><li><p>toggle([speed],[easing],[fn])</p></li></ol></li><li><p>滑动显示和隐藏方式</p><ol><li>slideDown([speed],[easing],[fn])</li><li>slideUp([speed,[easing],[fn]])</li><li>slideToggle([speed],[easing],[fn])</li></ol></li><li><p>淡入淡出显示和隐藏方式</p><ol><li>fadeIn([speed],[easing],[fn])</li><li>fadeOut([speed],[easing],[fn])</li><li>fadeToggle([speed,[easing],[fn]])</li></ol></li></ol></li></ol></li><li><p>遍历</p><ol><li><p>js的遍历方式</p><ul><li>for(初始化值;循环结束条件;步长)</li></ul></li><li><p>jq的遍历方式</p><ol><li><p>jq对象.each(callback)</p><ol><li><p>语法：<br> jquery对象.each(function(index,element){});</p><pre><code>* index:就是元素在集合中的索引* element：就是集合中的每一个元素对象* this：集合中的每一个元素对象</code></pre></li><li><p>回调函数返回值：</p><ul><li>true:如果当前function返回为false，则结束循环(break)。</li><li>false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)</li></ul></li></ol></li><li><p>$.each(object, [callback])</p></li><li><p>for..of: jquery 3.0 版本之后提供的方式<br> for(元素对象 of 容器对象)</p></li></ol></li></ol></li><li><p>事件绑定</p><ol><li><p>jquery标准的绑定方式</p><ul><li>jq对象.事件方法(回调函数)；</li><li>注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。<ul><li>表单对象.submit();//让表单提交</li></ul></li></ul></li><li><p>on绑定事件/off解除绑定</p><ul><li>jq对象.on(“事件名称”,回调函数)</li><li>jq对象.off(“事件名称”)<ul><li>如果off方法不传递任何参数，则将组件上的所有事件全部解绑</li></ul></li></ul></li><li><p>事件切换：toggle</p><ul><li><p>jq对象.toggle(fn1,fn2…)</p><ul><li>当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2…..</li></ul></li><li><p>注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。</p>   <script src="../js/jquery-migrate-1.0.0.js" type="text/javascript" charset="utf-8"></script></li></ul></li></ol></li><li><p>案例</p><ol><li><p>广告显示和隐藏</p> <!DOCTYPE html> <html> <head>     <meta charset="UTF-8">     <title>广告的自动显示与隐藏</title>     <style>         #content{width:100%;height:500px;background:#999}     </style><pre><code>&lt;!--引入jquery--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    /*        需求：            1. 当页面加载完，3秒后。自动显示广告            2. 广告显示5秒后，自动消失。        分析：            1. 使用定时器来完成。setTimeout (执行一次定时器)            2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display            3. 使用  show/hide方法来完成广告的显示     */    //入口函数，在页面加载完成之后，定义定时器，调用这两个方法    $(function () {       //定义定时器，调用adShow方法 3秒后执行一次       setTimeout(adShow,3000);       //定义定时器，调用adHide方法，8秒后执行一次        setTimeout(adHide,8000);    });    //显示广告    function adShow() {        //获取广告div，调用显示方法        $(&quot;#ad&quot;).show(&quot;slow&quot;);    }    //隐藏广告    function adHide() {        //获取广告div，调用隐藏方法        $(&quot;#ad&quot;).hide(&quot;slow&quot;);    }    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 整体的DIV --&gt;&lt;div&gt;    &lt;!-- 广告DIV --&gt;    &lt;div id=&quot;ad&quot; style=&quot;display: none;&quot;&gt;    &lt;/div&gt;&lt;!-- 下方正文部分 --&gt;&lt;div id=&quot;content&quot;&gt;    正文部分&lt;/div&gt;</code></pre> </div> </body> </html>    </li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>2. 抽奖    &lt;!DOCTYPE html&gt;    &lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;jquery案例之抽奖&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;        &lt;script language=&apos;javascript&apos; type=&apos;text/javascript&apos;&gt;            /*                分析：                    1. 给开始按钮绑定单击事件                        1.1 定义循环定时器                        1.2 切换小相框的src属性                            * 定义数组，存放图片资源路径                            * 生成随机数。数组索引                       2. 给结束按钮绑定单击事件                        1.1 停止定时器                        1.2 给大相框设置src属性             */            var imgs = [&quot;../img/man00.jpg&quot;,                        &quot;../img/man01.jpg&quot;,                        &quot;../img/man02.jpg&quot;,                        &quot;../img/man03.jpg&quot;,                        &quot;../img/man04.jpg&quot;,                        &quot;../img/man05.jpg&quot;,                        &quot;../img/man06.jpg&quot;,                        ];            var startId;//开始定时器的id            var index;//随机角标            $(function () {                //处理按钮是否可以使用的效果                $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);                $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);                  //1. 给开始按钮绑定单击事件                $(&quot;#startID&quot;).click(function () {                    // 1.1 定义循环定时器 20毫秒执行一次                    startId = setInterval(function () {                        //处理按钮是否可以使用的效果                        $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true);                        $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false);                        //1.2生成随机角标 0-6                        index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999                        //1.3设置小相框的src属性                        $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]);                    },20);                });                //2. 给结束按钮绑定单击事件                $(&quot;#stopID&quot;).click(function () {                    //处理按钮是否可以使用的效果                    $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);                    $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);                   // 1.1 停止定时器                    clearInterval(startId);                   // 1.2 给大相框设置src属性                    $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide();                    //显示1秒之后                    $(&quot;#img2ID&quot;).show(1000);                });            });         &lt;/script&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>&lt;/head&gt;&lt;body&gt;&lt;!-- 小像框 --&gt;&lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt;    &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt;&lt;/div&gt;&lt;!-- 大像框 --&gt;&lt;div        style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt;    &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt;&lt;/div&gt;&lt;!-- 开始按钮 --&gt;&lt;input        id=&quot;startID&quot;        type=&quot;button&quot;        value=&quot;点击开始&quot;        style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;&lt;!-- 停止按钮 --&gt;&lt;input        id=&quot;stopID&quot;        type=&quot;button&quot;        value=&quot;点击停止&quot;        style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;</code></pre><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、web相关概念&quot;&gt;&lt;a href=&quot;#1、web相关概念&quot; class=&quot;headerlink&quot; title=&quot;1、web相关概念&quot;&gt;&lt;/a&gt;1、web相关概念&lt;/h2&gt;&lt;p&gt;1.软件架构&lt;/p&gt;
&lt;p&gt;​    1、C/S：客户端/服务器端&lt;/p&gt;
&lt;p&gt;​
      
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/02/13/hello-world/"/>
    <id>http://yoursite.com/2020/02/13/hello-world/</id>
    <published>2020-02-13T02:58:40.639Z</published>
    <updated>2020-02-13T12:27:29.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hahahaheihei"><a href="#hahahaheihei" class="headerlink" title="hahahaheihei"></a>hahahaheihei</h1><p>测试博客首页</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hahahaheihei&quot;&gt;&lt;a href=&quot;#hahahaheihei&quot; class=&quot;headerlink&quot; title=&quot;hahahaheihei&quot;&gt;&lt;/a&gt;hahahaheihei&lt;/h1&gt;&lt;p&gt;测试博客首页&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
